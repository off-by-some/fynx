{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"FynX","text":"<p>FynX (\"Finks\") = Functional Yielding Observable Networks</p> <p> </p>"},{"location":"#fynx-python-reactive-state-management-library","title":"FynX - Python Reactive State Management Library","text":"<p>FynX is a lightweight, transparent reactive state management library for Python, inspired by MobX. It enables reactive programming patterns where state changes automatically propagate through your application, eliminating the need for manual state synchronization.</p>"},{"location":"#what-is-reactive-programming","title":"What is Reactive Programming?","text":"<p>Reactive programming is a paradigm where you declare how your application should respond to changes in data. Instead of manually updating UI elements, API calls, or derived values when data changes, you define relationships between data and let the framework handle the updates automatically.</p> <p>FynX makes reactive programming in Python simple and intuitive - no complex syntax or framework-specific patterns required. Just use regular Python objects and let FynX handle the reactivity behind the scenes.</p>"},{"location":"#core-concepts","title":"Core Concepts","text":"<p>Observables: Values that can be watched for changes. When an observable value changes, all dependent computations and reactions automatically update.</p> <p>Computed Values: Derived values that automatically recalculate when their dependencies change, with built-in memoization for performance.</p> <p>Reactions: Functions that run automatically when their observed dependencies change, enabling side effects like UI updates or API calls.</p> <p>Stores: Classes that group related observables together with convenient subscription and state management methods.</p> <p>Conditional Reactions: Functions that only run when specific conditions are met, perfect for state machines, validation, and event filtering.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Transparent Reactivity: No special syntax needed - just use regular Python objects</li> <li>Automatic Dependency Tracking: Observables automatically track what depends on them</li> <li>Lazy Evaluation: Computed values only recalculate when needed</li> <li>Type Safety: Full type hint support for better IDE experience and static analysis</li> <li>Memory Efficient: Automatic cleanup of unused reactive contexts</li> <li>Composable: Easy to combine and nest reactive components</li> <li>Flexible Operators: Use <code>|</code>, <code>&gt;&gt;</code>, <code>&amp;</code>, and <code>~</code> operators for expressive reactive logic</li> </ul>"},{"location":"#quick-start-example","title":"Quick Start Example","text":"<pre><code>from fynx import Store, observable, computed, reactive, watch\n\n# Create a reactive store\nclass UserStore(Store):\n    name = observable(\"Alice\")\n    age = observable(30)\n    is_online = observable(False)\n\n    @computed\n    def greeting(self):\n        return f\"Hello, {self.name}! You are {self.age} years old.\"\n\n# React to all changes\n@reactive(UserStore.name, UserStore.age)\ndef on_user_change(name, age):\n    print(f\"User updated: {name}, {age}\")\n\n# React only when conditions are met\n@watch(\n    lambda: UserStore.is_online.value,\n    lambda: UserStore.age.value &gt;= 18\n)\ndef on_adult_online():\n    print(f\"Adult user {UserStore.name.value} is now online!\")\n\n# Changes trigger reactions automatically\nUserStore.name = \"Bob\"      # Prints: User updated: Bob, 30\nUserStore.age = 25          # Prints: User updated: Bob, 25\nUserStore.is_online = True  # Prints: Adult user Bob is now online!\n</code></pre>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install fynx\n</code></pre>"},{"location":"#documentation","title":"Documentation","text":"<ul> <li>API Reference - Complete API documentation</li> <li>Examples - Working examples and patterns</li> <li>GitHub Repository - Source code and issues</li> </ul>"},{"location":"#common-patterns","title":"Common Patterns","text":"<p>State Management: Group related data in Store classes for organized state management.</p> <p>Derived Data: Use computed values for data that depends on other data.</p> <p>Side Effects: Use reactive decorators for UI updates, API calls, or logging.</p> <p>Conditional Logic: Use watch decorators for state machines and conditional behavior.</p> <p>Data Flow: Use operators (<code>|</code>, <code>&gt;&gt;</code>, <code>&amp;</code>) for composing complex reactive relationships.</p>"},{"location":"#contributing","title":"Contributing","text":"<p>Contributions are welcome! Please see the GitHub repository for contribution guidelines.</p>"},{"location":"#license","title":"License","text":"<p>FynX is released under the MIT License. See the LICENSE file for details.</p>"},{"location":"1.0_TODO/","title":"Fynx Observable System - Product Specification for 1.0","text":"<p>Below is the roadmap for Fynx</p>"},{"location":"1.0_TODO/#1-overview","title":"1. Overview","text":"<p>A reactive observable system providing type-safe, composable primitives for finite state management and infinite stream processing with Pythonic operator semantics. Features deterministic concurrency handling through serialized propagation.</p>"},{"location":"1.0_TODO/#2-concurrency-model-threading-behavior","title":"2. Concurrency Model &amp; Threading Behavior","text":""},{"location":"1.0_TODO/#21-serialized-propagation-architecture","title":"2.1 Serialized Propagation Architecture","text":"<p>Description: All observables use an internal emission queue to ensure deterministic, race-free propagation regardless of emission source (sync thread, async coroutine, or background thread).</p> <p>Core Mechanism:</p> <ol> <li>Each observable (or the global system) maintains an internal emission queue</li> <li>Any emission (via <code>obs &lt;&lt; value</code>, assignment <code>obs = value</code>, or merged sources) enqueues the value</li> <li>A single propagation worker consumes the queue sequentially</li> <li>The worker recalculates derived observables, applies filters, and notifies subscribers in queue order</li> <li>Worker can be a dedicated thread or the current thread in single-threaded contexts</li> </ol> <p>Acceptance Criteria:</p> <ul> <li>[ ] All emissions are enqueued, never propagated directly on caller thread</li> <li>[ ] Propagation worker processes emissions sequentially in enqueue order</li> <li>[ ] Concurrent pushes from multiple threads/coroutines are serialized automatically</li> <li>[ ] No race conditions possible: subscribers never observe partial updates</li> <li>[ ] Merge order (<code>a @ b @ c</code>) determines transformation argument order deterministically</li> <li>[ ] Left-to-right evaluation: <code>(a @ b) @ c</code> processes <code>a</code>, then <code>b</code>, then <code>c</code> emissions in queue order</li> </ul>"},{"location":"1.0_TODO/#22-thread-safe-enqueueing","title":"2.2 Thread-Safe Enqueueing","text":"<p>Open Questions: * What is the non-sugar api for this?</p> <p>Acceptance Criteria:</p> <ul> <li>[ ] Push operations (<code>&lt;&lt;</code>, assignment) are thread-safe</li> <li>[ ] Uses thread-safe queue implementation (<code>queue.Queue</code> or equivalent with locks)</li> <li>[ ] Multiple threads can emit concurrently without coordination</li> <li>[ ] Enqueue operation returns immediately (non-blocking for caller)</li> <li>[ ] Propagation happens asynchronously on worker thread/context</li> </ul> <p>Example:</p> <pre><code>stream = InfiniteObservable()\n\n# Thread 1\nstream &lt;&lt; 1\n\n# Thread 2 (concurrent)\nstream &lt;&lt; 2\n\n# Both enqueued safely; propagated sequentially in arrival order\n</code></pre>"},{"location":"1.0_TODO/#23-asyncawait-integration","title":"2.3 Async/Await Integration","text":"<p>Acceptance Criteria:</p> <ul> <li>[ ] Supports <code>asyncio</code> integration via <code>asyncio.Queue</code> for propagation</li> <li>[ ] Sync context emissions use <code>loop.call_soon_threadsafe()</code> to enqueue</li> <li>[ ] Async context emissions can directly await queue operations</li> <li>[ ] Propagation coroutine processes emissions sequentially</li> <li>[ ] Users can emit from sync or async contexts transparently</li> <li>[ ] Subscribers can be sync or async callbacks (system handles both)</li> </ul> <p>Example:</p> <pre><code># Sync emission (from any thread)\nstream &lt;&lt; value  # Internally uses call_soon_threadsafe if async loop active\n\n# Async emission\nasync def process():\n    stream &lt;&lt; await fetch_data()\n\n# Async subscriber\nasync def async_handler(value):\n    await save_to_db(value)\n\nstream.subscribe(async_handler)  # System detects async and handles appropriately\n</code></pre>"},{"location":"1.0_TODO/#24-propagation-guarantees","title":"2.4 Propagation Guarantees","text":"<p>Acceptance Criteria:</p> <ul> <li>[ ] Deterministic ordering: Emissions processed in exact enqueue order</li> <li>[ ] Atomic propagation: Each emission propagates completely before next emission starts</li> <li>[ ] No race conditions: Derived observables never see partial/inconsistent state</li> <li>[ ] Subscriber safety: All subscribers receive same value in same propagation cycle</li> <li>[ ] Single propagation per emission: Each emission triggers exactly one propagation pass</li> <li>[ ] Merge consistency: Left-to-right merge order preserved across all propagations</li> </ul> <p>Example:</p> <pre><code>a = observable(1)\nb = observable(2)\nmerged = a @ b\nresult = merged &gt;&gt; (lambda x, y: x + y)  # x from a, y from b (deterministic)\n\n# Thread 1\na = 10\n\n# Thread 2 (concurrent)\nb = 20\n\n# Result sees either (10, 2) or (1, 20) or (10, 20)\n# Never partial like (10, &lt;uninitialized&gt;)\n# Order determined by queue arrival, but always consistent\n</code></pre>"},{"location":"1.0_TODO/#25-performance-considerations","title":"2.5 Performance Considerations","text":"<p>Latency:</p> <ul> <li>[ ] Slight overhead vs direct synchronous propagation (typically microseconds)</li> <li>[ ] Negligible for most applications</li> <li>[ ] Configurable queue processing batch size for high-throughput scenarios</li> </ul> <p>Backpressure:</p> <ul> <li>[ ] Optional max queue size to prevent unbounded memory growth</li> <li>[ ] Configurable overflow strategies: block, drop oldest, drop newest, raise error</li> <li>[ ] Monitoring API for queue depth inspection</li> </ul> <p>Example:</p> <pre><code># Configure backpressure (optional)\nstream = InfiniteObservable(max_queue_size=1000, overflow='drop_oldest')\n\n# Monitor queue health\nif stream.queue_depth() &gt; 900:\n    warnings.warn(\"Observable queue near capacity\")\n</code></pre>"},{"location":"1.0_TODO/#26-user-experience","title":"2.6 User Experience","text":"<p>Acceptance Criteria:</p> <ul> <li>[ ] No API changes required for threading/async support</li> <li>[ ] System automatically detects execution context (sync/async, thread)</li> <li>[ ] Users never need to manage locks, mutexes, or async context explicitly</li> <li>[ ] Standard operators (<code>&lt;&lt;</code>, <code>=</code>, <code>&gt;&gt;</code>, <code>@</code>) work identically regardless of threading</li> <li>[ ] Subscribers always see sequential, deterministic updates</li> <li>[ ] Optional configuration for advanced use cases (queue size, worker threads)</li> </ul> <p>Example:</p> <pre><code># Works identically in all contexts\nstream &lt;&lt; value  # Sync thread\nstream &lt;&lt; value  # Async coroutine\nstream &lt;&lt; value  # Background thread\n\n# User never sees:\n# - Race conditions\n# - Partial updates\n# - Lock/mutex management\n# - async/await complexity (unless desired)\n</code></pre>"},{"location":"1.0_TODO/#3-core-observable-types","title":"3. Core Observable Types","text":""},{"location":"1.0_TODO/#31-genericobservable-base-type","title":"3.1 GenericObservable (Base Type)","text":"<p>Description: Abstract supertype for all observable types. Provides common interface and enables polymorphic operations across all observable subtypes.</p> <p>Acceptance Criteria:</p> <ul> <li>[ ] All observable types inherit from <code>GenericObservable</code></li> <li>[ ] All operators (<code>&gt;&gt;</code>, <code>@</code>, <code>.where()</code>, <code>.subscribe()</code>) work on <code>GenericObservable</code> instances regardless of concrete subtype</li> <li>[ ] Type system is transparent to users - operations return appropriate concrete types without requiring type-specific logic</li> <li>[ ] Generic observables can be composed with any other generic observable using standard operators</li> <li>[ ] Runtime type determination follows documented promotion rules (e.g., Finite + Infinite \u2192 Infinite)</li> <li>[ ] All emissions go through serialized propagation queue (see Section 2)</li> </ul>"},{"location":"1.0_TODO/#32-finiteobservable","title":"3.2 FiniteObservable <p>Description: Single-valued reactive cell holding current value from discrete domain with serialized propagation.</p> <p>Acceptance Criteria:</p> <ul> <li>[ ] Holds exactly one value of type <code>T</code> at any moment</li> <li>[ ] Assignment enqueues value for propagation (not direct synchronous)</li> <li>[ ] Can be created via <code>observable(initial_value)</code> factory function</li> <li>[ ] Supports <code>obs = new_value</code> assignment syntax (thread-safe)</li> <li>[ ] Reading <code>.value</code> returns current value without triggering propagation</li> <li>[ ] Used as Store class property decorator: <code>property_name = observable(default)</code></li> <li>[ ] All dependent observables recalculate atomically during propagation worker pass</li> <li>[ ] Thread-safe: can be assigned from any thread</li> </ul> <p>Example:</p> <pre><code>counter = observable(5)\ndoubled = counter &gt;&gt; (lambda x: x * 2)\ncounter = 10  # Enqueued; doubled becomes 20 after propagation\n</code></pre>","text":""},{"location":"1.0_TODO/#33-infiniteobservable","title":"3.3 InfiniteObservable <p>Description: Unbounded stream of values emitted asynchronously over time with serialized propagation.</p> <p>Acceptance Criteria:</p> <ul> <li>[ ] Maintains sequence of emissions with no defined \u201cfinal\u201d value</li> <li>[ ] Created via <code>InfiniteObservable()</code> constructor</li> <li>[ ] Supports <code>&lt;&lt;</code> push operator: <code>stream &lt;&lt; value</code> (thread-safe)</li> <li>[ ] Supports merging another stream: <code>stream &lt;&lt; other_stream</code></li> <li>[ ] Each emission enqueued and triggers downstream propagation independently</li> <li>[ ] Concurrent emissions are serialized: multiple threads can push simultaneously</li> <li>[ ] Emissions processed in queue arrival order</li> <li>[ ] Can emit zero or more values over lifetime</li> <li>[ ] Can merge with transformed streams: <code>stream &lt;&lt; upload.map(fn)</code></li> <li>[ ] Push operations are non-blocking (return immediately after enqueueing)</li> </ul> <p>Memory Management:</p> <ul> <li>[ ] Subscriptions maintain reference to observable</li> <li>[ ] Unsubscribing releases subscription reference but not observable</li> <li>[ ] Long-lived infinite observables should be explicitly disposed when no longer needed</li> <li>[ ] Consider weak references for subscriber management to prevent memory leaks</li> </ul> <p>Concurrent Emission Example:</p> <pre><code>stream = InfiniteObservable()\n\n# Thread 1\nfor i in range(100):\n    stream &lt;&lt; i\n\n# Thread 2 (concurrent)\nfor i in range(100, 200):\n    stream &lt;&lt; i\n\n# Thread 3 (concurrent)\nfor i in range(200, 300):\n    stream &lt;&lt; i\n\n# All 300 emissions safely enqueued and propagated sequentially\n# Subscribers see values in queue arrival order (deterministic per run)\n</code></pre>","text":""},{"location":"1.0_TODO/#34-conditionalobservable","title":"3.4 ConditionalObservable <p>Description: Wrapper that filters emissions from source observable based on predicate with propagation queue integration.</p> <p>Acceptance Criteria:</p> <p>Core Filtering:</p> <ul> <li>[ ] Created via <code>.where(predicate)</code> method on any observable</li> <li>[ ] Predicate signature: <code>T \u2192 Bool</code></li> <li>[ ] Only propagates emissions where <code>predicate(value) == True</code></li> <li>[ ] Predicate evaluation happens in propagation worker context</li> <li>[ ] Preserves source type: <code>FiniteObservable.where()</code> \u2192 <code>FiniteObservable</code></li> <li>[ ] Preserves source type: <code>InfiniteObservable.where()</code> \u2192 <code>InfiniteObservable</code></li> <li>[ ] Thread-safe: source emissions can come from any thread</li> </ul> <p>Finite Source Semantics:</p> <ul> <li>[ ] Evaluates condition during propagation worker pass</li> <li>[ ] Suppresses downstream propagation when condition is <code>False</code></li> <li>[ ] No retroactive evaluation of past assignments</li> </ul> <p>Infinite Source Semantics:</p> <ul> <li>[ ] Acts as stream filter during propagation</li> <li>[ ] Does not affect previously emitted values</li> <li>[ ] Each emission independently evaluated against predicate in worker context</li> </ul> <p>Dynamic Conditions:</p> <ul> <li>[ ] Accepts observable predicates: <code>.where(condition_observable)</code></li> <li>[ ] Gates emissions based on current value of condition observable at propagation time</li> <li>[ ] For finite sources: checks condition during propagation worker pass</li> <li>[ ] For infinite sources: checks condition during propagation of each emission</li> </ul> <p>Composition:</p> <ul> <li>[ ] Chained <code>.where()</code> calls compose with AND logic</li> <li>[ ] <code>source.where(P1).where(P2)</code> equivalent to <code>source.where(lambda x: P1(x) and P2(x))</code></li> <li>[ ] Derived observables inherit conditional propagation</li> </ul> <p>Example:</p> <pre><code>stream = InfiniteObservable()\nevens = stream.where(lambda x: x % 2 == 0)\n\n# Thread-safe concurrent pushes\nstream &lt;&lt; 1  # suppressed during propagation\nstream &lt;&lt; 2  # evens emits 2 during propagation\nstream &lt;&lt; 3  # suppressed\nstream &lt;&lt; 4  # evens emits 4\n\ncondition = observable(True)\ngated = stream.where(condition)  # Checks condition at propagation time\n</code></pre>","text":""},{"location":"1.0_TODO/#35-mergedobservable","title":"3.5 MergedObservable <p>Description: Unified emission stream combining multiple source observables with deterministic propagation order.</p> <p>Acceptance Criteria:</p> <p>Core Merging:</p> <ul> <li>[ ] Created via <code>@</code> operator: <code>obs1 @ obs2 @ obs3</code></li> <li>[ ] Accepts 2+ source observables of same type <code>T</code></li> <li>[ ] Emits union of all source emissions: <code>\u22c3\u1d62 emissions(s\u1d62)</code></li> <li>[ ] Merge order is deterministic and left-to-right: <code>(a @ b) @ c</code> always processes <code>a</code>, then <code>b</code>, then <code>c</code></li> <li>[ ] Interleaves emissions in queue arrival order (within propagation worker)</li> <li>[ ] Concurrent emissions from different sources serialized by propagation queue</li> </ul> <p>Type Determination:</p> <ul> <li>[ ] All finite sources \u2192 <code>FiniteObservable&lt;T&gt;</code></li> <li>[ ] All infinite sources \u2192 <code>InfiniteObservable&lt;T&gt;</code></li> <li>[ ] Mixed finite + infinite \u2192 <code>InfiniteObservable&lt;T&gt;</code> (most dynamic type wins)</li> </ul> <p>Finite Source Behavior:</p> <ul> <li>[ ] Each source assignment enqueued for propagation</li> <li>[ ] Merged result emits during propagation pass</li> <li>[ ] Sequential assignments preserve per-source ordering in queue</li> </ul> <p>Infinite Source Behavior:</p> <ul> <li>[ ] Each emission enqueued independently</li> <li>[ ] Emissions interleaved in queue arrival order</li> <li>[ ] Thread-safe: sources can emit from different threads concurrently</li> </ul> <p>Mixed Source Behavior:</p> <ul> <li>[ ] Finite sources contribute current value snapshot during propagation</li> <li>[ ] Infinite sources contribute ongoing emissions via queue</li> <li>[ ] Result exhibits both discrete and continuous characteristics</li> </ul> <p>Edge Cases:</p> <ul> <li>[ ] Empty merge <code>MergedObservable()</code> with no sources raises <code>ValueError</code></li> <li>[ ] Single source merge <code>MergedObservable(s)</code> returns identity (equivalent to <code>s</code>)</li> </ul> <p>Algebraic Properties:</p> <ul> <li>[ ] Identity: <code>MergedObservable(s) \u2261 s</code></li> <li>[ ] Associativity: <code>(a @ b) @ c \u2261 a @ (b @ c)</code></li> <li>[ ] Type closure: Result is always an observable</li> <li>[ ] Deterministic ordering: merge order determines transformation argument order (guaranteed by propagation queue)</li> </ul> <p>Concurrent Emission Example:</p> <pre><code>stream1 = InfiniteObservable()\nstream2 = InfiniteObservable()\nmerged = stream1 @ stream2\n\n# Thread 1\nstream1 &lt;&lt; \"A1\"\nstream1 &lt;&lt; \"A2\"\n\n# Thread 2 (concurrent)\nstream2 &lt;&lt; \"B1\"\nstream2 &lt;&lt; \"B2\"\n\n# Propagation worker sees queue like: [A1, B1, A2, B2] (example order)\n# Subscribers see deterministic sequence based on queue arrival\n# Transform receives arguments in merge order (stream1 first, stream2 second)\n\nresult = merged &gt;&gt; (lambda v1, v2: f\"{v1}+{v2}\")\n# v1 always from stream1, v2 always from stream2 (deterministic merge order)\n</code></pre>","text":""},{"location":"1.0_TODO/#4-operators","title":"4. Operators","text":""},{"location":"1.0_TODO/#41-transform-operator","title":"4.1 Transform Operator (<code>&gt;&gt;</code>) <p>Description: Creates derived observable by applying transformation function during propagation. Never mutates source observable.</p> <p>Acceptance Criteria:</p> <ul> <li>[ ] Signature: <code>Observable&lt;T&gt; &gt;&gt; (T \u2192 U) \u2192 Observable&lt;U&gt;</code></li> <li>[ ] Works on <code>GenericObservable</code> regardless of concrete type</li> <li>[ ] Always creates new observable; source remains unchanged</li> <li>[ ] Derived observable recalculates during propagation worker pass</li> <li>[ ] Supports chaining: <code>obs &gt;&gt; f &gt;&gt; g &gt;&gt; h</code></li> <li>[ ] Lazy evaluation: computes only during propagation pass</li> <li>[ ] Type preservation: Finite \u2192 Finite, Infinite \u2192 Infinite</li> <li>[ ] Multi-argument functions receive values in merge order (deterministic, left-to-right, guaranteed by propagation queue)</li> <li>[ ] Chained transformations compose left-to-right</li> <li>[ ] Transformation function called once per emission/update during propagation</li> <li>[ ] Thread-safe: source emissions can originate from any thread</li> </ul> <p>Example:</p> <pre><code>result = counter &gt;&gt; (lambda x: x * 2) &gt;&gt; (lambda x: x + 10)\n# counter unchanged; result is new observable\n# Transformation happens in propagation worker\n\ntotal = (count @ price) &gt;&gt; (lambda c, p: c * p)\n# c=count, p=price (merge order, deterministic even with concurrent updates)\n</code></pre>","text":""},{"location":"1.0_TODO/#42-merge-operator","title":"4.2 Merge Operator (<code>@</code>) <p>Description: Combines multiple observables into unified stream with deterministic propagation order.</p> <p>Acceptance Criteria:</p> <ul> <li>[ ] Signature: <code>Observable&lt;T&gt; @ Observable&lt;T&gt; \u2192 MergedObservable&lt;T&gt;</code></li> <li>[ ] Works on <code>GenericObservable</code> instances</li> <li>[ ] Accepts 2+ operands: <code>a @ b @ c</code></li> <li>[ ] Associative: <code>(a @ b) @ c \u2261 a @ (b @ c)</code></li> <li>[ ] Deterministic left-to-right merge order preserved for downstream transformations (guaranteed by propagation queue)</li> <li>[ ] Result type follows type determination rules (section 3.5)</li> <li>[ ] Can be chained with <code>&gt;&gt;</code>: <code>(a @ b) &gt;&gt; transform_fn</code></li> <li>[ ] Raises <code>ValueError</code> if called with zero operands</li> <li>[ ] Thread-safe: operands can emit from different threads concurrently</li> </ul> <p>Example:</p> <pre><code>combined = obs1 @ obs2 @ obs3\nresult = combined &gt;&gt; (lambda v1, v2, v3: v1 + v2 + v3)\n# v1=obs1, v2=obs2, v3=obs3 (deterministic merge order)\n# Works correctly even if obs1, obs2, obs3 updated from different threads\n</code></pre>","text":""},{"location":"1.0_TODO/#43-filter-method-where","title":"4.3 Filter Method (<code>.where()</code>) <p>Description: Creates conditional observable filtering emissions during propagation.</p> <p>Acceptance Criteria:</p> <ul> <li>[ ] Signature: <code>Observable&lt;T&gt;.where(T \u2192 Bool) \u2192 ConditionalObservable&lt;T&gt;</code></li> <li>[ ] Signature (dynamic): <code>Observable&lt;T&gt;.where(Observable&lt;Bool&gt;) \u2192 ConditionalObservable&lt;T&gt;</code></li> <li>[ ] Works on <code>GenericObservable</code></li> <li>[ ] Returns <code>ConditionalObservable</code> preserving source type (Finite/Infinite)</li> <li>[ ] Chainable: <code>obs.where(p1).where(p2)</code> applies AND logic</li> <li>[ ] Can be combined with other operators: <code>obs.where(pred) &gt;&gt; transform</code></li> <li>[ ] Predicate evaluation happens in propagation worker context</li> <li>[ ] Thread-safe: source can emit from any thread</li> </ul> <p>Example:</p> <pre><code>positives = counter.where(lambda x: x &gt; 0)\nevens = stream.where(lambda x: x % 2 == 0)\nfiltered = obs.where(p1).where(p2) &gt;&gt; transform\n# All predicates evaluated during propagation worker pass\n</code></pre>","text":""},{"location":"1.0_TODO/#44-push-operator","title":"4.4 Push Operator (<code>&lt;&lt;</code>) <p>Description: Thread-safe emission into infinite observable stream via propagation queue.</p> <p>Acceptance Criteria:</p> <ul> <li>[ ] Signature: <code>InfiniteObservable&lt;T&gt; &lt;&lt; T \u2192 None</code></li> <li>[ ] Signature (merge): <code>InfiniteObservable&lt;T&gt; &lt;&lt; Observable&lt;T&gt; \u2192 None</code></li> <li>[ ] Only valid for <code>InfiniteObservable</code> instances</li> <li>[ ] Pushes single value: <code>stream &lt;&lt; value</code> (enqueues for propagation)</li> <li>[ ] Merges another observable: <code>stream &lt;&lt; other_observable</code></li> <li>[ ] Thread-safe: can be called from any thread concurrently</li> <li>[ ] Non-blocking: returns immediately after enqueueing</li> <li>[ ] Triggers downstream propagation during worker pass</li> <li>[ ] Returns <code>None</code> (side-effect only)</li> </ul> <p>Example:</p> <pre><code>stream &lt;&lt; 42  # Thread-safe, enqueued\nstream &lt;&lt; (upload &gt;&gt; process)  # Merge enqueued\n\n# Concurrent pushes (safe)\nthreading.Thread(target=lambda: stream &lt;&lt; 1).start()\nthreading.Thread(target=lambda: stream &lt;&lt; 2).start()\n# Both enqueued; propagated sequentially by worker\n</code></pre>","text":""},{"location":"1.0_TODO/#45-subscribe-method-subscribe","title":"4.5 Subscribe Method (<code>.subscribe()</code>) <p>Description: Registers callback to react to observable changes during propagation.</p> <p>Acceptance Criteria:</p> <ul> <li>[ ] Signature: <code>Observable&lt;T&gt;.subscribe(T \u2192 None) \u2192 Subscription</code></li> <li>[ ] Works on <code>GenericObservable</code></li> <li>[ ] Callback invoked during propagation worker pass for each emission/update</li> <li>[ ] Returns subscription object for unsubscription</li> <li>[ ] Subscription has <code>.unsubscribe()</code> method</li> <li>[ ] Multiple subscribers supported per observable</li> <li>[ ] Callbacks receive current/emitted value as argument</li> <li>[ ] Callbacks execute in propagation worker context (thread-safe by design)</li> <li>[ ] All subscribers see same value in same propagation cycle (no races)</li> </ul> <p>Memory Management:</p> <ul> <li>[ ] Subscription maintains reference to observable and callback</li> <li>[ ] Calling <code>.unsubscribe()</code> releases callback reference</li> <li>[ ] Observable maintains weak references to subscriptions where possible</li> <li>[ ] Unsubscribing does not dispose the observable itself</li> <li>[ ] Subscribers should explicitly unsubscribe when done to prevent memory leaks</li> </ul> <p>Example:</p> <pre><code>subscription = obs.subscribe(lambda x: print(f\"Value: {x}\"))\n# Callback invoked in propagation worker context (safe)\n\nsubscription.unsubscribe()  # Release callback reference\n</code></pre>","text":""},{"location":"1.0_TODO/#5-booleancomparison-operators","title":"5. Boolean/Comparison Operators","text":""},{"location":"1.0_TODO/#51-boolean-logic-operators","title":"5.1 Boolean Logic Operators <p>Description: Native boolean operations on observables producing reactive boolean results with propagation queue semantics.</p> <p>Acceptance Criteria:</p> <ul> <li>[ ] <code>&amp;</code> operator: <code>obs1 &amp; obs2</code> returns observable evaluating AND during propagation</li> <li>[ ] <code>|</code> operator: <code>obs1 | obs2</code> returns observable evaluating OR during propagation (distinct from merge <code>@</code>)</li> <li>[ ] <code>~</code> operator: <code>~obs</code> returns observable negating value during propagation</li> <li>[ ] Operators work element-wise on current values at propagation time</li> <li>[ ] For finite sources: produces <code>FiniteObservable&lt;bool&gt;</code></li> <li>[ ] For infinite sources: produces stream of boolean evaluations per emission</li> <li>[ ] Results are fully reactive: update during propagation when any operand changes</li> <li>[ ] Works on <code>GenericObservable</code> instances</li> <li>[ ] Thread-safe: operands can be updated from different threads</li> </ul> <p>Mixed Type Behavior:</p> <ul> <li>[ ] <code>FiniteObservable&lt;bool&gt; &amp; InfiniteObservable&lt;bool&gt;</code> \u2192 <code>InfiniteObservable&lt;bool&gt;</code></li> <li>[ ] Finite operand provides current value snapshot; infinite operand drives emission timing</li> <li>[ ] Result emits on each infinite stream emission, using latest finite value at propagation time</li> </ul> <p>Example:</p> <pre><code>ready = uploaded &amp; valid &amp; (~processing)\nany_active = stream1 | stream2  # Boolean OR, not merge\n# All evaluations happen in propagation worker (thread-safe)\n</code></pre>","text":""},{"location":"1.0_TODO/#52-comparison-operators","title":"5.2 Comparison Operators <p>Description: Comparison operators for observables returning reactive boolean observables with propagation semantics.</p> <p>Acceptance Criteria:</p> <ul> <li>[ ] Supports: <code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code></li> <li>[ ] Signature: <code>Observable&lt;T&gt; {op} T \u2192 Observable&lt;bool&gt;</code></li> <li>[ ] Signature: <code>Observable&lt;T&gt; {op} Observable&lt;T&gt; \u2192 Observable&lt;bool&gt;</code></li> <li>[ ] Returns reactive boolean observable</li> <li>[ ] Evaluates comparison during propagation worker pass</li> <li>[ ] Works with <code>@watch</code> decorator and standalone</li> <li>[ ] Works on <code>GenericObservable</code></li> <li>[ ] Thread-safe: operands can be updated from different threads</li> </ul> <p>Mixed Type Behavior:</p> <ul> <li>[ ] <code>FiniteObservable&lt;T&gt; &gt;= InfiniteObservable&lt;T&gt;</code> \u2192 <code>InfiniteObservable&lt;bool&gt;</code></li> <li>[ ] <code>InfiniteObservable&lt;T&gt; &gt;= FiniteObservable&lt;T&gt;</code> \u2192 <code>InfiniteObservable&lt;bool&gt;</code></li> <li>[ ] Finite operand provides current value snapshot at propagation time</li> <li>[ ] Infinite operand drives emission timing</li> <li>[ ] Each emission from infinite side triggers comparison with latest finite value during propagation</li> <li>[ ] <code>FiniteObservable&lt;T&gt; &gt;= FiniteObservable&lt;T&gt;</code> \u2192 <code>FiniteObservable&lt;bool&gt;</code> (updates when either changes)</li> <li>[ ] <code>InfiniteObservable&lt;T&gt; &gt;= InfiniteObservable&lt;T&gt;</code> \u2192 <code>InfiniteObservable&lt;bool&gt;</code> (emits when either emits)</li> </ul> <p>Example:</p> <pre><code>is_adult = age &gt;= 18\nis_equal = obs1 == obs2\nmatches = name == \"Alice\"\n\n# Mixed types\nexceeded = infinite_sensor &gt;= finite_threshold  # InfiniteObservable&lt;bool&gt;\n# Comparison happens in propagation worker using latest finite_threshold value\n</code></pre>","text":""},{"location":"1.0_TODO/#6-decorator-watch","title":"6. Decorator: <code>@watch</code>","text":"<p>Description: Executes function when all condition observables evaluate to <code>True</code> during propagation. Triggers on every emission/update that satisfies all conditions.</p> <p>Acceptance Criteria:</p> <ul> <li>[ ] Signature: <code>@watch(condition1, condition2, ...) def fn(): ...</code></li> <li>[ ] Accepts multiple condition observables/lambdas</li> <li>[ ] Conditions are lambda expressions returning observables: <code>lambda: age &gt;= 18</code></li> <li>[ ] Lambdas evaluated reactively during propagation: re-evaluates whenever any observable referenced inside changes</li> <li>[ ] Executes function when ALL conditions are <code>True</code> during propagation worker pass</li> <li>[ ] Triggers once per emission/update that satisfies all conditions (no debouncing by default)</li> <li>[ ] Re-evaluates reactively during propagation when any condition observable changes</li> <li>[ ] Supports boolean/comparison operators in conditions</li> <li>[ ] Does not require observables to be used exclusively in <code>@watch</code> context</li> <li>[ ] Each condition lambda may reference multiple observables; any change triggers re-evaluation during propagation</li> <li>[ ] Thread-safe: conditions evaluated in propagation worker context, safe from races</li> </ul> <p>Execution Semantics:</p> <ul> <li>[ ] Function executes in propagation worker context when conditions become <code>True</code></li> <li>[ ] No automatic debouncing or coalescing (user can implement if needed)</li> <li>[ ] If multiple observables change concurrently, executes once during propagation with latest values</li> </ul> <p>Example:</p> <pre><code>@watch(lambda: User.age &gt;= 18, lambda: User.email.endswith('.com'))\ndef process_eligible_user():\n    print(\"Eligible user detected!\")\n# Triggers during propagation when conditions become True\n# Safe even if User.age and User.email updated from different threads\n\n@watch(lambda: (sensor_reading &gt; threshold) &amp; sensor_active)\ndef alert():\n    print(\"Alert!\")\n# Triggers during propagation on each emission where condition is True\n# Evaluation happens in propagation worker (thread-safe)\n</code></pre>"},{"location":"1.0_TODO/#7-operator-summary-table","title":"7. Operator Summary Table","text":"Operator Signature Description Example <code>&gt;&gt;</code> <code>Observable&lt;T&gt; &gt;&gt; (T \u2192 U) \u2192 Observable&lt;U&gt;</code> Transform values (creates new observable) <code>doubled = x &gt;&gt; (lambda v: v * 2)</code> <code>@</code> <code>Observable&lt;T&gt; @ Observable&lt;T&gt; \u2192 MergedObservable&lt;T&gt;</code> Merge observables (deterministic order) <code>combined = a @ b</code> <code>.where()</code> <code>Observable&lt;T&gt;.where(T \u2192 Bool) \u2192 ConditionalObservable&lt;T&gt;</code> Filter emissions during propagation <code>pos = x.where(lambda v: v &gt; 0)</code> <code>&lt;&lt;</code> <code>InfiniteObservable&lt;T&gt; &lt;&lt; T \u2192 None</code> Thread-safe push to stream (enqueued) <code>stream &lt;&lt; value</code> <code>.subscribe()</code> <code>Observable&lt;T&gt;.subscribe(T \u2192 None) \u2192 Subscription</code> React to changes during propagation <code>obs.subscribe(print)</code> <code>&amp;</code> <code>Observable&lt;bool&gt; &amp; Observable&lt;bool&gt; \u2192 Observable&lt;bool&gt;</code> Boolean AND (evaluated during propagation) <code>ready = a &amp; b</code> <code>|</code> <code>Observable&lt;bool&gt; | Observable&lt;bool&gt; \u2192 Observable&lt;bool&gt;</code> Boolean OR (evaluated during propagation) <code>any_active = a | b</code> <code>~</code> <code>~Observable&lt;bool&gt; \u2192 Observable&lt;bool&gt;</code> Boolean NOT (evaluated during propagation) <code>inactive = ~active</code> <code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code> <code>Observable&lt;T&gt; {op} T \u2192 Observable&lt;bool&gt;</code> Comparison (evaluated during propagation) <code>adult = age &gt;= 18</code>"},{"location":"1.0_TODO/#8-design-principles","title":"8. Design Principles","text":"<p>Acceptance Criteria:</p> <ul> <li>[ ] Type preservation: Operations preserve or predictably promote types per documented rules</li> <li>[ ] Composability: All operators support nesting and chaining</li> <li>[ ] Transparency: Internal taxonomy hidden from users; all operations work on <code>GenericObservable</code></li> <li>[ ] Immutability: Transformations always create new observables; sources never mutated</li> <li>[ ] Determinism: Merge order is left-to-right and consistent; propagation queue ensures sequential processing</li> <li>[ ] Algebraic rigor: Identity, associativity, and type closure properties maintained</li> <li>[ ] Pythonic elegance: Uses familiar Python operators and method chaining</li> <li>[ ] Accessibility: No category theory knowledge required; intuitive semantics</li> <li>[ ] Memory safety: Clear subscription lifecycle; explicit cleanup prevents leaks</li> <li>[ ] Concurrency safety: Serialized propagation queue eliminates race conditions; thread-safe by design</li> <li>[ ] Performance: Minimal latency overhead; configurable backpressure handling</li> </ul>"},{"location":"1.0_TODO/#9-full-integration-example","title":"9. Full Integration Example","text":"<p>Acceptance Criteria:</p> <ul> <li>[ ] Following example works end-to-end with all specified features including threading:</li> </ul> <pre><code>class CartStore(Store):\n    item_count = observable(1)\n    price_per_item = observable(10.0)\n    discount_active = observable(False)\n\n# Merge observables (@ operator, deterministic order, thread-safe)\ncart_state = CartStore.item_count @ CartStore.price_per_item\n\n# Calculate subtotal (immutable transform, propagated via queue)\nsubtotal = cart_state &gt;&gt; (lambda count, price: count * price)\n\n# Apply discount conditionally (evaluated during propagation)\nfinal_price = (subtotal @ CartStore.discount_active) &gt;&gt; \\\n    (lambda total, discount: total * 0.9 if discount else total)\n\n# Subscribe to updates (callback runs in propagation worker context)\nsubscription = final_price.subscribe(lambda price: print(f\"Total: ${price:.2f}\"))\n\n# Changes propagate automatically via queue (thread-safe)\nCartStore.item_count = 3           # Enqueued \u2192 Total: $30.00\nCartStore.discount_active = True   # Enqueued \u2192 Total: $27.00\n\n# Thread-safe concurrent updates\nimport threading\nthreading.Thread(target=lambda: CartStore.item_count = 5).start()\nthreading.Thread(target=lambda: CartStore.price_per_item = 15.0).start()\n# Both enqueued; propagated sequentially; final_price sees consistent state\n\n# Cleanup\nsubscription.unsubscribe()\n\n# Boolean operators (| for OR, @ for merge)\npreview_ready = uploaded_file &amp; is_valid &amp; (~is_processing)\nany_error = validation_error | network_error  # Boolean OR\n\n# Mixed type comparisons with concurrent emissions\nsensor_stream = InfiniteObservable()\nthreshold = observable(100)\nalert_stream = sensor_stream &gt;= threshold  # InfiniteObservable&lt;bool&gt;\n\n# Thread-safe concurrent sensor updates\ndef sensor_thread():\n    for reading in sensor_readings:\n        sensor_stream &lt;&lt; reading  # Thread-safe push\n\nthreading.Thread(target=sensor_thread).start()\n\n# Watch decorator (reactive, per-emission trigger, thread-safe)\n@watch(lambda: User.age &gt;= 18, lambda: User.email.endswith('.com'))\ndef process_eligible_user():\n    print(\"Eligible user detected!\")\n# Conditions evaluated in propagation worker (safe from races)\n</code></pre>"},{"location":"1.0_TODO/#10-edge-cases-error-handling","title":"10. Edge Cases &amp; Error Handling","text":"<p>Acceptance Criteria:</p> <p>Empty Merge:</p> <ul> <li>[ ] <code>MergedObservable()</code> with no sources raises <code>ValueError</code> with message: \u201cCannot create merge with zero sources\u201d</li> <li>[ ] <code>a @ b @ ...</code> with at least one operand succeeds</li> </ul> <p>Mixed Type Merges:</p> <ul> <li>[ ] <code>FiniteObservable @ InfiniteObservable</code> produces <code>InfiniteObservable</code> (documented in 3.5)</li> <li>[ ] Finite values emit immediately via queue, infinite values emit over time via queue</li> <li>[ ] ConditionalObservable wrapping MergedObservable preserves result type rules</li> </ul> <p>Type Mismatches:</p> <ul> <li>[ ] Merging incompatible types (e.g., <code>Observable&lt;int&gt; @ Observable&lt;str&gt;</code>) raises <code>TypeError</code></li> <li>[ ] Comparison operators require comparable types or raise <code>TypeError</code></li> </ul> <p>Null/None Handling:</p> <ul> <li>[ ] Observables can hold <code>None</code> as valid value</li> <li>[ ] Predicates/transforms receive <code>None</code></li> </ul>"}]}