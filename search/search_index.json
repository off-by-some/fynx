{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"\ud83d\udea7 Documentation Under Construction <p>Hey! You got here early! FynX is still incredibly new, so we're still ironing out the documentation here. Thanks for your patience and early interest!</p>"},{"location":"#fynx","title":"FynX","text":"<p>FynX (\"Finks\") = Functional Yielding Observable Networks</p>"},{"location":"#overview","title":"Overview","text":"<p>FynX is a lightweight reactive state management library for Python that brings the elegance of reactive programming to your applications. Inspired by MobX, FynX eliminates the complexity of manual state synchronization by automatically propagating changes through your application's data flow. When one piece of state changes, everything that depends on it updates automatically\u2014no boilerplate, no explicit update calls, just transparent reactivity.</p>"},{"location":"#understanding-reactive-programming","title":"Understanding Reactive Programming","text":"<p>Traditional imperative programming requires you to manually orchestrate updates: when data changes, you must explicitly call update methods, refresh UI components, or invalidate caches. This creates brittle, error-prone code where it's easy to forget an update or create inconsistent states.</p> <p>Reactive programming inverts this model. Instead of imperatively triggering updates, you declare relationships between data. When a value changes, the framework automatically propagates that change to everything that depends on it. Think of it like a spreadsheet: when you change a cell, all formulas referencing that cell recalculate automatically. FynX brings this same automatic dependency tracking and update propagation to Python.</p> <p>What makes FynX special is its transparency. You don't need to learn special syntax or wrap everything in framework-specific abstractions. Just use normal Python objects and assignment\u2014FynX handles the reactivity behind the scenes through automatic dependency tracking.</p>"},{"location":"#core-concepts","title":"Core Concepts","text":"<p>FynX's design centers on four fundamental building blocks that work together to create reactive data flows:</p>"},{"location":"#observables","title":"Observables","text":"<p>Observables are the foundation of reactivity. An observable is simply a value that FynX watches for changes. When you modify an observable, FynX automatically notifies everything that depends on it. Think of observables as the source nodes in your application's dependency graph\u2014they're the raw state that drives everything else.</p>"},{"location":"#computed-values","title":"Computed Values","text":"<p>Computed values are derived data that automatically recalculates when their dependencies change. They provide memoization by default, meaning they only recompute when one of their inputs actually changes\u2014not on every access. This makes them both convenient and performant for expensive calculations. Computed values form the intermediate nodes in your dependency graph, transforming observables into the exact shape your application needs.</p>"},{"location":"#reactions","title":"Reactions","text":"<p>Reactions are side effects that execute automatically when their observed dependencies change. Use reactions for actions like updating a UI, making an API call, logging, or any other effect that should happen in response to state changes. While observables and computed values represent your data, reactions represent what your application does with that data.</p>"},{"location":"#stores","title":"Stores","text":"<p>Stores provide organizational structure by grouping related observables, computed values, and methods together. They offer convenient patterns for subscribing to changes and managing related state as a cohesive unit. Stores aren't required, but they help you organize complex state into logical, reusable components.</p>"},{"location":"#conditional-reactions","title":"Conditional Reactions","text":"<p>Conditional reactions extend the basic reaction pattern by only executing when specific conditions are met. They're perfect for implementing state machines, validation rules, or any scenario where you need fine-grained control over when effects trigger. This allows you to express complex conditional logic declaratively rather than scattering imperative checks throughout your code.</p>"},{"location":"#why-fynx","title":"Why FynX?","text":"<p>Transparent Reactivity: FynX requires no special syntax. Use standard Python assignment, method calls, and attribute access\u2014reactivity works automatically without wrapper objects or proxy patterns.</p> <p>Automatic Dependency Tracking: FynX observables track their dependents automatically during execution. You never manually register or unregister dependencies; the framework infers them from how your code actually runs.</p> <p>Lazy Evaluation with Memoization: Computed values only recalculate when their dependencies change, and only when accessed. This combines the convenience of automatic updates with the performance of intelligent caching.</p> <p>Full Type Safety: FynX provides complete type hints, giving you autocomplete, inline documentation, and static analysis throughout your reactive code.</p> <p>Memory Efficient: FynX automatically cleans up reactive contexts when they're no longer needed, preventing memory leaks in long-running applications.</p> <p>Composable Architecture: Observables, computed values, and reactions compose naturally. You can nest stores, chain computed values, and combine reactions to build complex reactive systems from simple, reusable pieces.</p> <p>Expressive Operators: FynX provides intuitive operators (<code>|</code>, <code>&gt;&gt;</code>, <code>&amp;</code>, <code>~</code>) that let you compose reactive logic clearly and concisely, making your data flow explicit and easy to understand.</p>"},{"location":"#quick-start-example","title":"Quick Start Example","text":"<p>Here's a complete example showing how FynX's concepts work together:</p> <pre><code>from fynx import Store, observable, computed, reactive, watch\n\n# Create a reactive store grouping related state\nclass UserStore(Store):\n    name = observable(\"Alice\")\n    age = observable(30)\n    is_online = observable(False)\n\n    # Computed property that automatically updates when dependencies change\n    greeting = (name | age) &gt;&gt; (\n        lambda n, a: f\"Hello, {n}! You are {a} years old.\"\n    )\n\n# React to any change in name or age\n@reactive(UserStore.name, UserStore.age)\ndef on_user_change(name, age):\n    print(f\"User updated: {name}, {age}\")\n\n# React only when specific conditions are met\n@watch(\n    lambda: UserStore.is_online.value,\n    lambda: UserStore.age.value &gt;= 18\n)\ndef on_adult_online():\n    print(f\"Adult user {UserStore.name.value} is now online!\")\n\n# Changes trigger appropriate reactions automatically\nUserStore.name = \"Bob\"      # Prints: User updated: Bob, 30\nUserStore.age = 25          # Prints: User updated: Bob, 25\nUserStore.is_online = True  # Prints: Adult user Bob is now online!\n</code></pre> <p>Notice how natural the code looks\u2014no explicit update calls, no subscription management, just straightforward Python that happens to be reactive.</p>"},{"location":"#installation","title":"Installation","text":"<p>Install FynX from PyPI using pip:</p> <pre><code>pip install fynx\n</code></pre> <p>FynX has no required dependencies and works with Python 3.8 and above.</p>"},{"location":"#common-patterns","title":"Common Patterns","text":"<p>As you work with FynX, you'll find these patterns emerge naturally:</p> <p>State Management: Group related observables in Store classes to create logical boundaries in your application. Each store becomes a self-contained module of state with its own computed values and methods.</p> <p>Derived Data: Use computed values whenever you need data that depends on other data. The automatic memoization means you can freely access computed values without worrying about performance\u2014they only recalculate when necessary.</p> <p>Side Effects: Attach reactions to observables for any effect that should happen in response to state changes: updating a UI, sending analytics, making API calls, or writing to a database.</p> <p>Conditional Logic: Use watch decorators to implement state machines, validation rules, or event filtering. This keeps conditional logic declarative and colocated with the relevant state.</p> <p>Data Flow Composition: Use FynX's operators (<code>|</code> for piping values, <code>&gt;&gt;</code> for chaining, <code>&amp;</code> for combining) to build clear, expressive data transformation pipelines.</p>"},{"location":"#documentation","title":"Documentation","text":"<ul> <li>API Reference - Complete API documentation with organized sections</li> <li>Examples - Working examples and patterns</li> <li>GitHub Repository - Source code and issues</li> </ul>"},{"location":"#contributing","title":"Contributing","text":"<p>We welcome contributions! Please visit the GitHub repository for contribution guidelines, issue tracking, and development setup instructions.</p>"},{"location":"#license","title":"License","text":"<p>FynX is released under the MIT License. See the LICENSE file for complete terms.</p>"},{"location":"generation/markdown/api/","title":"API Reference","text":"<p>This reference provides comprehensive documentation of FynX's public API. FynX is a reactive programming library that makes your application state respond automatically to changes\u2014think of it as a spreadsheet for your code, where updating one cell automatically recalculates all the formulas that depend on it.</p>"},{"location":"generation/markdown/api/#a-mental-model-for-fynx","title":"A Mental Model for FynX","text":"<p>Before diving into the API details, it helps to understand FynX's core philosophy:</p> <p>Traditional programming is imperative: You tell your code exactly when to update things. Change a variable here, update the UI there, recalculate this value over there. You're responsible for remembering all the connections.</p> <p>FynX is declarative: You describe relationships between values, and FynX handles the updates automatically. Change a value once, and everything that depends on it updates correctly, in the right order, every time.</p> <p>This mental shift\u2014from managing updates to declaring relationships\u2014is the key to thinking reactively.</p>"},{"location":"generation/markdown/api/#your-learning-path","title":"Your Learning Path","text":"<p>FynX's API is designed to be learned progressively, with each concept building on the previous one:</p> <ol> <li>Start with Observables \u2014 Learn to create reactive values that notify subscribers when they change</li> <li>Organize with Stores \u2014 Group related observables into cohesive units with clean APIs</li> <li>Filter Conditionally \u2014 Control when reactions occur based on runtime conditions</li> <li>Automate with Decorators \u2014 Eliminate boilerplate and express reactive relationships declaratively</li> </ol> <p>Each section in this reference assumes you understand the previous sections. If you encounter an unfamiliar concept, backtrack to the earlier pages.</p>"},{"location":"generation/markdown/api/#core-concepts","title":"Core Concepts","text":""},{"location":"generation/markdown/api/#observables-reactive-values","title":"Observables: Reactive Values","text":"<p>Observables are containers for values that change over time. Unlike regular variables, they automatically notify anyone who's interested when their values change.</p> <p>Observable \u2014 The foundation of FynX. Create observables with <code>observable(initial_value)</code>, read them with <code>.value</code>, write them with <code>.set(new_value)</code>. Every other FynX feature builds on this simple primitive.</p> <p>ComputedObservable \u2014 Values that automatically recalculate when their dependencies change. Create them with the <code>&gt;&gt;</code> operator: <code>full_name = (first | last) &gt;&gt; (lambda f, l: f\"{f} {l}\")</code>. The <code>&gt;&gt;</code> operator transforms observables through functions, creating a new computed observable. Alternatively, use the <code>computed(func, observable)</code> function for the same result with different syntax. FynX tracks dependencies automatically and ensures computed values always stay up-to-date.</p> <p>MergedObservable \u2014 Combine multiple observables into a single reactive tuple using the <code>|</code> operator: <code>position = x | y | z</code>. When any source changes, subscribers receive all values as a tuple. This is the foundation for reactive relationships that depend on multiple values.</p> <p>ConditionalObservable \u2014 Observables that only emit when conditions are satisfied. Create them with the <code>&amp;</code> operator: <code>valid_submission = form_data &amp; is_valid</code>. This enables sophisticated reactive logic without cluttering your code with conditional checks.</p> <p>Observable Descriptors \u2014 The mechanism behind Store class attributes. When you write <code>name = observable(\"Alice\")</code> in a Store class, you're creating a descriptor that provides clean property access without <code>.value</code> or <code>.set()</code>.</p> <p>Observable Operators \u2014 The operators (<code>|</code>, <code>&gt;&gt;</code>, <code>&amp;</code>, <code>~</code>) that let you compose observables into reactive pipelines. The <code>&gt;&gt;</code> operator is the primary way to transform observables, passing values through functions. Understanding these operators unlocks FynX's full expressive power.</p>"},{"location":"generation/markdown/api/#stores-organizing-state","title":"Stores: Organizing State","text":"<p>While standalone observables are useful for small scripts, real applications need structure. Stores group related observables and computed values into cohesive units.</p> <p>Store &amp; @observable \u2014 Create Store classes that encapsulate related state. Use <code>@observable</code> to make class attributes reactive, or use <code>observable()</code> as a class attribute descriptor. This gives you clean property access: <code>UserStore.name = \"Alice\"</code> instead of <code>user_name.set(\"Alice\")</code>. Stores are where FynX really shines in application development.</p>"},{"location":"generation/markdown/api/#decorators-declarative-reactions","title":"Decorators: Declarative Reactions","text":"<p>Decorators let you declare what should happen when observables change, without manually managing subscriptions.</p> <p>@reactive \u2014 Run functions automatically when dependencies change. This is how you implement side effects\u2014logging, UI updates, API calls\u2014that should happen in response to state changes. The function runs immediately and again whenever any observable it reads changes.</p> <p>@watch \u2014 Like <code>@reactive</code>, but only runs when a condition becomes true. Use this for state transitions, validation triggers, and event handlers that should fire conditionally. The condition is checked reactively, so changes to observables in the condition trigger re-evaluation.</p>"},{"location":"generation/markdown/api/#api-quick-reference","title":"API Quick Reference","text":""},{"location":"generation/markdown/api/#creating-reactive-state","title":"Creating Reactive State","text":"<pre><code>from fynx import observable, Store\n\n# Standalone observables\ncount = observable(0)\nname = observable(\"Alice\")\n\n# Store-based observables\nclass AppStore(Store):\n    count = observable(0)\n    name = observable(\"Alice\")\n</code></pre>"},{"location":"generation/markdown/api/#reading-and-writing","title":"Reading and Writing","text":"<pre><code># Standalone observables\ncurrent = count.value          # Read\ncount.set(current + 1)         # Write\n\n# Store observables\ncurrent = AppStore.count       # Read\nAppStore.count = current + 1   # Write\n</code></pre>"},{"location":"generation/markdown/api/#deriving-values","title":"Deriving Values","text":"<pre><code># Using the &gt;&gt; operator (recommended)\ndoubled = count &gt;&gt; (lambda c: c * 2)\nfull_name = (first | last) &gt;&gt; (lambda f, l: f\"{f} {l}\")\n\n# Using computed() function (alternative syntax)\nfrom fynx import computed\ndoubled = computed(lambda c: c * 2, count)\nfull_name = computed(lambda f, l: f\"{f} {l}\", first | last)\n</code></pre>"},{"location":"generation/markdown/api/#reacting-to-changes","title":"Reacting to Changes","text":"<pre><code># Manual subscription\ncount.subscribe(lambda val: print(f\"Count: {val}\"))\n\n# Using @reactive decorator\n@reactive(count)\ndef log_count(val):\n    print(f\"Count: {val}\")\n\n# Using @watch for conditional reactions\n@watch(lambda: count.value &gt; 10)\ndef on_threshold():\n    print(\"Count exceeded 10!\")\n</code></pre>"},{"location":"generation/markdown/api/#composing-observables","title":"Composing Observables","text":"<pre><code># Merge multiple sources\nposition = x | y | z\n\n# Transform values with &gt;&gt; operator\ndoubled = count &gt;&gt; (lambda c: c * 2)\n\n# Or use computed() function\nfrom fynx import computed\ndoubled = computed(lambda c: c * 2, count)\n\n# Filter conditionally\nshould_save = has_changes &amp; is_valid\n\n# Negate conditions\nis_idle = ~is_busy\n</code></pre>"},{"location":"generation/markdown/api/#complete-example-putting-it-all-together","title":"Complete Example: Putting It All Together","text":"<p>Here's how these concepts work together in a realistic scenario:</p> <pre><code>from fynx import Store, observable, reactive, watch\n\nclass ShoppingCartStore(Store):\n    # Basic reactive state\n    items = observable([])\n    discount_code = observable(None)\n\n# Computed values using &gt;&gt; operator\nsubtotal = ShoppingCartStore.items &gt;&gt; (\n    lambda items: sum(item['price'] * item['quantity'] for item in items)\n)\n\ndiscount_amount = (ShoppingCartStore.items | ShoppingCartStore.discount_code) &gt;&gt; (\n    lambda items, code: sum(item['price'] * item['quantity'] for item in items) * 0.20 \n    if code == \"SAVE20\" else 0.0\n)\n\ntotal = (subtotal | discount_amount) &gt;&gt; (\n    lambda sub, disc: sub - disc\n)\n\n# Conditional observable for checkout eligibility\nhas_items = ShoppingCartStore.items &gt;&gt; (lambda i: len(i) &gt; 0)\ntotal_positive = total &gt;&gt; (lambda t: t &gt; 0)\ncan_checkout = has_items &amp; total_positive\n\n# React to changes automatically\n@reactive(total)\ndef update_ui_total(t):\n    print(f\"\ud83d\udcb0 New total: ${t:.2f}\")\n\n# Only react when condition is met\n@watch(can_checkout)\ndef enable_checkout_button():\n    print(\"\u2705 Checkout button enabled\")\n\n# Use the store\nShoppingCartStore.items = [\n    {'name': 'Widget', 'price': 10.00, 'quantity': 2}\n]\n# Output: \ud83d\udcb0 New total: $20.00\n# Output: \u2705 Checkout button enabled\n\nShoppingCartStore.discount_code = \"SAVE20\"\n# Output: \ud83d\udcb0 New total: $16.00\n</code></pre>"},{"location":"generation/markdown/api/#documentation-conventions","title":"Documentation Conventions","text":"<p>Throughout this reference, we follow consistent patterns:</p> <ul> <li>Type signatures use Python type hints for clarity and enable IDE autocomplete</li> <li>Examples progress from simple to complex within each page</li> <li>Notes highlight gotchas that trip up newcomers</li> <li>Performance tips appear when relevant to optimization decisions</li> <li>See also links connect related concepts and alternative approaches</li> </ul>"},{"location":"generation/markdown/api/#navigating-this-reference","title":"Navigating This Reference","text":""},{"location":"generation/markdown/api/#new-to-fynx","title":"New to FynX?","text":"<p>Read in order: Observable \u2192 Store \u2192 @reactive \u2192 ConditionalObservable \u2192 @watch</p>"},{"location":"generation/markdown/api/#building-an-application","title":"Building an application?","text":"<p>Focus on: Store, Observable Operators (especially <code>&gt;&gt;</code>), @reactive</p>"},{"location":"generation/markdown/api/#need-complex-state-logic","title":"Need complex state logic?","text":"<p>Dive into: Observable Operators, ConditionalObservable, @watch</p>"},{"location":"generation/markdown/api/#performance-optimization","title":"Performance optimization?","text":"<p>See: ComputedObservable for memoization, Observable for subscription management</p>"},{"location":"generation/markdown/api/#curious-about-implementation","title":"Curious about implementation?","text":"<p>Explore: Observable Descriptors to understand how the magic works</p> <p>For conceptual introductions and tutorials, return to the main documentation. For practical examples and patterns, see the Cookbook.</p>"},{"location":"generation/markdown/computed-decorator/","title":"@computed Decorator","text":"<p>Function for creating computed observables from other reactive values.</p> <pre><code>Create a computed observable that derives its value from other observables.\n\nThe `computed` function creates a new observable whose value is automatically\ncalculated by applying the given function to the values of the input observable(s).\nWhen the input observable(s) change, the computed observable automatically updates.\n\nThis implements the functorial map operation over observables, allowing you to\ntransform observable values through pure functions while preserving reactivity.\n\nArgs:\n    func: A pure function that computes the derived value. For merged observables,\n          the function receives individual values as separate arguments. For single\n          observables, it receives the single value.\n    observable: The source observable(s) to compute from. Can be a single Observable\n               or a MergedObservable (created with the `|` operator).\n\nReturns:\n    A new ComputedObservable containing the computed values. The observable will\n    automatically update whenever the source observable(s) change.\n\nExamples:\n    ```python\n    from fynx import observable, computed\n\n    # Single observable computation\n    counter = observable(5)\n    doubled = computed(lambda x: x * 2, counter)\n    print(doubled.value)  # 10\n\n    counter.set(7)\n    print(doubled.value)  # 14\n\n    # Merged observable computation\n    width = observable(10)\n    height = observable(20)\n    dimensions = width | height\n\n    area = computed(lambda w, h: w * h, dimensions)\n</code></pre> <p>print(area.value)  # 200</p> <pre><code>    # More complex computation\n    person = observable({\"name\": \"Alice\", \"age\": 30})\n    greeting = computed(\n        lambda p: f\"Hello {p['name']}, you are {p['age']} years old!\",\n        person\n    )\n    print(greeting.value)  # \"Hello Alice, you are 30 years old!\"\n    ```\n\nNote:\n    Computed functions should be pure (no side effects) and relatively fast,\n    as they may be called frequently when dependencies change.\n\nSee Also:\n    observable: Create basic observables\n    ComputedObservable: The returned observable type\n    MergedObservable: For combining multiple observables\n</code></pre>"},{"location":"generation/markdown/computed-observable/","title":"ComputedObservable","text":"<p>Read-only observables that derive their values from other observables.</p> <p>A read-only observable that derives its value from other observables.</p> <p>ComputedObservable is a subclass of Observable that represents computed/derived values. Unlike regular observables, computed observables are read-only and cannot be set directly - their values are automatically calculated from their dependencies.</p> <p>This provides type-based distinction from regular observables, eliminating the need for magic strings or runtime checks. Computed observables maintain the same interface as regular observables for reading values and subscribing to changes, but enforce immutability at runtime.</p> Example <pre><code># Regular observable\ncounter = observable(0)\n\n# Computed observable (read-only)\ndoubled = ComputedObservable(\"doubled\", lambda: counter.value * 2)\ndoubled.set(10)  # Raises ValueError: Computed observables are read-only\n</code></pre>"},{"location":"generation/markdown/computed-observable/#fynx.observable.computed.ComputedObservable.set","title":"set","text":"<pre><code>set(value)\n</code></pre> <p>Prevent direct modification of computed observable values.</p> <p>Computed observables are read-only by design because their values are automatically calculated from other observables. Attempting to set them directly would break the reactive relationship and defeat the purpose of computed values.</p> <p>To create a computed observable, use the <code>computed()</code> function instead:</p> <pre><code>from fynx import observable, computed\n\nbase = observable(5)\n# Correct: Create computed value\ndoubled = computed(lambda x: x * 2, base)\n\n# Incorrect: Try to set computed value directly\ndoubled.set(10)  # Raises ValueError\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Optional[T]</code> <p>The value that would be set (ignored).   This parameter exists for API compatibility but is not used.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>Always raised to prevent direct modification of computed values.        Use the <code>computed()</code> function to create derived observables instead.</p> See Also <p>computed: Function for creating computed observables _set_computed_value: Internal method used by the framework</p>"},{"location":"generation/markdown/conditional-observable/","title":"ConditionalObservable","text":"<p>Observables that only emit values when specific conditions are met.</p>"},{"location":"generation/markdown/conditional-observable/#fynx.observable.conditional--fynx-conditionalobservable-conditional-reactive-computations","title":"FynX ConditionalObservable - Conditional Reactive Computations","text":"<p>This module provides the ConditionalObservable class, which enables filtering reactive streams based on boolean conditions. Conditional observables only emit values from a source observable when all specified conditions are satisfied.</p>"},{"location":"generation/markdown/conditional-observable/#fynx.observable.conditional--when-to-use-conditional-observables","title":"When to Use Conditional Observables","text":"<p>Conditional observables are perfect for scenarios where you need to react to data changes only under specific circumstances:</p> <ul> <li>Guarded Updates: Only reacting to changes when prerequisites are met</li> <li>State Machines: Different behavior based on application state</li> <li>Resource Optimization: Avoiding unnecessary computations when conditions aren't met</li> <li>Event Filtering: Processing events only under specific circumstances</li> <li>Permission Checks: Only updating UI when user has appropriate permissions</li> </ul>"},{"location":"generation/markdown/conditional-observable/#fynx.observable.conditional--how-it-works","title":"How It Works","text":"<p>Conditional observables work by maintaining an internal cache of condition states. They only emit values when:</p> <ol> <li>All conditions become True (after previously being False)</li> <li>Source value changes while all conditions remain True</li> </ol> <p>This prevents unnecessary updates when conditions aren't met and provides precise control over when reactive effects occur.</p>"},{"location":"generation/markdown/conditional-observable/#fynx.observable.conditional--creating-conditional-observables","title":"Creating Conditional Observables","text":"<p>Conditional behavior is created using the <code>&amp;</code> operator:</p> <pre><code>from fynx.observable import Observable\n\n# Source data\ntemperature = Observable(\"temp\", 20)\nhumidity = Observable(\"humidity\", 60)\n\n# Conditions\nis_heating_on = Observable(\"heating\", False)\nis_dry = Observable(\"dry\", False)\n\n# Conditional observable - only emits when heating is on AND it's dry\nsmart_humidity = humidity &amp; is_heating_on &amp; is_dry\n\nsmart_humidity.subscribe(lambda h: print(f\"Adjusting humidity: {h}%\"))\n# Only prints when ALL conditions are True\n</code></pre>"},{"location":"generation/markdown/conditional-observable/#fynx.observable.conditional--key-concepts","title":"Key Concepts","text":"<ul> <li>Condition Chaining: Multiple conditions combine with logical AND</li> <li>Transition-Based: Only triggers on false\u2192true condition transitions</li> <li>Value Filtering: Source values only pass through when conditions are met</li> <li>Immutable Composition: Each <code>&amp;</code> creates a new conditional observable</li> </ul>"},{"location":"generation/markdown/conditional-observable/#fynx.observable.conditional--performance-benefits","title":"Performance Benefits","text":"<ul> <li>Lazy Evaluation: Conditions only re-evaluated when dependencies change</li> <li>Efficient Filtering: Prevents unnecessary reactive updates</li> <li>Memory Conscious: Minimal overhead for condition tracking</li> <li>Composable: Build complex conditions from simple boolean observables</li> </ul>"},{"location":"generation/markdown/conditional-observable/#fynx.observable.conditional--common-patterns","title":"Common Patterns","text":"<p>Feature Flags: <pre><code>data = Observable(\"data\", [])\nfeature_enabled = Observable(\"feature\", False)\nuser_premium = Observable(\"premium\", True)\n\npremium_data = data &amp; feature_enabled &amp; user_premium\n</code></pre></p> <p>Form Validation: <pre><code>email = Observable(\"email\", \"\")\nis_valid_email = Observable(\"valid\", False)\nuser_consented = Observable(\"consent\", False)\n\nsubmittable_data = email &amp; is_valid_email &amp; user_consented\n</code></pre></p> <p>Resource Availability: <pre><code>updates = Observable(\"updates\", [])\nnetwork_available = Observable(\"network\", True)\nbattery_ok = Observable(\"battery\", True)\n\nsync_updates = updates &amp; network_available &amp; battery_ok\n</code></pre></p>"},{"location":"generation/markdown/conditional-observable/#fynx.observable.conditional--see-also","title":"See Also","text":"<ul> <li><code>fynx.watch</code>: For conditional reactive functions (alternative approach)</li> <li><code>fynx.observable</code>: Core observable classes and operators</li> <li><code>fynx.computed</code>: For derived reactive values</li> </ul>"},{"location":"generation/markdown/conditional-observable/#fynx.observable.conditional.ConditionalObservable","title":"ConditionalObservable","text":"<pre><code>ConditionalObservable(source_observable, *condition_observables)\n</code></pre> <p>An observable that filters values from a source observable based on boolean conditions.</p> <p>ConditionalObservable creates a reactive stream that only emits values when ALL specified conditions are True. This enables precise control over when reactive updates occur, preventing unnecessary computations and side effects.</p> <p>The conditional observable maintains an internal cache of the current condition state and only notifies subscribers when conditions transition from unmet to met, or when the source value changes while conditions remain met.</p> <p>Key Features: - Condition Filtering: Only emits when all conditions are satisfied - State Transitions: Triggers on condition state changes - Composable: Can chain multiple conditions with additional <code>&amp;</code> operators - Memory Efficient: Internal caching prevents redundant evaluations</p> Example <pre><code>from fynx.observable import Observable\n\n# Source observable\ntemperature = Observable(\"temp\", 20)\n\n# Condition observables\nis_heating_enabled = Observable(\"heating\", False)\nis_cold = Observable(\"cold_check\", False)\n\n# Conditional observable - only emits when heating is enabled AND it's cold\nheating_trigger = temperature &amp; is_heating_enabled &amp; is_cold\n\n# Subscribe to conditional updates\ndef activate_heating(temp):\n    print(f\"Activating heating at {temp}\u00b0C\")\n\nheating_trigger.subscribe(activate_heating)\n\n# Only triggers when ALL conditions become true\ntemperature.set(15)        # No trigger (heating not enabled)\nis_heating_enabled.set(True)  # No trigger (not marked as cold yet)\nis_cold.set(True)          # Triggers: \"Activating heating at 15\u00b0C\"\ntemperature.set(10)        # Triggers: \"Activating heating at 10\u00b0C\"\nis_heating_enabled.set(False)  # Stops triggering\n</code></pre> Note <p>The conditional observable starts with <code>None</code> as its value if conditions are not initially met. It only takes on the source observable's value when all conditions become True.</p> See Also <p>Observable: Base observable class MergedObservable: For combining multiple observables fynx.watch: For conditional reactive functions</p> <p>Create a conditional observable that filters values based on boolean conditions.</p> <p>The conditional observable will only emit values from the source observable when ALL condition observables are True. If no conditions are provided, the conditional observable behaves identically to the source observable.</p> <p>Parameters:</p> Name Type Description Default <code>source_observable</code> <code>Observable[T]</code> <p>The observable whose values will be conditionally emitted.               This is the primary data source for the conditional stream.</p> required <code>*condition_observables</code> <code>Observable[bool]</code> <p>Variable number of boolean observables that act as                    conditions. ALL conditions must be True for the source                    value to be emitted. Can be empty for unconditional behavior.</p> <code>()</code> Example <pre><code>from fynx.observable import Observable\n\ndata = Observable(\"data\", \"hello\")\nis_ready = Observable(\"ready\", False)\nuser_enabled = Observable(\"enabled\", True)\n\n# Only emits when is_ready AND user_enabled are both True\nconditional_data = ConditionalObservable(data, is_ready, user_enabled)\n\nconditional_data.subscribe(lambda x: print(f\"Received: {x}\"))\n# Initially: no output (is_ready is False)\n\nis_ready.set(True)  # Now prints: \"Received: hello\"\ndata.set(\"world\")   # Prints: \"Received: world\"\n</code></pre>"},{"location":"generation/markdown/conditional-observable/#fynx.observable.conditional.ConditionalObservable.__and__","title":"__and__","text":"<pre><code>__and__(condition)\n</code></pre> <p>Chain an additional condition using the <code>&amp;</code> operator.</p> <p>This method enables fluent composition of multiple conditions. The resulting conditional observable will only emit values when ALL conditions (including the new one) are True.</p> <p>Parameters:</p> Name Type Description Default <code>condition</code> <code>Observable[bool]</code> <p>An additional boolean observable condition that must also be       True for values to be emitted. This condition is combined with       all existing conditions using logical AND.</p> required <p>Returns:</p> Type Description <code>ConditionalObservable[T]</code> <p>A new ConditionalObservable instance with the additional condition.</p> <code>ConditionalObservable[T]</code> <p>The original conditional observable remains unchanged.</p> Example <pre><code>from fynx.observable import Observable\n\ntemperature = Observable(\"temp\", 20)\nis_heating_on = Observable(\"heating\", False)\nis_user_present = Observable(\"present\", True)\n\n# Chain conditions fluently\nsmart_heating = temperature &amp; is_heating_on &amp; is_user_present\n\n# This is equivalent to:\n# smart_heating = ConditionalObservable(temperature, is_heating_on, is_user_present)\n\nsmart_heating.subscribe(lambda t: print(f\"Smart heating: {t}\u00b0C\"))\n\n# Only triggers when ALL conditions are met\nis_heating_on.set(True)  # Now triggers: \"Smart heating: 20\u00b0C\"\ntemperature.set(22)      # Triggers: \"Smart heating: 22\u00b0C\"\nis_user_present.set(False)  # Stops triggering\n</code></pre> Note <p>This method returns a new ConditionalObservable rather than modifying the existing one, enabling immutable composition of conditions.</p>"},{"location":"generation/markdown/conditionals/","title":"Conditionals: Filtering and Logic on Observables","text":"<p>You've learned about observables and how they automatically track changes. You've seen how the <code>&gt;&gt;</code> operator transforms data. But sometimes you need more than transformation\u2014you need filtering and logic.</p> <p>What if you only want to react when certain conditions are true? What if you want to combine multiple conditions? What if you need to filter out unwanted values?</p> <p>That's where FynX's conditional operators come in. They let you create observables that only produce values when conditions are met, filter data streams, and combine logical expressions.</p>"},{"location":"generation/markdown/conditionals/#the-problem-not-all-data-should-pass-through","title":"The Problem: Not All Data Should Pass Through","text":"<p>Consider this scenario:</p> <pre><code>temperature = observable(20)\nweather_alerts = []\n\n# You only want alerts when temperature is extreme\ntemperature.subscribe(lambda temp: {\n    if temp &gt; 30 or temp &lt; 0:\n        weather_alerts.append(f\"Temperature alert: {temp}\u00b0C\")\n})\n</code></pre> <p>This works, but it's verbose. You have to write filtering logic in every subscriber. The filtering is mixed with the reaction logic. And if multiple subscribers need the same filtering, you repeat yourself.</p>"},{"location":"generation/markdown/conditionals/#the-solution-conditional-observables","title":"The Solution: Conditional Observables","text":"<p>FynX gives you operators that create filtered, conditional observables. The key insight: separate the condition logic from the filtering operation.</p> <pre><code>temperature = observable(20)\n\n# First, create a boolean observable representing the condition\nis_extreme = temperature &gt;&gt; (lambda temp: temp &gt; 30 or temp &lt; 0)\n\n# Then, filter the original observable based on that condition\nextreme_temps = temperature &amp; is_extreme\n\nextreme_temps.subscribe(lambda temp: {\n    print(f\"Temperature alert: {temp}\u00b0C\")\n})\n</code></pre> <p>Now the filtering is declarative and reusable. The <code>extreme_temps</code> observable only produces values when the condition is met.</p>"},{"location":"generation/markdown/conditionals/#the-operator-conditional-filtering","title":"The &amp; Operator: Conditional Filtering","text":"<p>The <code>&amp;</code> operator combines an observable with boolean condition observables. It only emits values from the source observable when ALL condition observables are <code>True</code>:</p> <pre><code>from fynx import observable\n\nscores = observable(85)\n\n# Create a boolean condition observable\nis_high_score = scores &gt;&gt; (lambda score: score &gt; 90)\n\n# Filter the original scores based on the condition\nhigh_scores = scores &amp; is_high_score\n\nhigh_scores.subscribe(lambda score: {\n    print(f\"\ud83c\udf89 High score achieved: {score}\")\n})\n\nscores.set(88)  # No output (condition is False)\nscores.set(95)  # Prints: \"\ud83c\udf89 High score achieved: 95\"\nscores.set(87)  # No output (condition becomes False again)\n</code></pre>"},{"location":"generation/markdown/conditionals/#multiple-conditions","title":"Multiple Conditions","text":"<p>Combine multiple conditions with logical operators:</p> <pre><code>age = observable(25)\nscore = observable(85)\nis_premium = observable(True)\n\n# Create boolean condition observables\nis_adult = age &gt;&gt; (lambda a: a &gt;= 18)\nhas_good_score = score &gt;&gt; (lambda s: s &gt;= 80)\nis_premium_user = is_premium &gt;&gt; (lambda p: p == True)\n\n# Multiple conditions - all must be true\neligible_users = age &amp; is_adult &amp; has_good_score &amp; is_premium_user\n\neligible_users.subscribe(lambda _: {\n    print(\"User is eligible for premium features\")\n})\n</code></pre>"},{"location":"generation/markdown/conditionals/#complex-predicates","title":"Complex Predicates","text":"<p>Your condition functions can be as complex as needed:</p> <pre><code>user = observable({\"name\": \"Alice\", \"age\": 30, \"country\": \"US\"})\n\n# Complex validation logic as a boolean observable\nis_valid_user = user &gt;&gt; (lambda u: {\n    u[\"age\"] &gt;= 18 and\n    u[\"country\"] in [\"US\", \"CA\", \"UK\"] and\n    len(u[\"name\"]) &gt; 2 and\n    \"@\" not in u[\"name\"]  # No emails in names\n})\n\n# Filter users based on validation\nvalid_users = user &amp; is_valid_user\n\nvalid_users.subscribe(lambda user_data: {\n    print(f\"\u2705 Valid user: {user_data['name']}\")\n})\n</code></pre>"},{"location":"generation/markdown/conditionals/#the-operator-logical-negation","title":"The ~ Operator: Logical Negation","text":"<p>The <code>~</code> operator inverts boolean conditions. It works on boolean observables:</p> <pre><code>is_online = observable(True)\n\n# Create a negated boolean observable\nis_offline = ~is_online\n\n# React when user goes offline (when is_offline becomes True)\noffline_events = is_offline\n\noffline_events.subscribe(lambda _: {\n    print(\"User went offline\")\n})\n\nis_online.set(False)  # is_offline becomes True, prints: \"User went offline\"\nis_online.set(True)   # is_offline becomes False, no output\n</code></pre>"},{"location":"generation/markdown/conditionals/#combining-negation-with-filtering","title":"Combining Negation with Filtering","text":"<p>Create \"everything except\" patterns:</p> <pre><code>status = observable(\"loading\")\n\n# Create boolean condition for non-loading states\nis_not_loading = status &gt;&gt; (lambda s: s != \"loading\")\n\n# React to any status except \"loading\"\nnon_loading_status = status &amp; is_not_loading\n\nnon_loading_status.subscribe(lambda status_val: {\n    print(f\"Status changed to: {status_val}\")\n})\n\nstatus.set(\"loading\")    # No output (filtered out)\nstatus.set(\"success\")    # Prints: \"Status changed to: success\"\nstatus.set(\"error\")      # Prints: \"Status changed to: error\"\n</code></pre>"},{"location":"generation/markdown/conditionals/#real-world-example-form-validation","title":"Real-World Example: Form Validation","text":"<p>Form validation is perfect for conditional observables:</p> <pre><code>email = observable(\"\")\npassword = observable(\"\")\nterms_accepted = observable(False)\n\n# Validation conditions as boolean observables\nemail_valid = email &gt;&gt; (lambda e: \"@\" in e and \".\" in e.split(\"@\")[1])\npassword_strong = password &gt;&gt; (lambda p: len(p) &gt;= 8)\nterms_checked = terms_accepted &gt;&gt; (lambda t: t == True)\n\n# Form is valid only when all conditions are true\nform_valid = email &amp; email_valid &amp; password_strong &amp; terms_checked\n\nform_valid.subscribe(lambda _: {\n    print(\"\u2705 Form is complete and valid!\")\n})\n\n# Simulate form filling\nemail.set(\"user@\")           # Not yet\npassword.set(\"pass\")         # Not yet\nterms_accepted.set(True)     # Not yet\n\nemail.set(\"user@example.com\")  # Not yet (password too short)\npassword.set(\"secure123\")      # Now valid!\n</code></pre> <p>Notice how <code>form_valid</code> only emits when ALL conditions become true simultaneously.</p>"},{"location":"generation/markdown/conditionals/#advanced-patterns-state-machines-with-conditionals","title":"Advanced Patterns: State Machines with Conditionals","text":"<p>Build state machines using conditional logic:</p> <pre><code>app_state = observable(\"initializing\")\nuser_authenticated = observable(False)\ndata_loaded = observable(False)\n\n# Define state conditions as boolean observables\nis_app_ready = app_state &gt;&gt; (lambda s: s == \"ready\")\nis_user_auth = user_authenticated &gt;&gt; (lambda a: a == True)\nis_data_loaded = data_loaded &gt;&gt; (lambda d: d == True)\nis_app_error = app_state &gt;&gt; (lambda s: s == \"error\")\n\n# Combine conditions - app is ready when all are true\nready_state = app_state &amp; is_app_ready &amp; is_user_auth &amp; is_data_loaded\n\n# Error state\nerror_state = app_state &amp; is_app_error\n\n# React to state transitions\nready_state.subscribe(lambda _: {\n    print(\"\ud83d\ude80 Application is fully ready!\")\n})\n\nerror_state.subscribe(lambda _: {\n    print(\"\u274c Application encountered an error\")\n})\n\n# Simulate app lifecycle\napp_state.set(\"authenticating\")\nuser_authenticated.set(True)\napp_state.set(\"loading_data\")\ndata_loaded.set(True)\napp_state.set(\"ready\")  # Triggers \"fully ready\" message\n</code></pre>"},{"location":"generation/markdown/conditionals/#conditional-operators-with-derived-values","title":"Conditional Operators with Derived Values","text":"<p>Combine conditionals with the <code>&gt;&gt;</code> operator for powerful data processing:</p> <pre><code>sensor_readings = observable([])\n\n# Create condition for sufficient data\nhas_enough_data = sensor_readings &gt;&gt; (lambda readings: len(readings) &gt;= 3)\n\n# Only process readings when we have enough data\nvalid_readings = sensor_readings &amp; has_enough_data\n\n# Then calculate statistics\naverage_reading = valid_readings &gt;&gt; (lambda readings: sum(readings) / len(readings))\n\naverage_reading.subscribe(lambda avg: {\n    print(f\"Average sensor reading: {avg:.2f}\")\n})\n\nsensor_readings.set([1, 2])        # No output (not enough data)\nsensor_readings.set([1, 2, 3, 4])  # Prints: \"Average sensor reading: 2.50\"\n</code></pre>"},{"location":"generation/markdown/conditionals/#performance-benefits","title":"Performance Benefits","text":"<p>Conditional observables improve performance by:</p> <ol> <li>Reducing unnecessary computations - Only process data that meets criteria</li> <li>Filtering at the source - Don't pass unwanted data to subscribers</li> <li>Early termination - Stop reactive chains when conditions aren't met</li> </ol> <pre><code># Without conditionals - expensive operation runs on every change\nraw_data = observable(\"some data\")\nprocessed_data = raw_data &gt;&gt; (lambda d: expensive_cleanup(d))\nfinal_result = processed_data &gt;&gt; (lambda d: expensive_analysis(d))\n\n# With conditionals - expensive operations only run when needed\nclean_data = raw_data &amp; (lambda d: is_worth_processing(d))\nprocessed_data = clean_data &gt;&gt; (lambda d: expensive_cleanup(d))\nfinal_result = processed_data &gt;&gt; (lambda d: expensive_analysis(d))\n</code></pre>"},{"location":"generation/markdown/conditionals/#common-patterns","title":"Common Patterns","text":""},{"location":"generation/markdown/conditionals/#pattern-1-threshold-monitoring","title":"Pattern 1: Threshold Monitoring","text":"<pre><code>temperature = observable(20)\n\n# Create threshold conditions\nis_hot = temperature &gt;&gt; (lambda t: t &gt; 25)\nis_cold = temperature &gt;&gt; (lambda t: t &lt; 10)\n\n# Alert when temperature crosses thresholds\nhot_weather = temperature &amp; is_hot\ncold_weather = temperature &amp; is_cold\n\nhot_weather.subscribe(lambda t: print(f\"\ud83c\udf21\ufe0f Hot: {t}\u00b0C\"))\ncold_weather.subscribe(lambda t: print(f\"\ud83e\uddca Cold: {t}\u00b0C\"))\n</code></pre>"},{"location":"generation/markdown/conditionals/#pattern-2-data-quality-gates","title":"Pattern 2: Data Quality Gates","text":"<pre><code>api_response = observable(None)\n\n# Create validation condition\nis_valid_response = api_response &gt;&gt; (lambda resp: {\n    resp is not None and\n    resp.get(\"status\") == \"success\" and\n    resp.get(\"data\") is not None\n})\n\n# Only process successful responses with data\nvalid_responses = api_response &amp; is_valid_response\n\nvalid_responses.subscribe(lambda resp: {\n    process_data(resp[\"data\"])\n})\n</code></pre>"},{"location":"generation/markdown/conditionals/#pattern-3-feature-flags-with-conditions","title":"Pattern 3: Feature Flags with Conditions","text":"<pre><code>feature_enabled = observable(False)\nuser_premium = observable(False)\nexperiment_active = observable(True)\n\n# Create boolean conditions\nis_feature_on = feature_enabled &gt;&gt; (lambda e: e == True)\nis_premium_user = user_premium &gt;&gt; (lambda p: p == True)\nis_experiment_on = experiment_active &gt;&gt; (lambda a: a == True)\n\n# Feature is available only under specific conditions\ncan_use_feature = feature_enabled &amp; is_feature_on &amp; is_premium_user &amp; is_experiment_on\n\ncan_use_feature.subscribe(lambda _: {\n    enable_premium_feature()\n})\n</code></pre>"},{"location":"generation/markdown/conditionals/#gotchas-and-best-practices","title":"Gotchas and Best Practices","text":""},{"location":"generation/markdown/conditionals/#gotcha-1-condition-functions-run-frequently","title":"Gotcha 1: Condition Functions Run Frequently","text":"<pre><code># Bad - expensive condition runs on every change\nslow_condition = data &amp; (lambda d: expensive_validation(d))\n\n# Better - cache expensive conditions\nis_valid = data &gt;&gt; (lambda d: expensive_validation(d))\nvalid_data = is_valid &amp; (lambda v: v == True)\n</code></pre>"},{"location":"generation/markdown/conditionals/#gotcha-2-negation-can-be-confusing","title":"Gotcha 2: Negation Can Be Confusing","text":"<pre><code>flag = observable(True)\n\n# This creates an observable that emits when flag becomes False\nnot_flag = ~flag\n\n# But this doesn't do what you might expect\nwrong_not_flag = flag &amp; (lambda f: not f)  # Less clear than ~\n</code></pre>"},{"location":"generation/markdown/conditionals/#best-practice-keep-conditions-simple","title":"Best Practice: Keep Conditions Simple","text":"<pre><code># Good - simple, focused conditions\nis_adult = age &amp; (lambda a: a &gt;= 18)\nhas_permission = role &amp; (lambda r: r in [\"admin\", \"moderator\"])\n\n# Avoid - complex conditions\ncomplex_check = user &amp; (lambda u: {\n    u[\"age\"] &gt;= 18 and\n    u[\"role\"] in [\"admin\", \"moderator\"] and\n    u[\"verified\"] and\n    not u[\"banned\"]\n})\n</code></pre>"},{"location":"generation/markdown/conditionals/#best-practice-name-your-conditions","title":"Best Practice: Name Your Conditions","text":"<pre><code>def is_valid_email(email):\n    return \"@\" in email and \".\" in email.split(\"@\")[1]\n\ndef is_strong_password(pwd):\n    return len(pwd) &gt;= 8\n\n# Much clearer than inline lambdas\nemail_ok = email &amp; is_valid_email\npassword_ok = password &amp; is_strong_password\nform_valid = (email_ok &amp; (lambda _: True)) &amp; (password_ok &amp; (lambda _: True))\n</code></pre>"},{"location":"generation/markdown/conditionals/#the-big-picture","title":"The Big Picture","text":"<p>Conditionals transform your reactive system from \"process everything\" to \"process only what matters\":</p> <ul> <li><code>&amp;</code> operator: Filter data streams based on predicates</li> <li><code>~</code> operator: Invert boolean conditions</li> <li>Performance: Skip unnecessary computations</li> <li>Clarity: Separate filtering logic from reaction logic</li> <li>Composition: Combine conditions with other operators</li> </ul> <p>Think of conditionals as reactive filters. They let you create observables that only emit valuable data, reducing noise and improving performance. Combined with transformations (<code>&gt;&gt;</code>) and reactions (<code>@reactive</code>, <code>@watch</code>), they give you a complete toolkit for building sophisticated reactive applications.</p> <p>The next step is organizing these reactive pieces into reusable units called Stores\u2014the architectural pattern that brings everything together.</p>"},{"location":"generation/markdown/decorators/","title":"Decorators - Making Code Reactive","text":"<p>Decorators in FynX provide the high-level API for creating reactive relationships in your application. They transform regular Python functions and classes into reactive components that automatically respond to state changes.</p>"},{"location":"generation/markdown/decorators/#overview","title":"Overview","text":"<p>FynX decorators fall into two main categories:</p> <ul> <li>Function Decorators: Transform functions into reactive components (<code>@reactive</code>, <code>@watch</code>)</li> <li>Class Decorators: Make class attributes reactive (<code>@observable</code>)</li> </ul>"},{"location":"generation/markdown/decorators/#function-decorators","title":"Function Decorators","text":""},{"location":"generation/markdown/decorators/#reactive-automatic-function-execution","title":"<code>@reactive</code> - Automatic Function Execution","text":"<p>The <code>@reactive</code> decorator makes functions automatically execute whenever their observable dependencies change. It's perfect for side effects like UI updates, logging, and API calls.</p>"},{"location":"generation/markdown/decorators/#basic-usage","title":"Basic Usage","text":"<pre><code>from fynx import reactive, observable\n\ncounter = observable(0)\n\n@reactive(counter)\ndef log_counter_changes(new_value):\n    print(f\"Counter changed to: {new_value}\")\n\ncounter = 5  # Prints: \"Counter changed to: 5\"\ncounter = 10 # Prints: \"Counter changed to: 10\"\n</code></pre>"},{"location":"generation/markdown/decorators/#multiple-dependencies","title":"Multiple Dependencies","text":"<pre><code>user_name = observable(\"Alice\")\nuser_age = observable(30)\n\n@reactive(user_name, user_age)\ndef update_user_display(name, age):\n    print(f\"User: {name}, Age: {age}\")\n\nuser_name = \"Bob\"  # Triggers with current age\nuser_age = 31      # Triggers with current name\n</code></pre>"},{"location":"generation/markdown/decorators/#store-level-reactions","title":"Store-Level Reactions","text":"<p>React to any change in an entire store:</p> <pre><code>from fynx import Store, observable, reactive\n\nclass UserStore(Store):\n    name = observable(\"Alice\")\n    age = observable(30)\n    email = observable(\"alice@example.com\")\n\n@reactive(UserStore)\ndef on_any_user_change(store_snapshot):\n    print(f\"User data changed: {store_snapshot.name}, {store_snapshot.age}\")\n\nUserStore.name = \"Bob\"     # Triggers reaction\nUserStore.email = \"bob@example.com\"  # Also triggers reaction\n</code></pre>"},{"location":"generation/markdown/decorators/#cleanup","title":"Cleanup","text":"<p>Reactive functions can be unsubscribed:</p> <pre><code># The decorator returns the original function\n# so you can unsubscribe later\nunsubscribe_func = reactive(UserStore)(on_any_user_change)\n\n# Later, stop the reaction\nUserStore.unsubscribe(on_any_user_change)\n</code></pre>"},{"location":"generation/markdown/decorators/#watch-conditional-reactions","title":"<code>@watch</code> - Conditional Reactions","text":"<p>The <code>@watch</code> decorator creates reactions that only trigger when specific conditions are met. Unlike <code>@reactive</code> which triggers on every change, <code>@watch</code> only runs when conditions transition from unmet to met.</p>"},{"location":"generation/markdown/decorators/#basic-conditional-watching","title":"Basic Conditional Watching","text":"<pre><code>from fynx import watch, observable\n\nuser_online = observable(False)\nmessage_count = observable(0)\n\n@watch(\n    lambda: user_online.value,           # User must be online\n    lambda: message_count.value &gt; 0      # Must have messages\n)\ndef send_notifications():\n    print(f\"\ud83d\udcec Sending {message_count.value} notifications!\")\n\n# No reaction yet - conditions not met\nmessage_count = 5       # User offline\nuser_online = True      # Now both conditions met - triggers!\n\n# No reaction - already met conditions\nmessage_count = 3       # Still triggers (count changed)\nuser_online = False     # Conditions no longer met\n\nuser_online = True      # Triggers again - conditions newly met\n</code></pre>"},{"location":"generation/markdown/decorators/#complex-conditions","title":"Complex Conditions","text":"<pre><code>is_logged_in = observable(False)\nhas_permissions = observable(False)\ndata_loaded = observable(False)\n\n@watch(\n    lambda: is_logged_in.value,\n    lambda: has_permissions.value,\n    lambda: data_loaded.value\n)\ndef enable_feature():\n    print(\"\ud83c\udf89 Feature enabled - all conditions met!\")\n\n# Only triggers when ALL conditions become true after being false\nis_logged_in = True     # Not yet - missing permissions\nhas_permissions = True  # Not yet - missing data\ndata_loaded = True      # Now triggers!\n</code></pre>"},{"location":"generation/markdown/decorators/#real-world-example-form-validation","title":"Real-World Example: Form Validation","text":"<pre><code>email = observable(\"\")\npassword = observable(\"\")\nterms_accepted = observable(False)\n\n@watch(\n    lambda: email.value and \"@\" in email.value,\n    lambda: len(password.value) &gt;= 8,\n    lambda: terms_accepted.value\n)\ndef enable_submit_button():\n    print(\"\u2705 Form is valid - submit button enabled\")\n\nemail = \"user@example.com\"  # Not yet - password too short\npassword = \"secure123\"      # Not yet - terms not accepted\nterms_accepted = True       # All conditions met - triggers!\n</code></pre>"},{"location":"generation/markdown/decorators/#class-decorators","title":"Class Decorators","text":""},{"location":"generation/markdown/decorators/#observable-reactive-class-attributes","title":"<code>@observable</code> - Reactive Class Attributes","text":"<p>The <code>@observable</code> decorator makes class attributes reactive. It's used within Store classes to create observable properties.</p>"},{"location":"generation/markdown/decorators/#basic-usage-in-stores","title":"Basic Usage in Stores","text":"<pre><code>from fynx import Store, observable\n\nclass CounterStore(Store):\n    count = observable(0)    # Reactive attribute\n    step = observable(1)     # Another reactive attribute\n\n# Direct assignment triggers reactivity\nCounterStore.count = 5\nCounterStore.step = 2\n</code></pre>"},{"location":"generation/markdown/decorators/#computed-properties","title":"Computed Properties","text":"<p>While not a decorator itself, the <code>&gt;&gt;</code> operator (used with <code>observable</code> attributes) creates computed properties:</p> <pre><code>class CounterStore(Store):\n    count = observable(0)\n    doubled = count &gt;&gt; (lambda x: x * 2)  # Computed property\n\nCounterStore.count = 5\nprint(CounterStore.doubled)  # 10\n</code></pre>"},{"location":"generation/markdown/decorators/#decorator-patterns","title":"Decorator Patterns","text":""},{"location":"generation/markdown/decorators/#when-to-use-each-decorator","title":"When to Use Each Decorator","text":"Decorator Use Case Triggers On <code>@reactive</code> Side effects, UI updates, logging Every change to dependencies <code>@watch</code> Conditional logic, state machines, validation Conditions becoming newly met <code>@observable</code> Reactive state in classes N/A (attribute decorator)"},{"location":"generation/markdown/decorators/#combining-decorators","title":"Combining Decorators","text":"<pre><code>from fynx import Store, observable, reactive, watch\n\nclass TodoStore(Store):\n    todos = observable([])\n    filter_mode = observable(\"all\")\n\n    # Reactive: Update UI on any change\n    @reactive(todos, filter_mode)\n    def update_ui(todos_list, mode):\n        print(f\"UI updated: {len(todos_list)} todos, filter: {mode}\")\n\n    # Watch: Only when todos exist and filter changes to \"completed\"\n    @watch(\n        lambda: len(TodoStore.todos.value) &gt; 0,\n        lambda: TodoStore.filter_mode.value == \"completed\"\n    )\n    def show_completion_message():\n        completed_count = len([t for t in TodoStore.todos.value if t[\"completed\"]])\n        print(f\"\ud83c\udf89 {completed_count} todos completed!\")\n</code></pre>"},{"location":"generation/markdown/decorators/#error-handling","title":"Error Handling","text":"<p>Decorators handle errors gracefully:</p> <pre><code>@reactive(some_observable)\ndef potentially_failing_reaction(value):\n    if value &lt; 0:\n        raise ValueError(\"Negative values not allowed!\")\n    print(f\"Processed: {value}\")\n\n# Errors in reactive functions don't break the reactive system\nsome_observable = -5  # Error logged, but reactivity continues\nsome_observable = 10  # Continues working: \"Processed: 10\"\n</code></pre>"},{"location":"generation/markdown/decorators/#performance-considerations","title":"Performance Considerations","text":""},{"location":"generation/markdown/decorators/#lazy-vs-eager-execution","title":"Lazy vs Eager Execution","text":"<ul> <li>Reactive methods (<code>@reactive</code>): Execute eagerly when dependencies change</li> <li>Watch methods (<code>@watch</code>): Execute eagerly only when conditions are newly met</li> <li>Computed properties: Execute lazily when accessed</li> </ul> <pre><code>expensive_calc = observable(0)\n\n# Eager: Runs immediately when expensive_calc changes\n@reactive(expensive_calc)\ndef eager_update(val):\n    slow_operation(val)  # Runs immediately\n\n# Lazy: Only runs when result is accessed\nlazy_result = expensive_calc &gt;&gt; (lambda val: slow_operation(val))\n\n# lazy_result.value  # Only runs slow_operation here\n</code></pre>"},{"location":"generation/markdown/decorators/#memory-management","title":"Memory Management","text":"<p>Always clean up subscriptions:</p> <pre><code>class Component:\n    def __init__(self):\n        # Store subscription references for cleanup\n        self._cleanup = reactive(store)(self._on_change)\n\n    def destroy(self):\n        # Clean up when component is destroyed\n        store.unsubscribe(self._on_change)\n</code></pre>"},{"location":"generation/markdown/decorators/#common-patterns","title":"Common Patterns","text":""},{"location":"generation/markdown/decorators/#ui-state-management","title":"UI State Management","text":"<pre><code>class UIStore(Store):\n    sidebar_open = observable(False)\n    modal_visible = observable(False)\n    loading = observable(False)\n\n    @reactive(sidebar_open)\n    def update_layout(open_state):\n        if open_state:\n            print(\"\ud83d\udcf1 Adjusting layout for sidebar\")\n        else:\n            print(\"\ud83d\udcf1 Restoring full-width layout\")\n\n    @watch(lambda: UIStore.loading.value)\n    def show_loading_spinner():\n        print(\"\u23f3 Showing loading spinner\")\n\n    @watch(lambda: not UIStore.loading.value)\n    def hide_loading_spinner():\n        print(\"\u2705 Hiding loading spinner\")\n</code></pre>"},{"location":"generation/markdown/decorators/#form-handling","title":"Form Handling","text":"<pre><code>class FormStore(Store):\n    email = observable(\"\")\n    password = observable(\"\")\n    confirm_password = observable(\"\")\n\n    # Reactive validation\n    @reactive(email)\n    def validate_email(email_val):\n        if email_val and \"@\" not in email_val:\n            print(\"\u274c Invalid email format\")\n\n    # Watch for complete form\n    @watch(\n        lambda: FormStore.email.value and \"@\" in FormStore.email.value,\n        lambda: len(FormStore.password.value) &gt;= 8,\n        lambda: FormStore.password.value == FormStore.confirm_password.value\n    )\n    def enable_submit():\n        print(\"\u2705 Form is valid and ready to submit\")\n</code></pre>"},{"location":"generation/markdown/decorators/#api-integration","title":"API Integration","text":"<pre><code>class ApiStore(Store):\n    is_loading = observable(False)\n    data = observable(None)\n    error = observable(None)\n\n    @reactive(is_loading)\n    def update_ui_state(loading):\n        if loading:\n            print(\"\u23f3 Showing loading indicator\")\n        else:\n            print(\"\u2705 Hiding loading indicator\")\n\n    @watch(lambda: ApiStore.error.value is not None)\n    def show_error_message():\n        print(f\"\u274c Error: {ApiStore.error.value}\")\n\n    @watch(lambda: ApiStore.data.value is not None)\n    def process_successful_response():\n        print(f\"\ud83d\udce6 Processing data: {len(ApiStore.data.value)} items\")\n</code></pre>"},{"location":"generation/markdown/decorators/#best-practices","title":"Best Practices","text":""},{"location":"generation/markdown/decorators/#1-use-descriptive-function-names","title":"1. Use Descriptive Function Names","text":"<pre><code># Good\n@reactive(user_data)\ndef update_user_profile_display(user):\n    pass\n\n# Avoid\n@reactive(user_data)\ndef func1(user):\n    pass\n</code></pre>"},{"location":"generation/markdown/decorators/#2-keep-reactive-functions-focused","title":"2. Keep Reactive Functions Focused","text":"<pre><code># Good: Single responsibility\n@reactive(shopping_cart)\ndef update_cart_total(cart):\n    calculate_total(cart)\n\n@reactive(shopping_cart)\ndef update_cart_item_count(cart):\n    update_counter(len(cart))\n\n# Avoid: Multiple responsibilities\n@reactive(shopping_cart)\ndef handle_cart_changes(cart):\n    calculate_total(cart)\n    update_counter(len(cart))\n    send_analytics(cart)\n    update_ui(cart)\n</code></pre>"},{"location":"generation/markdown/decorators/#3-handle-errors-appropriately","title":"3. Handle Errors Appropriately","text":"<pre><code>@reactive(api_response)\ndef handle_api_response(response):\n    try:\n        if response[\"error\"]:\n            show_error(response[\"error\"])\n        else:\n            process_data(response[\"data\"])\n    except Exception as e:\n        log_error(f\"Failed to handle API response: {e}\")\n        show_generic_error()\n</code></pre>"},{"location":"generation/markdown/decorators/#4-prefer-watch-for-state-machines","title":"4. Prefer <code>@watch</code> for State Machines","text":"<pre><code>current_state = observable(\"idle\")\n\n@watch(lambda: current_state.value == \"loading\")\ndef enter_loading_state():\n    show_spinner()\n\n@watch(lambda: current_state.value == \"success\")\ndef enter_success_state():\n    hide_spinner()\n    show_success_message()\n\n@watch(lambda: current_state.value == \"error\")\ndef enter_error_state():\n    hide_spinner()\n    show_error_message()\n</code></pre>"},{"location":"generation/markdown/decorators/#5-document-side-effects","title":"5. Document Side Effects","text":"<pre><code>@reactive(user_preferences)\ndef update_application_theme(preferences):\n    \"\"\"\n    Updates the application theme based on user preferences.\n\n    Side effects:\n    - Modifies CSS custom properties\n    - Updates localStorage\n    - Triggers re-render of styled components\n    \"\"\"\n    apply_theme(preferences[\"theme\"])\n    save_to_localstorage(\"theme\", preferences[\"theme\"])\n</code></pre> <p>Decorators are the bridge between reactive state and imperative code. They allow you to write declarative relationships while maintaining clean, maintainable code. Choose the right decorator for your use case, and remember that reactive functions should focus on side effects while computed properties handle pure transformations.</p>"},{"location":"generation/markdown/merged-observable/","title":"MergedObservable","text":"<p>Observables that combine multiple values using the merge operator (<code>|</code>).</p>"},{"location":"generation/markdown/merged-observable/#fynx.observable.merged--fynx-mergedobservable-combined-reactive-values","title":"FynX MergedObservable - Combined Reactive Values","text":"<p>This module provides the MergedObservable class, which combines multiple individual observables into a single reactive unit. This enables treating related observables as a cohesive group that updates atomically when any component changes.</p> <p>Merged observables are useful for: - Coordinated Updates: When multiple values need to change together - Computed Relationships: When derived values depend on multiple inputs - Tuple Operations: When you need to pass multiple reactive values as a unit - State Composition: Building complex state from simpler reactive components</p> <p>The merge operation is created using the <code>|</code> operator between observables:</p> <pre><code>from fynx import observable\n\nwidth = observable(10)\nheight = observable(20)\ndimensions = width | height  # Creates MergedObservable\nprint(dimensions.value)  # (10, 20)\n\nwidth.set(15)\nprint(dimensions.value)  # (15, 20)\n</code></pre>"},{"location":"generation/markdown/merged-observable/#fynx.observable.merged.MergedObservable","title":"MergedObservable","text":"<pre><code>MergedObservable(*observables)\n</code></pre> <p>An observable that combines multiple observables into a single reactive tuple.</p> <p>MergedObservable creates a composite observable whose value is a tuple containing the current values of all source observables. When any source observable changes, the merged observable updates its tuple value and notifies all subscribers.</p> <p>This enables treating multiple related reactive values as a single atomic unit, which is particularly useful for:</p> <ul> <li>Functions that need multiple related parameters</li> <li>Computed values that depend on several inputs</li> <li>Coordinated state updates across multiple variables</li> <li>Maintaining referential consistency between related values</li> </ul> Example <pre><code>from fynx import observable, computed\n\n# Individual observables\nx = observable(10)\ny = observable(20)\n\n# Merge them into a single reactive unit\npoint = x | y\nprint(point.value)  # (10, 20)\n\n# Computed values can work with the tuple\ndistance_from_origin = computed(\n    lambda px, py: (px**2 + py**2)**0.5,\n    point\n)\nprint(distance_from_origin.value)  # 22.360679774997898\n\n# Changes to either coordinate update everything\nx.set(15)\nprint(point.value)                  # (15, 20)\nprint(distance_from_origin.value)   # 25.0\n</code></pre> Note <p>The merged observable's value is always a tuple, even when merging just two observables. This provides a consistent interface for computed functions.</p> See Also <p>Observable: Base observable class computed: For creating derived values from merged observables</p> <p>Create a merged observable from multiple source observables.</p> <p>Parameters:</p> Name Type Description Default <code>*observables</code> <code>Observable</code> <p>Variable number of Observable instances to combine.          At least one observable must be provided.</p> <code>()</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no observables are provided</p>"},{"location":"generation/markdown/merged-observable/#fynx.observable.merged.MergedObservable.value","title":"value","text":"<pre><code>value\n</code></pre> <p>Get the current tuple value, using cache when possible.</p> <p>Returns the current values of all source observables as a tuple. Uses caching to avoid recomputing the tuple on every access.</p> <p>Returns:</p> Type Description <p>A tuple containing the current values of all source observables,</p> <p>in the order they were provided to the constructor.</p> Example <pre><code>x = Observable(\"x\", 10)\ny = Observable(\"y\", 20)\nmerged = x | y\n\nprint(merged.value)  # (10, 20)\nx.set(15)\nprint(merged.value)  # (15, 20) - cache invalidated and recomputed\n</code></pre>"},{"location":"generation/markdown/merged-observable/#fynx.observable.merged.MergedObservable.__enter__","title":"__enter__","text":"<pre><code>__enter__()\n</code></pre> <p>Context manager entry for reactive blocks.</p> <p>Enables experimental syntax for defining reactive blocks that execute whenever any of the merged observables change.</p> <p>Returns:</p> Type Description <p>A context object that can be called with a function to create reactive behavior.</p> Example <pre><code># Experimental context manager syntax\nwith merged_obs as ctx:\n    ctx(lambda x, y: print(f\"Values changed: {x}, {y}\"))\n</code></pre> Note <p>This is an experimental feature. The more common approach is to use subscribe() or the @reactive decorator.</p>"},{"location":"generation/markdown/merged-observable/#fynx.observable.merged.MergedObservable.__exit__","title":"__exit__","text":"<pre><code>__exit__(exc_type, exc_val, exc_tb)\n</code></pre> <p>Context manager exit.</p> <p>Currently does nothing, but allows the context manager to work properly.</p>"},{"location":"generation/markdown/merged-observable/#fynx.observable.merged.MergedObservable.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(index)\n</code></pre> <p>Allow indexing into the merged observable like a tuple.</p> <p>Provides tuple-like access to individual values in the merged observable.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Zero-based index of the value to retrieve</p> required <p>Returns:</p> Type Description <code>T</code> <p>The value at the specified index</p> <p>Raises:</p> Type Description <code>IndexError</code> <p>If the index is out of range or the observable has no value</p> <p>Examples:</p> <pre><code>point = x | y | z\nprint(point[0])  # x value\nprint(point[1])  # y value\nprint(point[-1]) # z value\n</code></pre>"},{"location":"generation/markdown/merged-observable/#fynx.observable.merged.MergedObservable.__iter__","title":"__iter__","text":"<pre><code>__iter__()\n</code></pre> <p>Allow iteration over the tuple value.</p> <p>Enables unpacking and iteration over merged observable values.</p> <p>Yields:</p> Type Description <p>Individual values from the merged tuple.</p> <p>Examples:</p> <pre><code>coords = x | y | z\n# Unpack values\nx_val, y_val, z_val = coords\n\n# Iterate over values\nfor value in coords:\n    print(value)\n</code></pre>"},{"location":"generation/markdown/merged-observable/#fynx.observable.merged.MergedObservable.__len__","title":"__len__","text":"<pre><code>__len__()\n</code></pre> <p>Return the number of combined observables.</p> <p>Returns:</p> Type Description <code>int</code> <p>The number of source observables that were merged.</p> Example <pre><code>single = Observable(\"a\", 1)\npair = single | Observable(\"b\", 2)\ntriple = pair | Observable(\"c\", 3)\n\nprint(len(single))   # TypeError (single observable)\nprint(len(pair))     # 2\nprint(len(triple))   # 3\n</code></pre>"},{"location":"generation/markdown/merged-observable/#fynx.observable.merged.MergedObservable.__or__","title":"__or__","text":"<pre><code>__or__(other)\n</code></pre> <p>Chain merging with another observable using the | operator.</p> <p>Enables fluent syntax for building up merged observables incrementally. Each | operation creates a new MergedObservable containing all previous observables plus the new one.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Observable</code> <p>Another Observable to merge with this merged observable</p> required <p>Returns:</p> Type Description <code>MergedObservable</code> <p>A new MergedObservable containing all source observables from this</p> <code>MergedObservable</code> <p>merged observable plus the additional observable.</p> <p>Examples:</p> <pre><code># Chain multiple merges\na = Observable(\"a\", 1)\nb = Observable(\"b\", 2)\nc = Observable(\"c\", 3)\n\n# Method 1: Merge all at once\nmerged1 = MergedObservable(a, b, c)\n\n# Method 2: Chain merges\nmerged2 = a | b | c  # Same result as merged1\n\nprint(merged2.value)  # (1, 2, 3)\n</code></pre>"},{"location":"generation/markdown/merged-observable/#fynx.observable.merged.MergedObservable.__setitem__","title":"__setitem__","text":"<pre><code>__setitem__(index, value)\n</code></pre> <p>Allow setting values by index, updating the corresponding source observable.</p> <p>Provides a convenient way to update individual source observables through the merged interface.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Zero-based index of the source observable to update</p> required <code>value</code> <code>T</code> <p>New value for the source observable at that index</p> required <p>Raises:</p> Type Description <code>IndexError</code> <p>If the index is out of range</p> <p>Examples:</p> <pre><code>point = x | y | z\npoint[0] = 10  # Updates x\npoint[1] = 20  # Updates y\nprint(point.value)  # (10, 20, z.value)\n</code></pre>"},{"location":"generation/markdown/merged-observable/#fynx.observable.merged.MergedObservable.set","title":"set","text":"<pre><code>set(value)\n</code></pre> <p>Override set to invalidate cache.</p> <p>This method is not typically used directly on merged observables, as they derive their value from source observables. However, if you need to manually set a merged observable's value, this method ensures the internal cache is properly invalidated.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <p>The new tuple value to set</p> required Note <p>Manually setting merged observable values is uncommon. Usually, you update the source observables instead.</p>"},{"location":"generation/markdown/merged-observable/#fynx.observable.merged.MergedObservable.subscribe","title":"subscribe","text":"<pre><code>subscribe(func)\n</code></pre> <p>Subscribe a function to react to changes in any of the merged observables.</p> <p>The subscribed function will be called immediately with the current values of all merged observables, and then again whenever any source observable changes. This provides a way to react to coordinated changes across multiple observables.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable</code> <p>A callable that will receive the current values of all merged   observables as separate arguments, in the order they were merged.   The function signature should match the number of merged observables.</p> required <p>Returns:</p> Type Description <code>MergedObservable[T]</code> <p>This merged observable instance for method chaining.</p> <p>Examples:</p> <pre><code>x = Observable(\"x\", 1)\ny = Observable(\"y\", 2)\ncoords = x | y\n\ndef on_coords_change(x_val, y_val):\n    print(f\"Coordinates: ({x_val}, {y_val})\")\n\ncoords.subscribe(on_coords_change)  # Prints: \"Coordinates: (1, 2)\"\n\nx.set(10)  # Prints: \"Coordinates: (10, 2)\"\ny.set(20)  # Prints: \"Coordinates: (10, 20)\"\n</code></pre> Note <p>The function is called immediately upon subscription with current values. For more advanced reactive patterns, consider using the @reactive decorator or @watch decorator instead.</p> See Also <p>unsubscribe: Remove a subscription reactive: Decorator-based reactive functions</p>"},{"location":"generation/markdown/merged-observable/#fynx.observable.merged.MergedObservable.unsubscribe","title":"unsubscribe","text":"<pre><code>unsubscribe(func)\n</code></pre> <p>Unsubscribe a function from this merged observable.</p> <p>Removes the subscription for the specified function, preventing it from being called when the merged observable changes. This properly cleans up the reactive context and removes all observers.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable</code> <p>The function that was previously subscribed to this merged observable.   Must be the same function object that was passed to subscribe().</p> required <p>Examples:</p> <pre><code>def handler(x, y):\n    print(f\"Changed: {x}, {y}\")\n\ncoords = x | y\ncoords.subscribe(handler)\n\n# Later, unsubscribe\ncoords.unsubscribe(handler)  # No longer called when coords change\n</code></pre> Note <p>This only removes subscriptions to this specific merged observable. If the same function is subscribed to other observables, those subscriptions remain active.</p> See Also <p>subscribe: Add a subscription</p>"},{"location":"generation/markdown/observable-descriptors/","title":"Observable Descriptors","text":"<p>Classes for creating observable attributes in Store classes and other contexts.</p>"},{"location":"generation/markdown/observable-descriptors/#fynx.observable.descriptors--fynx-observable-descriptors-reactive-attribute-descriptors","title":"FynX Observable Descriptors - Reactive Attribute Descriptors","text":"<p>This module provides descriptor classes that enable transparent reactive programming in class attributes. These descriptors bridge the gap between regular Python attribute access and reactive capabilities, allowing Store classes to provide both familiar attribute syntax and full reactive behavior.</p>"},{"location":"generation/markdown/observable-descriptors/#fynx.observable.descriptors--transparent-reactivity","title":"Transparent Reactivity","text":"<p>FynX's descriptors enable \"transparent reactivity\" - the ability to write code that looks like regular attribute access while maintaining automatic dependency tracking and change propagation. This means you can use observables in existing code without major syntax changes.</p> <p>Instead of: <pre><code># Traditional reactive approach\nstore.counter.subscribe(lambda v: print(v))\nstore.counter.set(5)\n\n# Manual dependency tracking\ndef update_total():\n    total = store.price.value * store.quantity.value\n</code></pre></p> <p>You can write: <pre><code># Transparent reactive approach\nprint(store.counter)  # Direct access\nstore.counter = 5     # Automatic updates\n\n# Automatic dependency tracking\ntotal = store.price * store.quantity  # Reactive computation\n</code></pre></p>"},{"location":"generation/markdown/observable-descriptors/#fynx.observable.descriptors--how-it-works","title":"How It Works","text":"<p>The descriptor system works through two key components:</p> <ol> <li> <p>SubscriptableDescriptor: Attached to class attributes, creates and manages    the underlying Observable instances at the class level.</p> </li> <li> <p>ObservableValue: Returned when accessing descriptor attributes, provides    transparent value access while maintaining reactive capabilities.</p> </li> </ol> <p>When you access <code>store.counter</code>, the descriptor returns an ObservableValue that wraps the actual Observable, allowing natural value operations while preserving reactive behavior.</p>"},{"location":"generation/markdown/observable-descriptors/#fynx.observable.descriptors--key-benefits","title":"Key Benefits","text":"<ul> <li>Familiar Syntax: Use regular attribute access (<code>obj.attr = value</code>)</li> <li>Reactive Capabilities: Full access to subscription and operators</li> <li>Type Safety: Maintains type information through generics</li> <li>Performance: Efficient caching and lazy evaluation</li> <li>Compatibility: Works with existing Python idioms (iteration, comparison, etc.)</li> </ul>"},{"location":"generation/markdown/observable-descriptors/#fynx.observable.descriptors--common-patterns","title":"Common Patterns","text":"<p>Store Attributes: <pre><code>class UserStore(Store):\n    name = observable(\"Alice\")\n    age = observable(30)\n\n# Access like regular attributes\nprint(UserStore.name)      # \"Alice\"\nUserStore.age = 31         # Triggers reactive updates\n\n# But also provides reactive methods\nUserStore.name.subscribe(lambda n: print(f\"Name: {n}\"))\n</code></pre></p> <p>Transparent Integration: <pre><code># Works with existing Python constructs\nif store.is_enabled:\n    print(\"Enabled\")\n\nfor item in store.items:\n    print(item)\n\n# String formatting\nmessage = f\"User: {store.name}, Age: {store.age}\"\n</code></pre></p> <p>Reactive Operators: <pre><code># All operators work transparently\nfull_name = store.first_name | store.last_name &gt;&gt; (lambda f, l: f\"{f} {l}\")\nis_adult = store.age &gt;&gt; (lambda a: a &gt;= 18)\nvalid_user = store.name &amp; is_adult\n</code></pre></p>"},{"location":"generation/markdown/observable-descriptors/#fynx.observable.descriptors--implementation-details","title":"Implementation Details","text":"<p>Descriptor Protocol: Uses <code>__get__</code>, <code>__set__</code>, and <code>__set_name__</code> to integrate with Python's attribute system.</p> <p>Class-Level Storage: Observables are stored at the class level to ensure shared state across instances.</p> <p>Lazy Initialization: ObservableValue instances are created on-demand and cached for performance.</p> <p>Type Preservation: Generic types ensure compile-time type safety.</p>"},{"location":"generation/markdown/observable-descriptors/#fynx.observable.descriptors--performance-considerations","title":"Performance Considerations","text":"<ul> <li>Memory Efficient: Reuses Observable instances across attribute access</li> <li>Lazy Creation: ObservableValue wrappers created only when needed</li> <li>Minimal Overhead: Thin wrapper around actual Observable instances</li> <li>Caching: Internal caching prevents redundant operations</li> </ul>"},{"location":"generation/markdown/observable-descriptors/#fynx.observable.descriptors--best-practices","title":"Best Practices","text":"<ul> <li>Use Store Classes: Leverage descriptors through Store classes for better organization</li> <li>Consistent Access: Use either direct access or reactive methods, not both inconsistently</li> <li>Type Hints: Provide type annotations for better IDE support</li> <li>Documentation: Document store attributes and their purposes</li> </ul>"},{"location":"generation/markdown/observable-descriptors/#fynx.observable.descriptors--limitations","title":"Limitations","text":"<ul> <li>Descriptor behavior requires class-level attribute assignment</li> <li>Not suitable for instance-specific reactive attributes</li> <li>Some advanced Python features may not work as expected with wrapped values</li> </ul>"},{"location":"generation/markdown/observable-descriptors/#fynx.observable.descriptors--see-also","title":"See Also","text":"<ul> <li><code>fynx.store</code>: Store classes that use these descriptors</li> <li><code>fynx.observable</code>: Core observable classes</li> <li><code>fynx.computed</code>: Creating derived reactive values</li> </ul>"},{"location":"generation/markdown/observable-descriptors/#fynx.observable.descriptors.ObservableValue","title":"ObservableValue","text":"<pre><code>ObservableValue(observable)\n</code></pre> <p>A transparent wrapper that combines direct value access with observable capabilities.</p> <p>ObservableValue acts as a bridge between regular Python value access and reactive programming. It behaves like the underlying value in most contexts (equality, string conversion, iteration, etc.) while also providing access to observable methods like subscription and operator overloading.</p> <p>This class enables Store classes and other descriptor-based reactive systems to provide both familiar value access (<code>store.attr = value</code>) and reactive capabilities (<code>store.attr.subscribe(callback)</code>) through a single attribute.</p> <p>Key Features: - Transparent Value Access: Behaves like the underlying value for most operations - Observable Methods: Provides subscription and reactive operator access - Automatic Synchronization: Keeps the displayed value in sync with the observable - Operator Support: Enables <code>|</code>, <code>&gt;&gt;</code>, and other reactive operators - Type Safety: Generic type parameter ensures type-safe operations</p> Example <pre><code>from fynx import Store, observable\n\nclass CounterStore(Store):\n    count = observable(0)\n\n# ObservableValue provides both value access and reactive methods\ncounter = CounterStore.count\n\n# Direct value access (like a regular attribute)\nprint(counter)              # 0\nprint(counter == 0)         # True\nprint(len(counter))         # TypeError (unless value is a collection)\n\n# Observable methods\ncounter.set(5)              # Update the value\ncounter.subscribe(lambda x: print(f\"Count: {x}\"))\n\n# Reactive operators\ndoubled = counter &gt;&gt; (lambda x: x * 2)\n</code></pre> Note <p>ObservableValue instances are typically created automatically by SubscriptableDescriptor when accessing observable attributes on Store classes. You usually won't instantiate this class directly.</p> See Also <p>SubscriptableDescriptor: Creates ObservableValue instances for class attributes Observable: The underlying reactive value class Store: Uses ObservableValue for transparent reactive attributes</p>"},{"location":"generation/markdown/observable-descriptors/#fynx.observable.descriptors.ObservableValue.observable","title":"observable","text":"<pre><code>observable\n</code></pre> <p>Get the underlying observable instance.</p>"},{"location":"generation/markdown/observable-descriptors/#fynx.observable.descriptors.ObservableValue.__or__","title":"__or__","text":"<pre><code>__or__(other)\n</code></pre> <p>Support merging observables with | operator.</p>"},{"location":"generation/markdown/observable-descriptors/#fynx.observable.descriptors.ObservableValue.__rshift__","title":"__rshift__","text":"<pre><code>__rshift__(func)\n</code></pre> <p>Support computed observables with &gt;&gt; operator.</p>"},{"location":"generation/markdown/observable-descriptors/#fynx.observable.descriptors.SubscriptableDescriptor","title":"SubscriptableDescriptor","text":"<pre><code>SubscriptableDescriptor(initial_value=None, original_observable=None)\n</code></pre> <p>Descriptor that creates reactive class attributes with transparent observable behavior.</p> <p>SubscriptableDescriptor enables Store classes and other reactive containers to define attributes that behave like regular Python attributes while providing full reactive capabilities. When accessed, it returns an ObservableValue instance that combines direct value access with observable methods.</p> <p>This descriptor is the foundation for FynX's transparent reactive programming model, allowing you to write code that looks like regular attribute access while maintaining full reactive capabilities.</p> <p>Key Features: - Class-Level Observables: Creates observables at the class level for shared state - Transparent Access: Attributes behave like regular values but are reactive - Automatic Management: Handles observable lifecycle and descriptor protocol - Store Integration: Designed to work seamlessly with Store classes - Memory Efficient: Reuses observable instances across class access</p> How It Works <ol> <li>When assigned to a class attribute, stores initial value and owner class</li> <li>On first access, creates a class-level Observable instance</li> <li>Returns an ObservableValue wrapper for transparent reactive access</li> <li>Subsequent accesses reuse the same observable instance</li> </ol> Example <pre><code>from fynx import Store, observable\n\nclass UserStore(Store):\n    # This creates a SubscriptableDescriptor\n    name = observable(\"Alice\")\n    age = observable(30)\n\n# Access returns ObservableValue instances\nuser_name = UserStore.name    # ObservableValue wrapping Observable\nuser_age = UserStore.age      # ObservableValue wrapping Observable\n\n# Behaves like regular attributes\nprint(user_name)              # \"Alice\"\nUserStore.name = \"Bob\"        # Updates the observable\nprint(user_name)              # \"Bob\"\n\n# But also provides reactive methods\nUserStore.name.subscribe(lambda n: print(f\"Name changed to: {n}\"))\n</code></pre> Note <p>This descriptor is typically used indirectly through the <code>observable()</code> function in Store classes. Direct instantiation is usually not needed.</p> See Also <p>ObservableValue: The wrapper returned by this descriptor observable: Convenience function that creates SubscriptableDescriptor instances Store: Uses this descriptor for reactive class attributes</p>"},{"location":"generation/markdown/observable-descriptors/#fynx.observable.descriptors.SubscriptableDescriptor.__get__","title":"__get__","text":"<pre><code>__get__(instance, owner)\n</code></pre> <p>Get the observable value for this attribute.</p>"},{"location":"generation/markdown/observable-descriptors/#fynx.observable.descriptors.SubscriptableDescriptor.__set__","title":"__set__","text":"<pre><code>__set__(instance, value)\n</code></pre> <p>Set the value on the observable.</p>"},{"location":"generation/markdown/observable-descriptors/#fynx.observable.descriptors.SubscriptableDescriptor.__set_name__","title":"__set_name__","text":"<pre><code>__set_name__(owner, name)\n</code></pre> <p>Called when the descriptor is assigned to a class attribute.</p>"},{"location":"generation/markdown/observable-operators/","title":"Observable Operators","text":"<p>Special operators for composing and transforming observables.</p>"},{"location":"generation/markdown/observable-operators/#fynx.observable.operators--fynx-operators-observable-operator-implementations","title":"FynX Operators - Observable Operator Implementations","text":"<p>This module provides the core operator implementations that enable FynX's fluent reactive programming syntax. These operators allow observables to be composed using intuitive Python operators, creating complex reactive behaviors from simple building blocks.</p>"},{"location":"generation/markdown/observable-operators/#fynx.observable.operators--why-operators","title":"Why Operators?","text":"<p>FynX uses Python's operator overloading to provide a natural, readable syntax for reactive programming. Instead of verbose method calls, you can express reactive relationships using familiar operators:</p> <ul> <li><code>observable &gt;&gt; function</code> - Transform values reactively</li> <li><code>observable &amp; condition</code> - Filter values conditionally</li> <li><code>obs1 | obs2 | obs3</code> - Combine observables</li> </ul> <p>This approach makes reactive code more declarative and easier to understand.</p>"},{"location":"generation/markdown/observable-operators/#fynx.observable.operators--operator-overview","title":"Operator Overview","text":"<p>Transform (<code>&gt;&gt;</code>): Apply functions to create derived values <pre><code>doubled = counter &gt;&gt; (lambda x: x * 2)\n</code></pre></p> <p>Filter (<code>&amp;</code>): Only emit values when conditions are met <pre><code>valid_data = data &amp; is_valid\n</code></pre></p> <p>Combine (<code>|</code>): Merge multiple observables into tuples <pre><code>coordinates = x | y | z\n</code></pre></p> <p>These operators work together to create complex reactive pipelines: <pre><code>result = (x | y) &gt;&gt; (lambda a, b: a + b) &amp; (total &gt;&gt; (lambda t: t &gt; 10))\n</code></pre></p>"},{"location":"generation/markdown/observable-operators/#fynx.observable.operators--implementation-details","title":"Implementation Details","text":"<p>The operators are implemented as standalone functions rather than methods to avoid circular import issues and enable lazy loading. They are called automatically when you use the corresponding operators on Observable instances.</p> <p>The functions handle different observable types (regular, merged, conditional) appropriately, ensuring consistent behavior across the reactive system.</p>"},{"location":"generation/markdown/observable-operators/#fynx.observable.operators--performance-characteristics","title":"Performance Characteristics","text":"<ul> <li>Lazy Evaluation: Operators create computed/conditional observables that   only evaluate when needed</li> <li>Efficient Composition: Multiple operators can be chained without   creating intermediate objects</li> <li>Memory Conscious: Operators reuse existing infrastructure rather than   creating new classes</li> </ul>"},{"location":"generation/markdown/observable-operators/#fynx.observable.operators--common-patterns","title":"Common Patterns","text":"<p>Data Processing Pipeline: <pre><code>raw_data = observable([])\nprocessed = (raw_data\n    &gt;&gt; (lambda d: [x for x in d if x &gt; 0])  # Filter positive values\n    &gt;&gt; (lambda d: sorted(d))                # Sort results\n    &gt;&gt; (lambda d: sum(d) / len(d) if d else 0))  # Calculate average\n</code></pre></p> <p>Conditional UI Updates: <pre><code>user_input = observable(\"\")\nis_valid = user_input &gt;&gt; (lambda s: len(s) &gt;= 3)\nshow_error = user_input &amp; ~is_valid  # Show error when input is invalid but not empty\n</code></pre></p> <p>Reactive Calculations: <pre><code>price = observable(10.0)\nquantity = observable(1)\ntax_rate = observable(0.08)\n\nsubtotal = (price | quantity) &gt;&gt; (lambda p, q: p * q)\ntax = subtotal &gt;&gt; (lambda s: s * tax_rate.value)\ntotal = (subtotal | tax) &gt;&gt; (lambda s, t: s + t)\n</code></pre></p>"},{"location":"generation/markdown/observable-operators/#fynx.observable.operators--error-handling","title":"Error Handling","text":"<p>Operators handle errors gracefully: - Transformation function errors are propagated but don't break the reactive system - Invalid operator usage provides clear error messages - Circular dependencies are detected and prevented</p>"},{"location":"generation/markdown/observable-operators/#fynx.observable.operators--best-practices","title":"Best Practices","text":"<ul> <li>Keep Functions Pure: Transformation functions should not have side effects</li> <li>Use Meaningful Lambdas: Complex operations deserve named functions</li> <li>Chain Thoughtfully: Break complex chains into intermediate variables for clarity</li> <li>Handle Edge Cases: Consider what happens with None, empty collections, etc.</li> </ul>"},{"location":"generation/markdown/observable-operators/#fynx.observable.operators--migration-from-method-calls","title":"Migration from Method Calls","text":"<p>If you're familiar with other reactive libraries, here's how FynX operators compare:</p> <pre><code># Other libraries (method-based)\nresult = obs.map(lambda x: x * 2).filter(lambda x: x &gt; 10)\n\n# FynX (operator-based)\nresult = obs &gt;&gt; (lambda x: x * 2) &amp; (obs &gt;&gt; (lambda x: x &gt; 10))\n</code></pre> <p>The operator syntax is more concise and readable for simple transformations.</p>"},{"location":"generation/markdown/observable-operators/#fynx.observable.operators--see-also","title":"See Also","text":"<ul> <li><code>fynx.observable</code>: Core observable classes that use these operators</li> <li><code>fynx.computed</code>: Computed observables created by the <code>&gt;&gt;</code> operator</li> <li><code>fynx.watch</code>: Conditional reactive functions (alternative to <code>&amp;</code>)</li> </ul>"},{"location":"generation/markdown/observable-operators/#fynx.observable.operators.and_operator","title":"and_operator","text":"<pre><code>and_operator(obs, condition)\n</code></pre> <p>Implement the <code>&amp;</code> operator for creating conditional observables.</p> <p>This operator creates conditional observables that only emit values when boolean conditions are satisfied. The resulting observable filters the reactive stream, preventing unnecessary updates and computations when conditions aren't met.</p> <p>Parameters:</p> Name Type Description Default <code>obs</code> <code>Observable[T]</code> <p>The source observable whose values will be conditionally emitted.</p> required <code>condition</code> <code>Observable[bool]</code> <p>A boolean observable that acts as a gate. Values from <code>obs</code>       are only emitted when this condition is True.</p> required <p>Returns:</p> Type Description <code>Observable[T]</code> <p>A new ConditionalObservable that only emits values when the condition is met.</p> <code>Observable[T]</code> <p>The observable starts with None if the condition is initially False.</p> <p>Examples:</p> <pre><code>from fynx.observable import Observable\n\n# Basic conditional filtering\ndata = Observable(\"data\", \"hello\")\nis_ready = Observable(\"ready\", False)\n\nfiltered = data &amp; is_ready  # Only emits when is_ready is True\n\nfiltered.subscribe(lambda x: print(f\"Received: {x}\"))\ndata.set(\"world\")      # No output (is_ready is False)\nis_ready.set(True)     # Prints: \"Received: world\"\n\n# Multiple conditions (chained)\nuser_present = Observable(\"present\", True)\nsmart_data = data &amp; is_ready &amp; user_present  # All must be True\n\n# Practical example: temperature monitoring\ntemperature = Observable(\"temp\", 20)\nalarm_enabled = Observable(\"alarm\", True)\nis_critical = Observable(\"critical\", False)\n\nalarm_trigger = temperature &amp; alarm_enabled &amp; is_critical\nalarm_trigger.subscribe(lambda t: print(f\"\ud83d\udea8 Alarm: {t}\u00b0C\"))\n</code></pre> Note <p>Multiple conditions can be chained: <code>obs &amp; cond1 &amp; cond2 &amp; cond3</code>. All conditions must be True for values to be emitted.</p> See Also <p>ConditionalObservable: The class that implements conditional behavior Observable.and: The magic method that calls this operator</p>"},{"location":"generation/markdown/observable-operators/#fynx.observable.operators.rshift_operator","title":"rshift_operator","text":"<pre><code>rshift_operator(obs, func)\n</code></pre> <p>Implement the <code>&gt;&gt;</code> operator for creating computed observables.</p> <p>This operator enables the functorial map operation over observables, transforming observable values through pure functions while preserving reactivity. The resulting computed observable automatically updates whenever the source observable changes.</p> <p>For merged observables (created with <code>|</code>), the function receives multiple arguments corresponding to the tuple values. For single observables, it receives one argument.</p> <p>Parameters:</p> Name Type Description Default <code>obs</code> <code>Observable[T]</code> <p>The source observable(s) to transform. Can be a single Observable or  a MergedObservable (from <code>|</code> operator).</p> required <code>func</code> <code>Callable[..., U]</code> <p>A pure function that transforms the observable value(s). For merged   observables, receives unpacked tuple values as separate arguments.</p> required <p>Returns:</p> Type Description <code>Observable[U]</code> <p>A new computed observable containing the transformed values. Updates automatically</p> <code>Observable[U]</code> <p>when source observables change.</p> <p>Examples:</p> <pre><code>from fynx.observable import Observable\n\n# Single observable transformation\ncounter = Observable(\"counter\", 5)\ndoubled = counter &gt;&gt; (lambda x: x * 2)  # ComputedObservable with value 10\n\n# Merged observable transformation\nwidth = Observable(\"width\", 10)\nheight = Observable(\"height\", 20)\narea = (width | height) &gt;&gt; (lambda w, h: w * h)  # ComputedObservable with value 200\n\n# Function chaining\nresult = counter &gt;&gt; (lambda x: x + 1) &gt;&gt; str &gt;&gt; (lambda s: f\"Count: {s}\")\n# Result: \"Count: 6\"\n</code></pre> Note <p>The transformation function should be pure (no side effects) and relatively fast, as it may be called frequently when dependencies change.</p> See Also <p>computed: The underlying function that creates computed observables MergedObservable: For combining multiple observables with <code>|</code></p>"},{"location":"generation/markdown/observable/","title":"Observable","text":"<p>The core observable class that provides reactive values.</p> <p>A reactive value that automatically notifies dependents when it changes.</p> <p>Observable is the core primitive of FynX's reactivity system. It wraps a value and provides transparent reactive behavior - when the value changes, all dependent computations and reactions are automatically notified and updated.</p> <p>Key Features: - Transparent: Behaves like a regular value but with reactive capabilities - Dependency Tracking: Automatically tracks which reactive contexts depend on it - Change Notification: Notifies all observers when the value changes - Type Safety: Generic type parameter ensures type-safe operations - Lazy Evaluation: Computations only re-run when actually needed - Circular Dependency Detection: Prevents infinite loops at runtime</p> <p>Observable implements various magic methods (<code>__eq__</code>, <code>__str__</code>, etc.) to behave like its underlying value in most contexts, making it easy to use in existing code without modification.</p> <p>Attributes:</p> Name Type Description <code>key</code> <code>Optional[str]</code> <p>Unique identifier for debugging and serialization</p> <code>_value</code> <code>Optional[T]</code> <p>The current wrapped value</p> <code>_observers</code> <code>Set[Callable]</code> <p>Set of observer functions</p> Class Attributes <p>_current_context (Optional[ReactiveContext]): Current reactive execution context _context_stack (List[ReactiveContext]): Stack of nested reactive contexts</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Optional[str]</code> <p>A unique identifier for this observable (used for debugging).  If None, will be set to \"\" and updated in set_name. <code>None</code> <code>initial_value</code> <code>Optional[T]</code> <p>The initial value to store. Can be any type.</p> <code>None</code> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If a circular dependency is detected during value updates.</p> Example <pre><code>from fynx.observable import Observable\n\n# Create an observable\ncounter = Observable(\"counter\", 0)\n\n# Direct access (transparent behavior)\nprint(counter.value)  # 0\nprint(counter == 0)   # True\nprint(str(counter))   # \"0\"\n\n# Subscribe to changes\ndef on_change():\n    print(f\"Counter changed to: {counter.value}\")\n\ncounter.subscribe(on_change)\ncounter.set(5)  # Prints: \"Counter changed to: 5\"\n</code></pre> Note <p>While you can create Observable instances directly, it's often more convenient to use the <code>observable()</code> descriptor in Store classes for better organization and automatic serialization support.</p> See Also <p>Store: For organizing observables into reactive state containers computed: For creating derived values from observables reactive: For creating reactive functions that respond to changes</p> <p>Initialize an observable value.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Optional[str]</code> <p>A unique identifier for this observable (used for serialization).  If None, will be set to \"\" and updated in set_name. <code>None</code> <code>initial_value</code> <code>Optional[T]</code> <p>The initial value to store</p> <code>None</code>"},{"location":"generation/markdown/observable/#fynx.observable.base.Observable.value","title":"value","text":"<pre><code>value\n</code></pre> <p>Get the current value of this observable.</p> <p>Accessing the value property automatically registers this observable as a dependency if called within a reactive context (computation or reaction).</p> <p>Returns:</p> Type Description <code>Optional[T]</code> <p>The current value stored in this observable, or None if not set.</p> Note <p>This property is tracked by the reactive system. Use it instead of accessing _value directly to ensure proper dependency tracking.</p> Example <pre><code>obs = Observable(\"counter\", 5)\nprint(obs.value)  # 5\n\n# In a reactive context, this creates a dependency\n@reactive(obs)\ndef print_value(val):\n    print(f\"Value: {val}\")\n</code></pre>"},{"location":"generation/markdown/observable/#fynx.observable.base.Observable.__and__","title":"__and__","text":"<pre><code>__and__(condition)\n</code></pre> <p>Create a conditional observable using the &amp; operator for filtered reactivity.</p> <p>This creates a ConditionalObservable that only emits values from the source observable when the specified condition (and any chained conditions) are all True. This enables precise control over when reactive updates occur, preventing unnecessary computations and side effects.</p> <p>Parameters:</p> Name Type Description Default <code>condition</code> <code>Observable[bool]</code> <p>A boolean Observable that acts as a gate. The source observable's       values are only emitted when this condition is True.</p> required <p>Returns:</p> Type Description <code>ConditionalObservable[T]</code> <p>A ConditionalObservable that filters the source observable's updates</p> <code>ConditionalObservable[T]</code> <p>based on the condition. The conditional observable starts with None</p> <code>ConditionalObservable[T]</code> <p>if the condition is initially False.</p> <p>Examples:</p> <pre><code>from fynx.observable import Observable\n\n# Basic conditional filtering\ntemperature = Observable(\"temp\", 20)\nis_heating_on = Observable(\"heating\", False)\n\n# Only emit temperature when heating is on\nheating_temp = temperature &amp; is_heating_on\n\nheating_temp.subscribe(lambda t: print(f\"Maintaining {t}\u00b0C\"))\ntemperature.set(22)     # No output (heating off)\nis_heating_on.set(True) # Prints: \"Maintaining 22\u00b0C\"\ntemperature.set(25)     # Prints: \"Maintaining 25\u00b0C\"\n\n# Multiple conditions (chained)\nis_valid = Observable(\"valid\", True)\nsmart_heating = temperature &amp; is_heating_on &amp; is_valid\n\n# Resource optimization\nnetwork_available = Observable(\"network\", True)\nbattery_level = Observable(\"battery\", 80)\n\n# Only sync when network is available AND battery is not low\nsync_data = data_changes &amp; network_available &amp; (battery_level &gt;&gt; (lambda b: b &gt; 20))\n</code></pre> Note <p>Multiple conditions can be chained: <code>obs &amp; cond1 &amp; cond2 &amp; cond3</code>. All conditions must be True for values to be emitted.</p> See Also <p>ConditionalObservable: The class that implements conditional behavior invert: For negating boolean conditions watch: For conditional reactive functions with complex logic</p>"},{"location":"generation/markdown/observable/#fynx.observable.base.Observable.__bool__","title":"__bool__","text":"<pre><code>__bool__()\n</code></pre> <p>Boolean conversion returns whether the value is truthy.</p> <p>This allows observables to be used directly in boolean contexts (if statements, boolean operations) just like regular values.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the wrapped value is truthy, False otherwise.</p> Example <pre><code>obs = Observable(\"flag\", True)\nif obs:  # Works like if obs.value\n    print(\"Observable is truthy\")\n\nobs.set(0)  # False\nif not obs:  # Works like if not obs.value\n    print(\"Observable is falsy\")\n</code></pre>"},{"location":"generation/markdown/observable/#fynx.observable.base.Observable.__eq__","title":"__eq__","text":"<pre><code>__eq__(other)\n</code></pre> <p>Equality comparison with another value or observable.</p> <p>Compares the wrapped values for equality. If comparing with another Observable, compares their wrapped values.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>object</code> <p>Value or Observable to compare with</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the values are equal, False otherwise.</p> Example <pre><code>obs1 = Observable(\"a\", 5)\nobs2 = Observable(\"b\", 5)\nregular_val = 5\n\nobs1 == obs2      # True (both wrap 5)\nobs1 == regular_val  # True (observable equals regular value)\nobs1 == 10        # False (5 != 10)\n</code></pre>"},{"location":"generation/markdown/observable/#fynx.observable.base.Observable.__hash__","title":"__hash__","text":"<pre><code>__hash__()\n</code></pre> <p>Hash based on object identity, not value.</p> <p>Since values may be unhashable (like dicts, lists), observables hash based on their object identity rather than their value.</p> <p>Returns:</p> Type Description <code>int</code> <p>Hash of the observable's object identity.</p> Note <p>This means observables with the same value will not be considered equal for hashing purposes, only identical objects.</p> Example <pre><code>obs1 = Observable(\"a\", [1, 2, 3])\nobs2 = Observable(\"b\", [1, 2, 3])\n\n# These will have different hashes despite same value\nhash(obs1) != hash(obs2)  # True\n\n# But identical objects hash the same\nhash(obs1) == hash(obs1)  # True\n</code></pre>"},{"location":"generation/markdown/observable/#fynx.observable.base.Observable.__invert__","title":"__invert__","text":"<pre><code>__invert__()\n</code></pre> <p>Create a negated boolean observable using the ~ operator.</p> <p>This creates a computed observable that returns the logical negation of the current observable's boolean value. Useful for creating inverse conditions and boolean logic in reactive expressions.</p> <p>Returns:</p> Type Description <code>Observable[bool]</code> <p>A computed Observable[bool] with the negated boolean value.</p> <code>Observable[bool]</code> <p>Updates automatically when the source observable changes.</p> <p>Examples:</p> <pre><code>from fynx.observable import Observable\n\nis_loading = Observable(\"loading\", False)\n\n# Create negated observable\nis_not_loading = ~is_loading  # True when is_loading is False\n\n# Use in conditional logic\ncan_interact = ~is_loading\ncan_interact.subscribe(lambda can: print(f\"Can interact: {can}\"))\n\nis_loading.set(True)   # Prints: \"Can interact: False\"\nis_loading.set(False)  # Prints: \"Can interact: True\"\n\n# Chain with other conditions\nis_enabled = Observable(\"enabled\", True)\nshould_show_spinner = is_loading &amp; is_enabled\nshould_hide_content = is_loading &amp; ~is_enabled  # Loading but not enabled\n\n# Complex boolean logic\nis_valid = Observable(\"valid\", True)\nhas_errors = Observable(\"errors\", False)\n\ncan_submit = is_valid &amp; ~has_errors &amp; ~is_loading\n</code></pre> Note <p>This creates a computed observable, so the negation is evaluated lazily and cached until the source value changes.</p> See Also <p>and: For combining conditions with AND logic computed: For creating other computed transformations</p>"},{"location":"generation/markdown/observable/#fynx.observable.base.Observable.__or__","title":"__or__","text":"<pre><code>__or__(other)\n</code></pre> <p>Combine this observable with another using the | operator.</p> <p>This creates a merged observable that contains a tuple of both values and updates automatically when either observable changes.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Observable</code> <p>Another Observable to combine with</p> required <p>Returns:</p> Type Description <code>MergedObservable[T]</code> <p>A MergedObservable containing both values as a tuple</p> Example <pre><code>combined = obs1 | obs2  # Creates MergedObservable((obs1.value, obs2.value))\ncombined2 = combined | obs3  # Creates MergedObservable((obs1.value, obs2.value, obs3.value))\n</code></pre>"},{"location":"generation/markdown/observable/#fynx.observable.base.Observable.__repr__","title":"__repr__","text":"<pre><code>__repr__()\n</code></pre> <p>Developer representation showing the observable's key and current value.</p> <p>Returns:</p> Type Description <code>str</code> <p>A string representation useful for debugging and development.</p> Example <pre><code>obs = Observable(\"counter\", 42)\nprint(repr(obs))  # Observable('counter', 42)\n</code></pre>"},{"location":"generation/markdown/observable/#fynx.observable.base.Observable.__rshift__","title":"__rshift__","text":"<pre><code>__rshift__(func)\n</code></pre> <p>Apply a transformation function using the &gt;&gt; operator to create computed observables.</p> <p>This implements the functorial map operation over observables, allowing you to transform observable values through pure functions while preserving reactivity. The result is a new observable that automatically updates when the source changes.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable</code> <p>A pure function to apply to the observable's value(s).   For single observables, receives the current value.   For merged observables, receives unpacked tuple values as separate arguments.</p> required <p>Returns:</p> Type Description <code>Observable</code> <p>A new computed Observable containing the transformed values.</p> <p>Examples:</p> <pre><code>from fynx.observable import Observable\n\n# Single observable transformation\ncounter = Observable(\"counter\", 5)\ndoubled = counter &gt;&gt; (lambda x: x * 2)  # Observable with value 10\n\n# String formatting\nname = Observable(\"name\", \"Alice\")\ngreeting = name &gt;&gt; (lambda n: f\"Hello, {n}!\")\n\n# Merged observable transformation\nwidth = Observable(\"width\", 10)\nheight = Observable(\"height\", 20)\narea = (width | height) &gt;&gt; (lambda w, h: w * h)  # Observable with value 200\n\n# Complex chaining\nresult = counter &gt;&gt; (lambda x: x + 1) &gt;&gt; str &gt;&gt; (lambda s: f\"Count: {s}\")\n# Result: Observable with value \"Count: 6\"\n</code></pre> Note <p>The transformation function should be pure (no side effects) and relatively fast, as it may be called frequently when dependencies change.</p> See Also <p>computed: The underlying function that creates computed observables or: For merging observables before transformation</p>"},{"location":"generation/markdown/observable/#fynx.observable.base.Observable.__set_name__","title":"__set_name__","text":"<pre><code>__set_name__(owner, name)\n</code></pre> <p>Called when this Observable is assigned to a class attribute.</p> <p>This method implements the descriptor protocol to enable automatic conversion of Observable instances to appropriate descriptors based on the owning class type.</p> <p>For Store classes, the conversion is handled by StoreMeta metaclass. For other classes, converts to SubscriptableDescriptor for class-level observable behavior.</p> <p>Parameters:</p> Name Type Description Default <code>owner</code> <code>Type</code> <p>The class that owns this attribute</p> required <code>name</code> <code>str</code> <p>The name of the attribute being assigned</p> required Note <p>This method is called automatically by Python when an Observable instance is assigned to a class attribute. It modifies the class to use the appropriate descriptor for reactive behavior.</p> Example <pre><code>class MyClass:\n    obs = Observable(\"counter\", 0)  # __set_name__ called here\n\n# Gets converted to a descriptor automatically\ninstance = MyClass()\nprint(instance.obs)  # Uses descriptor\n</code></pre>"},{"location":"generation/markdown/observable/#fynx.observable.base.Observable.__str__","title":"__str__","text":"<pre><code>__str__()\n</code></pre> <p>String representation of the wrapped value.</p> <p>Returns the string representation of the current value, enabling observables to be used seamlessly in string contexts.</p> <p>Returns:</p> Type Description <code>str</code> <p>String representation of the wrapped value.</p> Example <pre><code>obs = Observable(\"name\", \"Alice\")\nprint(f\"Hello {obs}\")  # Prints: \"Hello Alice\"\nmessage = \"User: \" + obs  # Works like \"User: \" + obs.value\n</code></pre>"},{"location":"generation/markdown/observable/#fynx.observable.base.Observable.add_observer","title":"add_observer","text":"<pre><code>add_observer(observer)\n</code></pre> <p>Add an observer function that will be called when this observable changes.</p> <p>Parameters:</p> Name Type Description Default <code>observer</code> <code>Callable</code> <p>A callable that takes no arguments</p> required"},{"location":"generation/markdown/observable/#fynx.observable.base.Observable.remove_observer","title":"remove_observer","text":"<pre><code>remove_observer(observer)\n</code></pre> <p>Remove an observer function.</p> <p>Parameters:</p> Name Type Description Default <code>observer</code> <code>Callable</code> <p>The observer function to remove</p> required"},{"location":"generation/markdown/observable/#fynx.observable.base.Observable.set","title":"set","text":"<pre><code>set(value)\n</code></pre> <p>Set the value and notify all observers if the value changed.</p> <p>This method updates the observable's value and triggers change notifications to all registered observers. The update only occurs if the new value is different from the current value (using != comparison).</p> <p>Circular dependency detection is performed to prevent infinite loops where a computation tries to modify one of its own dependencies.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Optional[T]</code> <p>The new value to set. Can be any type compatible with the    observable's generic type parameter.</p> required <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If setting this value would create a circular dependency          (e.g., a computed value trying to modify its own input).</p> Example <pre><code>obs = Observable(\"counter\", 0)\nobs.set(5)  # Triggers observers if value changed\n\n# No change, no notification\nobs.set(5)  # Same value, observers not called\n</code></pre> Note <p>Equality is checked using <code>!=</code> operator, so custom objects should implement proper equality comparison if needed.</p>"},{"location":"generation/markdown/observable/#fynx.observable.base.Observable.subscribe","title":"subscribe","text":"<pre><code>subscribe(func)\n</code></pre> <p>Subscribe a function to react to changes in this observable.</p> <p>The subscribed function will be called immediately with the current value, and then again whenever the observable's value changes.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable</code> <p>A callable that accepts one argument (the new value).   The function will be called with the observable's current value   immediately upon subscription, and again whenever the value changes.</p> required <p>Returns:</p> Type Description <code>Observable[T]</code> <p>This observable instance for method chaining.</p> Example <pre><code>def on_change(new_value):\n    print(f\"Observable changed to: {new_value}\")\n\nobs = Observable(\"counter\", 0)\nobs.subscribe(on_change)  # Prints: \"Observable changed to: 0\"\n\nobs.set(5)  # Prints: \"Observable changed to: 5\"\n</code></pre> Note <p>The function is called immediately upon subscription with the current value. This ensures the subscriber gets the initial state.</p> See Also <p>unsubscribe: Remove a subscription reactive: Decorator-based subscription with automatic dependency tracking</p>"},{"location":"generation/markdown/observable/#fynx.observable.base.Observable.unsubscribe","title":"unsubscribe","text":"<pre><code>unsubscribe(func)\n</code></pre> <p>Unsubscribe a function from this observable.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable</code> <p>The function to unsubscribe from this observable</p> required"},{"location":"generation/markdown/observables/","title":"Observables: The Foundation of Reactivity","text":"<p>An observable is a value that changes over time and tells you when it changes. That's it. Everything else in FynX\u2014every operator, every decorator, every pattern\u2014builds on this simple idea.</p> <p>Think of a regular Python variable:</p> <pre><code>count = 0\ncount = 1\ncount = 2\n</code></pre> <p>When <code>count</code> changes, nothing happens. The value updates silently, and any code that depends on <code>count</code> has no idea. You have to manually check for changes, manually update dependent state, manually keep everything synchronized.</p> <p>Now think of an observable:</p> <pre><code>from fynx import observable\n\ncount = observable(0)\ncount.set(1)\ncount.set(2)\n</code></pre> <p>When an observable changes, it notifies anyone who's listening. Dependent computations recalculate automatically. UI updates happen without explicit instructions. The reactive graph maintains its own consistency.</p> <p>This is the fundamental shift: from telling your code when to update to declaring what should be true. FynX handles the rest.</p>"},{"location":"generation/markdown/observables/#creating-your-first-observable","title":"Creating Your First Observable","text":"<p>Start by importing the <code>observable</code> function and giving it an initial value:</p> <pre><code>from fynx import observable\n\n# Create observables with initial values of any type\nname = observable(\"Alice\")\nage = observable(30)\nscores = observable([85, 92, 78])\nuser = observable({\"id\": 1, \"active\": True})\n</code></pre> <p>The initial value can be anything\u2014strings, numbers, lists, dictionaries, custom objects, even <code>None</code>. FynX doesn't care about the type. It just wraps the value and makes it reactive.</p>"},{"location":"generation/markdown/observables/#reading-observable-values","title":"Reading Observable Values","text":"<p>To read what's inside an observable, use the <code>.value</code> property:</p> <pre><code>name = observable(\"Alice\")\n\nprint(name.value)  # \"Alice\"\nprint(age.value)   # 30\n</code></pre> <p>This looks like extra syntax compared to regular variables, and it is. But that <code>.value</code> access does something important: it registers that your code depends on this observable. When you read <code>.value</code> inside a reactive context (we'll get to those soon), FynX automatically tracks the dependency and ensures your code re-runs when the observable changes.</p>"},{"location":"generation/markdown/observables/#writing-observable-values","title":"Writing Observable Values","text":"<p>To change what's inside an observable, use the <code>.set()</code> method:</p> <pre><code>name = observable(\"Alice\")\n\nname.set(\"Bob\")\nprint(name.value)  # \"Bob\"\n\nname.set(\"Charlie\")\nprint(name.value)  # \"Charlie\"\n</code></pre> <p>Each call to <code>.set()</code> does two things:</p> <ol> <li>Updates the internal value</li> <li>Notifies all subscribers that the value changed</li> </ol> <p>This notification is what makes observables reactive. Without it, they'd just be awkward wrappers around regular values.</p>"},{"location":"generation/markdown/observables/#subscribing-to-changes","title":"Subscribing to Changes","text":"<p>The real power of observables emerges when you subscribe to them. A subscription is a function that runs whenever the observable changes:</p> <pre><code>name = observable(\"Alice\")\n\ndef greet(new_name):\n    print(f\"Hello, {new_name}!\")\n\n# Subscribe to changes\nname.subscribe(greet)\n\n# Now changes trigger the subscriber\nname.set(\"Bob\")      # Prints: \"Hello, Bob!\"\nname.set(\"Charlie\")  # Prints: \"Hello, Charlie!\"\n</code></pre> <p>Your subscriber function receives the new value as its argument. The function runs immediately when you call <code>.set()</code>, after the value updates but before <code>.set()</code> returns.</p> <p>You can subscribe multiple functions to the same observable:</p> <pre><code>counter = observable(0)\n\ncounter.subscribe(lambda n: print(f\"Count: {n}\"))\ncounter.subscribe(lambda n: print(f\"Double: {n * 2}\"))\ncounter.subscribe(lambda n: print(f\"Square: {n ** 2}\"))\n\ncounter.set(5)\n# Output:\n# Count: 5\n# Double: 10\n# Square: 25\n</code></pre> <p>All subscribers receive the same value, and they run in the order you subscribed them.</p>"},{"location":"generation/markdown/observables/#unsubscribing","title":"Unsubscribing","text":"<p>When you no longer need to listen to an observable, unsubscribe to prevent memory leaks:</p> <pre><code>def logger(value):\n    print(f\"Value: {value}\")\n\ncounter = observable(0)\ncounter.subscribe(logger)\n\ncounter.set(1)  # Prints: \"Value: 1\"\n\n# Unsubscribe when done\ncounter.unsubscribe(logger)\n\ncounter.set(2)  # No output - logger no longer subscribed\n</code></pre> <p>You must pass the exact same function reference to <code>unsubscribe()</code> that you passed to <code>subscribe()</code>. This is why lambda functions can be tricky\u2014you can't easily unsubscribe them later. For cleanup-critical code, use named functions.</p>"},{"location":"generation/markdown/observables/#observables-vs-regular-variables","title":"Observables vs. Regular Variables","text":"<p>Let's make the difference concrete. Here's state management without observables:</p> <pre><code># Traditional approach\nclass ShoppingCart:\n    def __init__(self):\n        self.items = []\n        self.total = 0\n\n    def add_item(self, item):\n        self.items.append(item)\n        self.total = sum(item['price'] for item in self.items)\n        self.update_ui()  # Manual synchronization\n        self.save_to_storage()  # Manual synchronization\n        self.notify_analytics()  # Manual synchronization\n</code></pre> <p>Every time you modify state, you must remember to update everything that depends on it. Miss one call and your application falls out of sync.</p> <p>Here's the same thing with observables:</p> <pre><code># Reactive approach\nitems = observable([])\ntotal = items &gt;&gt; (lambda item_list: sum(item['price'] for item in item_list))\n\nitems.subscribe(update_ui)\nitems.subscribe(save_to_storage)\nitems.subscribe(notify_analytics)\n\n# Now just update the observable\nitems.set(items.value + [{'name': 'Widget', 'price': 10}])\n# All three functions run automatically\n# total recalculates automatically\n</code></pre> <p>You declare the relationships once. Changes propagate automatically. There's no way to forget a synchronization step because there are no synchronization steps\u2014just state changes.</p>"},{"location":"generation/markdown/observables/#what-observables-enable","title":"What Observables Enable","text":"<p>Observables are containers, but they're programmable containers. They carry their dependencies with them. When you build reactive systems, you're constructing graphs where nodes (observables) automatically update when their upstream dependencies change.</p> <p>Consider a simple example:</p> <pre><code>base_price = observable(100)\nquantity = observable(2)\n\n# This creates a computed observable (we'll explore these deeply in the next section)\ntotal = (base_price | quantity) &gt;&gt; (lambda price, qty: price * qty)\n\ntotal.subscribe(lambda t: print(f\"Total: ${t}\"))\n\nbase_price.set(150)  # Prints: \"Total: $300\"\nquantity.set(3)      # Prints: \"Total: $450\"\n</code></pre> <p>Notice what didn't happen: you never manually recalculated <code>total</code>. You never explicitly called the subscriber. The reactive graph did all that work for you. You just changed the base values and watched the effects cascade.</p> <p>This is what observables enable: declarative state management. You describe what relationships should exist, and FynX ensures they hold.</p>"},{"location":"generation/markdown/observables/#when-to-use-observables","title":"When to Use Observables","text":"<p>Observables shine in situations where:</p> <ul> <li>Multiple things depend on the same state \u2014 One change needs to update several downstream systems</li> <li>State changes frequently \u2014 User interactions, real-time data, animated values</li> <li>Dependencies are complex \u2014 Value A depends on B and C, which depend on D and E</li> <li>You want to avoid manual synchronization \u2014 Eliminating update code reduces bugs</li> </ul> <p>Observables add overhead compared to plain variables. For simple scripts or one-off calculations, that overhead isn't worth it. But for interactive applications, data pipelines, or anything with non-trivial state management, observables pay for themselves quickly.</p>"},{"location":"generation/markdown/observables/#when-to-use-value-and-when-not-to","title":"When to Use .value (and When Not To)","text":"<p>Understanding when to access <code>.value</code> versus passing the observable itself is crucial for writing effective reactive code.</p> <p>Use <code>.value</code> when you need the actual data:</p> <pre><code>name = observable(\"Alice\")\nage = observable(30)\n\n# Reading for immediate use\nprint(f\"Current user: {name.value}, age {age.value}\")\n\n# Passing to non-reactive functions\nresult = some_function(name.value, age.value)\n\n# Conditionals based on current state\nif age.value &gt;= 18:\n    print(\"Adult user\")\n</code></pre> <p>When you access <code>.value</code>, you're saying \"I need this data right now for a calculation or decision.\" This is perfect for one-time reads, immediate computations, or interfacing with code that doesn't understand observables.</p> <p>Don't use <code>.value</code> when building reactive relationships:</p> <pre><code># Bad: Reads .value immediately, loses reactivity\ntotal = items.value.reduce(sum)  # Just a number, won't update\n\n# Good: Keeps reactivity by transforming the observable\ntotal = items &gt;&gt; (lambda item_list: sum(item_list))  # Updates when items changes\n</code></pre> <p>The moment you call <code>.value</code>, you extract the data and break the reactive chain. If you're building something that should update automatically when the source changes, work with the observable itself, not its value.</p> <p>Pass observables to reactive operators:</p> <pre><code># These operators expect observables, not values\nderived = count &gt;&gt; (lambda c: c * 2)           # Pass count, not count.value\nmerged = first_name | last_name                # Pass observables, not .value\nfiltered = items &amp; is_valid                    # Pass observables, not .value\n</code></pre> <p>The operators (<code>&gt;&gt;</code>, <code>|</code>, <code>&amp;</code>, <code>~</code>) are designed to work with observables and maintain reactivity. When you pass <code>.value</code> to them, you're passing a static snapshot instead of a reactive stream.</p> <p>Inside subscribers and reactive functions, <code>.value</code> is fine:</p> <pre><code>counter = observable(0)\n\n# The function receives the value directly as an argument\ncounter.subscribe(lambda count: print(f\"Count: {count}\"))\n\n# But if you need to read OTHER observables inside, use .value\ncounter.subscribe(lambda count: print(f\"Double count: {count}, Age: {age.value}\"))\n</code></pre> <p>When your function is already being called reactively (through a subscription or decorator), using <code>.value</code> inside it to read other observables is perfectly appropriate. You're already in a reactive context.</p> <p>Rule of thumb: If you want something to update automatically when the observable changes, don't use <code>.value</code>. If you just need to read the current value for immediate use, <code>.value</code> is correct.</p>"},{"location":"generation/markdown/observables/#observable-limitations","title":"Observable Limitations","text":"<p>Observables aren't magic. They have constraints:</p> <p>Observables don't automatically detect changes to their contents:</p> <pre><code>items = observable([1, 2, 3])\n\n# This does NOT trigger subscribers\nitems.value.append(4)\n\n# You must explicitly call .set()\nitems.set(items.value + [4])  # This DOES trigger subscribers\n</code></pre> <p>FynX can't detect mutations to the objects inside observables. When you modify a list, dictionary, or custom object in place, subscribers won't know. You must call <code>.set()</code> with the updated value\u2014even if it's the same object reference\u2014to trigger reactivity.</p> <p>Observables don't track external state:</p> <pre><code>external_count = 0\n\ncounter = observable(0)\n\n# This subscriber depends on external_count, but FynX doesn't know that\ncounter.subscribe(lambda c: print(f\"Sum: {c + external_count}\"))\n\nexternal_count = 10\ncounter.set(5)  # Prints: \"Sum: 15\" (uses current external_count)\n</code></pre> <p>If your subscriber depends on variables outside the observable, FynX won't track those dependencies. Changes to external state won't trigger re-subscription. Keep all reactive state inside observables for predictable behavior.</p>"},{"location":"generation/markdown/observables/#whats-next","title":"What's Next","text":"<p>You now understand the basic observable: a value that notifies subscribers when it changes. But standalone observables with manual subscriptions are just the beginning. In the next sections, you'll learn how to:</p> <ul> <li>Transform observables using the <code>&gt;&gt;</code> operator to create derived values</li> <li>Combine observables using the <code>|</code> operator to work with multiple sources</li> <li>Filter observables using the <code>&amp;</code> operator to apply conditional logic</li> <li>Organize observables into Stores for cleaner application architecture</li> <li>Automate reactions with decorators that eliminate subscription boilerplate</li> </ul> <p>Each of these builds on the foundation you've just learned. Observables are simple, but their composition creates sophisticated reactive systems.</p> <p>The key insight to carry forward: observables aren't just containers\u2014they're nodes in a reactive graph. When you change one node, effects ripple through the entire structure automatically. That's the power FynX gives you.</p>"},{"location":"generation/markdown/reactive-decorator/","title":"@reactive Decorator","text":"<p>Decorator for creating reactive functions that run when observables change.</p>"},{"location":"generation/markdown/reactive-decorator/#fynx.reactive--fynx-reactive-reactive-decorators-and-utilities","title":"FynX Reactive - Reactive Decorators and Utilities","text":"<p>This module provides decorators and utilities for creating reactive relationships between observables and functions. Reactive decorators enable automatic execution of functions when their observable dependencies change, perfect for side effects like UI updates, API calls, logging, and other imperative operations.</p>"},{"location":"generation/markdown/reactive-decorator/#fynx.reactive--what-are-reactive-functions","title":"What are Reactive Functions?","text":"<p>Reactive functions are functions that automatically re-run whenever the observables they depend on change. Unlike computed values (which are declarative and return derived data), reactive functions are imperative and perform side effects.</p> <p>Reactive functions are ideal for: - UI Updates: Automatically updating displays when data changes - API Calls: Triggering network requests when relevant data changes - Logging: Recording changes for debugging or analytics - Side Effects: Any imperative operation that should respond to data changes - Synchronization: Keeping external systems in sync with reactive state</p>"},{"location":"generation/markdown/reactive-decorator/#fynx.reactive--key-characteristics","title":"Key Characteristics","text":"<ul> <li>Automatic Execution: Functions run whenever dependencies change</li> <li>Imperative: Designed for side effects, not data transformation</li> <li>Dependency Tracking: Framework automatically tracks accessed observables</li> <li>Unsubscription: Easy cleanup when reactive functions are no longer needed</li> <li>Multiple Targets: Can react to multiple observables or entire stores</li> </ul>"},{"location":"generation/markdown/reactive-decorator/#fynx.reactive--basic-usage","title":"Basic Usage","text":"<pre><code>```python\nfrom fynx import Store, observable, reactive\n</code></pre> <p>class CounterStore(Store):     count = observable(0)     name = observable(\"Counter\")</p> <p>@reactive(CounterStore.count, CounterStore.name) def log_counter_changes(count, name):     print(f\"Counter '{name}' changed to: {count}\")</p>"},{"location":"generation/markdown/reactive-decorator/#fynx.reactive--changes-trigger-the-reactive-function-automatically","title":"Changes trigger the reactive function automatically","text":"<p>CounterStore.count = 5   # Prints: \"Counter 'Counter' changed to: 5\" CounterStore.name = \"My Counter\"  # Prints: \"Counter 'My Counter' changed to: 5\" CounterStore.count = 10  # Prints: \"Counter 'My Counter' changed to: 10\" <pre><code>Advanced Patterns\n-----------------\n\n### Store-Level Reactions\n\nReact to any change in an entire store:\n\n```python\n    class UserStore(Store):\n        name = observable(\"Alice\")\n        age = observable(30)\n    email = observable(\"alice@example.com\")\n\n@reactive(UserStore)  # Reacts to any change in UserStore\ndef on_any_user_change():\n    snapshot = UserStore.to_dict()\n    print(f\"User data changed: {snapshot}\")\n\nUserStore.name = \"Bob\"   # Triggers: User data changed: {'name': 'Bob', 'age': 30, 'email': 'alice@example.com'}\nUserStore.age = 31       # Triggers again with updated data\n</code></pre></p>"},{"location":"generation/markdown/reactive-decorator/#fynx.reactive--mixed-observable-types","title":"Mixed Observable Types","text":"<p>Combine store-level and individual observable reactions:</p> <pre><code># React to store changes and a specific external observable\nis_online = observable(True)\n\n@reactive(UserStore, is_online)\ndef on_user_or_online_change():\n    user_data = UserStore.to_dict()\n    online_status = \"online\" if is_online.value else \"offline\"\n    print(f\"User {user_data['name']} is {online_status}\")\n\nUserStore.name = \"Charlie\"  # Triggers with current online status\nis_online.set(False)       # Triggers with current user data\n</code></pre>"},{"location":"generation/markdown/reactive-decorator/#fynx.reactive--cleanup-and-unsubscription","title":"Cleanup and Unsubscription","text":"<p>Reactive functions can be unsubscribed when no longer needed:</p> <pre><code># The reactive decorator returns the original function\n# so you can unsubscribe later if needed\nunsubscribe_func = reactive(CounterStore.count)(log_changes)\n# Later...\n# CounterStore.count.unsubscribe(log_changes)  # Unsubscribe specific function\n</code></pre>"},{"location":"generation/markdown/reactive-decorator/#fynx.reactive--real-world-examples","title":"Real-World Examples","text":""},{"location":"generation/markdown/reactive-decorator/#fynx.reactive--ui-update-simulation","title":"UI Update Simulation","text":"<pre><code>class ViewModel(Store):\n    search_query = observable(\"\")\n    results = observable([])\n    is_loading = observable(False)\n\n@reactive(ViewModel.search_query)\ndef update_search_results(query):\n    if query:\n        ViewModel.is_loading = True\n        # Simulate API call\n        ViewModel.results = [f\"Result for '{query}'\"]\n        ViewModel.is_loading = False\n    else:\n        ViewModel.results = []\n\n@reactive(ViewModel.results, ViewModel.is_loading)\ndef update_ui(results, loading):\n    if loading:\n        print(\"\ud83d\udd04 Loading...\")\n    else:\n        print(f\"\ud83d\udccb Found {len(results)} results: {results}\")\n\nViewModel.search_query = \"python\"  # Triggers both functions\n</code></pre>"},{"location":"generation/markdown/reactive-decorator/#fynx.reactive--form-validation","title":"Form Validation","text":"<pre><code>class FormStore(Store):\n    email = observable(\"\")\n    password = observable(\"\")\n    is_submitting = observable(False)\n\n@reactive(FormStore.email)\ndef validate_email(email):\n    is_valid = \"@\" in email and len(email) &gt; 5\n    print(f\"Email valid: {is_valid}\")\n\n@reactive(FormStore.password)\ndef validate_password(password):\n    is_strong = len(password) &gt;= 8\n    print(f\"Password strong: {is_strong}\")\n\nFormStore.email = \"user@\"       # Email valid: False\nFormStore.email = \"user@example.com\"  # Email valid: True\nFormStore.password = \"123\"      # Password strong: False\nFormStore.password = \"secure123\" # Password strong: True\n</code></pre>"},{"location":"generation/markdown/reactive-decorator/#fynx.reactive--analytics-tracking","title":"Analytics Tracking","text":"<pre><code>class AnalyticsStore(Store):\n    page_views = observable(0)\n    unique_visitors = observable(0)\n    current_page = observable(\"home\")\n\n@reactive(AnalyticsStore.page_views)\ndef track_page_views(views):\n    print(f\"\ud83d\udcca Analytics: {views} page views\")\n\n@reactive(AnalyticsStore.current_page)\ndef track_page_changes(page):\n    print(f\"\ud83d\udccd User navigated to: {page}\")\n\nAnalyticsStore.page_views = 150\nAnalyticsStore.current_page = \"products\"\nAnalyticsStore.page_views = 151  # Both functions trigger\n</code></pre>"},{"location":"generation/markdown/reactive-decorator/#fynx.reactive--performance-considerations","title":"Performance Considerations","text":"<p>Reactive functions include several performance optimizations:</p> <p>Efficient Tracking: Only tracks observables actually accessed during function execution</p> <p>Batch Updates: Multiple observable changes in quick succession trigger the function only once</p> <p>Memory Management: Automatic cleanup when reactive contexts are no longer needed</p> <p>Selective Execution: Functions only run when their specific dependencies change</p>"},{"location":"generation/markdown/reactive-decorator/#fynx.reactive--best-practices","title":"Best Practices","text":""},{"location":"generation/markdown/reactive-decorator/#fynx.reactive--keep-functions-focused","title":"Keep Functions Focused","text":"<p>Each reactive function should have a single, clear responsibility:</p> <pre><code># Good: Focused responsibilities\n@reactive(user_data)\ndef update_profile_ui(user_data):\n    # Only handles UI updates\n    pass\n\n@reactive(user_data)\ndef sync_to_server(user_data):\n    # Only handles server sync\n    pass\n\n# Avoid: Mixed responsibilities\n@reactive(user_data)\ndef handle_user_change(user_data):\n    # Updates UI, syncs to server, logs analytics...\n    pass\n</code></pre>"},{"location":"generation/markdown/reactive-decorator/#fynx.reactive--handle-errors-gracefully","title":"Handle Errors Gracefully","text":"<p>Reactive functions should handle exceptions to prevent breaking the reactive system:</p> <pre><code>@reactive(data)\ndef process_data_safely(data):\n    try:\n        # Process data...\n        result = expensive_operation(data)\n        update_ui(result)\n    except Exception as e:\n        print(f\"Error processing data: {e}\")\n        show_error_message()\n</code></pre>"},{"location":"generation/markdown/reactive-decorator/#fynx.reactive--use-appropriate-granularity","title":"Use Appropriate Granularity","text":"<p>Choose the right level of reactivity for your use case:</p> <pre><code># Fine-grained: React to specific changes\n@reactive(store.specific_field)\ndef handle_specific_change(value):\n    pass\n\n# Coarse-grained: React to any store change\n@reactive(store)\ndef handle_any_change():\n    pass\n</code></pre>"},{"location":"generation/markdown/reactive-decorator/#fynx.reactive--common-patterns","title":"Common Patterns","text":"<p>Event Logging: <pre><code>@reactive(store)\ndef log_all_changes():\n    print(f\"State changed at {datetime.now()}: {store.to_dict()}\")\n</code></pre></p> <p>Cache Invalidation: <pre><code>cache = {}\n@reactive(data_version)\ndef invalidate_cache(version):\n    cache.clear()\n    print(f\"Cache invalidated for version {version}\")\n</code></pre></p> <p>External System Sync: <pre><code>@reactive(local_data)\ndef sync_to_external_system(data):\n    external_api.update(data)\n    print(\"Synced to external system\")\n</code></pre></p>"},{"location":"generation/markdown/reactive-decorator/#fynx.reactive--limitations","title":"Limitations","text":"<ul> <li>Reactive functions cannot return values (use computed for that)</li> <li>Dependencies must be accessed synchronously during execution</li> <li>Functions execute for every dependency change (no debouncing built-in)</li> <li>Cannot create circular dependencies with observables</li> </ul>"},{"location":"generation/markdown/reactive-decorator/#fynx.reactive--troubleshooting","title":"Troubleshooting","text":"<p>Function not triggering: Ensure all accessed observables are passed as arguments to @reactive</p> <pre><code># Wrong: external_obs not declared as dependency\nexternal_obs = observable(10)\n@reactive(some_obs)\ndef wrong_func():\n    value = external_obs.value  # Not tracked!\n\n# Right: Declare all dependencies\n@reactive(some_obs, external_obs)\ndef right_func(some_val, external_val):\n    pass\n</code></pre> <p>Too many executions: Consider using @watch for conditional execution instead</p> <p>Performance issues: Break large reactive functions into smaller, focused ones</p>"},{"location":"generation/markdown/reactive-decorator/#fynx.reactive--comparison-with-other-approaches","title":"Comparison with Other Approaches","text":"<p>vs Manual Subscriptions: <pre><code># Manual (error-prone)\ndef setup():\n    obs.subscribe(callback)\n    obs2.subscribe(callback)\n    # Must manually unsubscribe later...\n\n# Reactive (declarative)\n@reactive(obs, obs2)\ndef callback():\n    pass  # Automatically managed\n</code></pre></p> <p>vs Computed Values: - Use @reactive for side effects (UI updates, API calls) - Use @computed for derived data (calculations, transformations)</p> <p>vs Watch Decorators: - Use @reactive for unconditional reactions to changes - Use @watch for conditional execution (only when conditions met)</p>"},{"location":"generation/markdown/reactive-decorator/#fynx.reactive--see-also","title":"See Also","text":"<ul> <li><code>fynx.watch</code>: Conditional reactive functions</li> <li><code>fynx.computed</code>: Derived reactive values</li> <li><code>fynx.store</code>: Reactive state containers</li> <li><code>fynx.observable</code>: Core observable classes</li> </ul>"},{"location":"generation/markdown/reactive-decorator/#fynx.reactive.ReactiveHandler","title":"ReactiveHandler","text":"<pre><code>ReactiveHandler(*targets)\n</code></pre> <p>Manages reactive function subscriptions and handles different target types.</p> <p>ReactiveHandler is the core implementation behind the <code>@reactive</code> decorator. It intelligently handles different types of targets (Store classes, individual observables) and creates the appropriate subscription mechanism.</p> <p>The handler supports: - Store class subscriptions (reacts to any change in the store) - Individual observable subscriptions (reacts to specific observables) - Mixed subscriptions (combination of stores and observables)</p> <p>This class is typically used indirectly through the <code>@reactive</code> decorator rather than instantiated directly.</p> Example <pre><code># These all use ReactiveHandler internally:\n@reactive(store_instance)      # Store subscription\n@reactive(obs1, obs2)          # Multiple observables\n@reactive(store_class.attr)    # Single observable\n</code></pre> <p>Initialize the reactive handler with target observables/stores.</p> <p>Parameters:</p> Name Type Description Default <code>*targets</code> <p>Variable number of observables, stores, or store attributes      to monitor for changes.</p> <code>()</code>"},{"location":"generation/markdown/reactive-decorator/#fynx.reactive.ReactiveHandler.__call__","title":"__call__","text":"<pre><code>__call__(func)\n</code></pre> <p>Decorator implementation that makes the function reactive.</p> <p>This method is called when the ReactiveHandler is used as a decorator. It sets up the reactive context for the decorated function and returns the original function (decorators typically return the same function).</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable</code> <p>The function to make reactive</p> required <p>Returns:</p> Type Description <code>Callable</code> <p>The original function, now configured to react to target changes</p> Example <pre><code>@reactive(store.count, store.name)\ndef update_display(count, name):\n    print(f\"Count: {count}, Name: {name}\")\n\n# This is equivalent to:\n# reactive_handler = ReactiveHandler(store.count, store.name)\n# update_display = reactive_handler(update_display)\n</code></pre>"},{"location":"generation/markdown/reactive-decorator/#fynx.reactive.reactive","title":"reactive","text":"<pre><code>reactive(*targets)\n</code></pre> <p>Create a reactive handler that works as a decorator.</p> <p>This is a convenience wrapper around subscribe() that works as a decorator.</p> As decorator <p>@reactive(store) - reacts to all observables in store @reactive(observable) - reacts to single observable @reactive(obs1, obs2, ...) - reacts to multiple observables</p> <p>Parameters:</p> Name Type Description Default <code>*targets</code> <p>Store class, Observable instance(s), or multiple Observable instances</p> <code>()</code> <p>Returns:</p> Type Description <p>ReactiveHandler that can be used as decorator</p>"},{"location":"generation/markdown/store/","title":"Store Class &amp; @observable Decorator","text":"<p>Container class for grouping observables and the decorator for making class attributes reactive.</p>"},{"location":"generation/markdown/store/#fynx.store--fynx-store-reactive-state-management-components","title":"FynX Store - Reactive State Management Components","text":"<p>This module provides the core components for reactive state management in FynX, enabling you to create organized, reactive state containers that group related observables together with convenient subscription and state management methods.</p>"},{"location":"generation/markdown/store/#fynx.store--why-use-stores","title":"Why Use Stores?","text":"<p>Stores help you organize your application's reactive state into logical units. Instead of having observables scattered throughout your codebase, Stores group related data together and provide convenient methods for subscribing to changes, serializing state, and managing the reactive lifecycle.</p> <p>Stores are particularly useful for: - Application State: Global app state like user preferences, theme settings - Feature State: State for specific features like shopping cart, user profile - Component State: Local state that needs to be shared across multiple components - Business Logic: Computed values and derived state based on raw data</p>"},{"location":"generation/markdown/store/#fynx.store--core-components","title":"Core Components","text":"<p>Store: A base class for creating reactive state containers. Store classes can define observable attributes using the <code>observable()</code> descriptor, and automatically provide methods for subscribing to changes and managing state.</p> <p>observable: A descriptor function that creates observable attributes on Store classes. Use this to define reactive properties in your Store subclasses.</p> <p>StoreSnapshot: An immutable snapshot of store state at a specific point in time, useful for debugging, logging, and ensuring consistent state access.</p> <p>StoreMeta: A metaclass that automatically converts observable attributes to descriptors and provides type hint compatibility for mypy.</p>"},{"location":"generation/markdown/store/#fynx.store--key-features","title":"Key Features","text":"<ul> <li>Automatic Observable Management: Store metaclass handles observable creation</li> <li>Convenient Subscriptions: Subscribe to all changes or individual observables</li> <li>State Serialization: Save and restore store state with <code>to_dict()</code> and <code>load_state()</code></li> <li>Type Safety: Full type hint support for better IDE experience</li> <li>Memory Efficient: Automatic cleanup and efficient change detection</li> <li>Composable: Easy to combine and nest multiple stores</li> </ul>"},{"location":"generation/markdown/store/#fynx.store--basic-usage","title":"Basic Usage","text":"<pre><code>from fynx import Store, observable\n\nclass CounterStore(Store):\n    count = observable(0)\n    name = observable(\"My Counter\")\n\n# Access values like regular attributes\nprint(CounterStore.count)  # 0\nCounterStore.count = 5     # Updates the observable\n\n# Subscribe to all changes in the store\n@CounterStore.subscribe\ndef on_store_change(snapshot):\n    print(f\"Store changed: count={snapshot.count}, name={snapshot.name}\")\n\nCounterStore.count = 10  # Triggers: \"Store changed: count=10, name=My Counter\"\n</code></pre>"},{"location":"generation/markdown/store/#fynx.store--advanced-patterns","title":"Advanced Patterns","text":""},{"location":"generation/markdown/store/#fynx.store--computed-properties-in-stores","title":"Computed Properties in Stores","text":"<pre><code>from fynx import Store, observable\n\nclass UserStore(Store):\n    first_name = observable(\"John\")\n    last_name = observable(\"Doe\")\n    age = observable(30)\n\n    # Computed properties using the &gt;&gt; operator\n    full_name = (first_name | last_name) &gt;&gt; (\n        lambda fname, lname: f\"{fname} {lname}\"\n    )\n\n    is_adult = age &gt;&gt; (lambda a: a &gt;= 18)\n\nprint(UserStore.full_name)  # \"John Doe\"\nUserStore.first_name = \"Jane\"\nprint(UserStore.full_name)  # \"Jane Doe\" (automatically updated)\n</code></pre>"},{"location":"generation/markdown/store/#fynx.store--state-persistence","title":"State Persistence","text":"<pre><code># Save store state\nstate = CounterStore.to_dict()\n# state = {\"count\": 10, \"name\": \"My Counter\"}\n\n# Restore state later\nCounterStore.load_state(state)\nprint(CounterStore.count)  # 10\n</code></pre>"},{"location":"generation/markdown/store/#fynx.store--store-composition","title":"Store Composition","text":"<pre><code>class AppStore(Store):\n    theme = observable(\"light\")\n    language = observable(\"en\")\n\nclass UserStore(Store):\n    name = observable(\"Alice\")\n    preferences = observable({})\n\n# Use both stores independently\nAppStore.theme = \"dark\"\nUserStore.name = \"Bob\"\n</code></pre>"},{"location":"generation/markdown/store/#fynx.store--store-lifecycle","title":"Store Lifecycle","text":"<p>Stores automatically manage the lifecycle of their observables:</p> <ol> <li> <p>Creation: When you define a Store subclass, the metaclass automatically    converts <code>observable()</code> calls into reactive descriptors.</p> </li> <li> <p>Access: When you access store attributes, you get transparent reactive values    that behave like regular Python attributes.</p> </li> <li> <p>Updates: When you assign to store attributes, the underlying observables are    updated and all dependent computations and reactions are notified.</p> </li> <li> <p>Cleanup: Reactive contexts are automatically cleaned up when no longer needed.</p> </li> </ol>"},{"location":"generation/markdown/store/#fynx.store--performance-considerations","title":"Performance Considerations","text":"<ul> <li>Efficient Updates: Only notifies subscribers when values actually change</li> <li>Lazy Evaluation: Computed properties only recalculate when accessed</li> <li>Memory Management: Automatic cleanup of unused reactive contexts</li> <li>Batch Updates: Multiple changes in quick succession are efficiently handled</li> </ul>"},{"location":"generation/markdown/store/#fynx.store--best-practices","title":"Best Practices","text":"<ul> <li>Group Related State: Keep related observables together in the same store</li> <li>Use Descriptive Names: Name your stores and observables clearly</li> <li>Avoid Large Stores: Split very large stores into smaller, focused ones</li> <li>Use Computed for Derived State: Don't store derived values manually</li> <li>Handle Errors: Reactive functions should handle exceptions gracefully</li> <li>Document Store Purpose: Use docstrings to explain what each store manages</li> </ul>"},{"location":"generation/markdown/store/#fynx.store--common-patterns","title":"Common Patterns","text":"<p>Singleton Stores: Use class-level access for global state:</p> <pre><code>class GlobalStore(Store):\n    is_loading = observable(False)\n    current_user = observable(None)\n\n# Access globally\nGlobalStore.is_loading = True\n</code></pre> <p>Instance Stores: Create store instances for per-component state:</p> <pre><code>class TodoStore(Store):\n    items = observable([])\n    filter = observable(\"all\")\n\nstore = TodoStore()  # Instance with its own state\n</code></pre> <p>Store Communication: Stores can reference each other:</p> <pre><code>class AuthStore(Store):\n    is_logged_in = observable(False)\n    user_id = observable(None)\n\nclass DataStore(Store):\n    @computed\n    def can_fetch_data(self):\n        return AuthStore.is_logged_in\n</code></pre>"},{"location":"generation/markdown/store/#fynx.store--migration-from-plain-observables","title":"Migration from Plain Observables","text":"<p>If you're using plain observables and want to migrate to Stores:</p> <pre><code># Before: Plain observables\nuser_name = observable(\"Alice\")\nuser_age = observable(30)\n\n# After: Store-based\nclass UserStore(Store):\n    name = observable(\"Alice\")\n    age = observable(30)\n\n# Access remains similar\nUserStore.name = \"Bob\"  # Instead of user_name.set(\"Bob\")\n</code></pre>"},{"location":"generation/markdown/store/#fynx.store--error-handling","title":"Error Handling","text":"<p>Stores handle errors gracefully:</p> <ul> <li>Observable updates that fail don't break the reactive system</li> <li>Computed property errors are logged but don't prevent other updates</li> <li>Store serialization handles missing or invalid data</li> </ul>"},{"location":"generation/markdown/store/#fynx.store--debugging","title":"Debugging","text":"<p>Use StoreSnapshot for debugging:</p> <pre><code># Capture current state\nsnapshot = StoreSnapshot(CounterStore, CounterStore._get_observable_attrs())\nprint(snapshot)  # Shows all observable values\n\n# Compare states\nold_snapshot = snapshot\n# ... do some operations ...\nnew_snapshot = StoreSnapshot(CounterStore, CounterStore._get_observable_attrs())\n# Compare old_snapshot and new_snapshot\n</code></pre>"},{"location":"generation/markdown/store/#fynx.store--see-also","title":"See Also","text":"<ul> <li><code>fynx.observable</code>: Core observable classes and operators</li> <li><code>fynx.computed</code>: Creating computed properties</li> <li><code>fynx.reactive</code>: Reactive decorators for side effects</li> <li><code>fynx.watch</code>: Conditional reactive functions</li> </ul>"},{"location":"generation/markdown/store/#fynx.store.Store","title":"Store","text":"<p>Base class for reactive state containers with observable attributes.</p> <p>Store provides a convenient way to group related observable values together and manage their lifecycle as a cohesive unit. Store subclasses can define observable attributes using the <code>observable()</code> descriptor, and Store provides methods for subscribing to changes, serializing state, and managing the reactive relationships.</p> <p>Key Features: - Automatic observable attribute detection and management - Convenient subscription methods for reacting to state changes - Serialization/deserialization support for persistence - Snapshot functionality for debugging and state inspection</p> Example <pre><code>from fynx import Store, observable\n\nclass CounterStore(Store):\n    count = observable(0)\n    name = observable(\"Counter\")\n\n# Subscribe to all changes\n@CounterStore.subscribe\ndef on_change(snapshot):\n    print(f\"Counter: {snapshot.count}, Name: {snapshot.name}\")\n\n# Changes trigger reactions\nCounterStore.count = 5  # Prints: Counter: 5, Name: Counter\nCounterStore.name = \"My Counter\"  # Prints: Counter: 5, Name: My Counter\n</code></pre> Note <p>Store uses a metaclass to intercept attribute assignment, allowing <code>Store.attr = value</code> syntax to work seamlessly with observables.</p>"},{"location":"generation/markdown/store/#fynx.store.Store.load_state","title":"load_state","text":"<pre><code>load_state(state_dict)\n</code></pre> <p>Load state from a dictionary into the store's observables.</p>"},{"location":"generation/markdown/store/#fynx.store.Store.subscribe","title":"subscribe","text":"<pre><code>subscribe(func)\n</code></pre> <p>Subscribe a function to react to all observable changes.</p>"},{"location":"generation/markdown/store/#fynx.store.Store.to_dict","title":"to_dict","text":"<pre><code>to_dict()\n</code></pre> <p>Serialize all observable values to a dictionary.</p>"},{"location":"generation/markdown/store/#fynx.store.Store.unsubscribe","title":"unsubscribe","text":"<pre><code>unsubscribe(func)\n</code></pre> <p>Unsubscribe a function from all observables.</p>"},{"location":"generation/markdown/store/#fynx.store.StoreMeta","title":"StoreMeta","text":"<p>Metaclass for Store to automatically convert observable attributes to descriptors and adjust type hints for mypy compatibility.</p>"},{"location":"generation/markdown/store/#fynx.store.StoreMeta.__setattr__","title":"__setattr__","text":"<pre><code>__setattr__(name, value)\n</code></pre> <p>Intercept class attribute assignment for observables.</p>"},{"location":"generation/markdown/store/#fynx.store.StoreSnapshot","title":"StoreSnapshot","text":"<pre><code>StoreSnapshot(store_class, observable_attrs)\n</code></pre> <p>Immutable snapshot of store observable values at a specific point in time.</p>"},{"location":"generation/markdown/store/#fynx.store.StoreSnapshot.__getattr__","title":"__getattr__","text":"<pre><code>__getattr__(name)\n</code></pre> <p>Access snapshot values or fall back to class attributes.</p>"},{"location":"generation/markdown/store/#fynx.store.observable","title":"observable","text":"<pre><code>observable(initial_value=None)\n</code></pre> <p>Create an observable with an initial value, used as a descriptor in Store classes.</p>"},{"location":"generation/markdown/stores/","title":"Stores: Organizing Reactive State","text":"<p>You've learned how observables work\u2014they hold values, notify subscribers, and form the foundation of reactivity. But as your application grows, managing dozens of scattered observables becomes unwieldy. Where do related observables live? How do you organize state modifications? How do you test different parts of your state in isolation?</p> <p>Stores solve these problems by giving structure to your reactive state.</p>"},{"location":"generation/markdown/stores/#what-is-a-store","title":"What is a Store?","text":"<p>A Store is a class that groups related observables together. That's the essence. Everything else\u2014the computed properties, the methods, the reactive behaviors\u2014builds on this simple organizational principle.</p> <p>Think of a Store as a namespace for related state. If you're building a shopping cart, all the cart-related observables live in <code>CartStore</code>. If you're managing user authentication, all auth state lives in <code>AuthStore</code>. Each Store becomes a clear, testable boundary in your application.</p> <p>Here's the simplest possible Store:</p> <pre><code>from fynx import Store, observable\n\nclass CounterStore(Store):\n    count = observable(0)\n</code></pre> <p>That's it. You've created a Store with one reactive attribute. The magic is in what this gives you:</p> <pre><code># Read the value\ncurrent = CounterStore.count\n\n# Write the value\nCounterStore.count = 5\n\n# The value is an observable under the hood\nCounterStore.count.subscribe(lambda c: print(f\"Count: {c}\"))\n\nCounterStore.count = 10  # Prints: \"Count: 10\"\n</code></pre> <p>Notice the asymmetry: you read with direct access (<code>CounterStore.count</code>), but the value is still an observable. You can still subscribe to it, transform it with <code>&gt;&gt;</code>, merge it with <code>|</code>. The Store class uses Python descriptors to give you clean syntax while preserving all of observable's power.</p>"},{"location":"generation/markdown/stores/#why-stores-matter","title":"Why Stores Matter","text":"<p>Before Stores, you might write code like this:</p> <pre><code># Scattered observables\nuser_first_name = observable(\"Alice\")\nuser_last_name = observable(\"Smith\")\nuser_age = observable(30)\nuser_email = observable(\"alice@example.com\")\nis_authenticated = observable(False)\n\n# Where does this logic live?\ndef update_user_profile(first, last, age, email):\n    user_first_name.set(first)\n    user_last_name.set(last)\n    user_age.set(age)\n    user_email.set(email)\n</code></pre> <p>This works, but it doesn't scale. Which observables relate to each other? Where should validation logic go? How do you reset user state? How do you test user-related functionality without affecting other parts of your application?</p> <p>With Stores:</p> <pre><code>class UserStore(Store):\n    first_name = observable(\"Alice\")\n    last_name = observable(\"Smith\")\n    age = observable(30)\n    email = observable(\"alice@example.com\")\n    is_authenticated = observable(False)\n\n    @classmethod\n    def update_profile(cls, first, last, age, email):\n        cls.first_name = first\n        cls.last_name = last\n        cls.age = age\n        cls.email = email\n\n    @classmethod\n    def logout(cls):\n        cls.is_authenticated = False\n        cls.first_name = \"\"\n        cls.last_name = \"\"\n        cls.email = \"\"\n</code></pre> <p>Now everything about users lives in one place. The boundaries are clear. Testing is straightforward. Other parts of your application import <code>UserStore</code> and interact with it through its public methods.</p>"},{"location":"generation/markdown/stores/#store-attributes-observable-descriptors","title":"Store Attributes: Observable Descriptors","text":"<p>When you write <code>count = observable(0)</code> inside a Store class, you're creating an observable descriptor. This descriptor gives you convenient syntax:</p> <pre><code>class MyStore(Store):\n    value = observable(100)\n\n# These are equivalent:\nprint(MyStore.value)         # Direct access\nprint(MyStore.value.value)   # Explicit .value access\n\n# Writing is clean:\nMyStore.value = 200           # Direct assignment\n\n# But you can still use it as an observable:\nMyStore.value.subscribe(lambda v: print(v))\ndoubled = MyStore.value &gt;&gt; (lambda v: v * 2)\n</code></pre> <p>The descriptor pattern means you don't need <code>.value</code> and <code>.set()</code> for Store attributes\u2014just read and write naturally. But the underlying observable is still there, ready for transformations and subscriptions.</p> <p>Important: This clean syntax only works for Store class attributes. Standalone observables (not in a Store) still require <code>.value</code> and <code>.set()</code>:</p> <pre><code># Standalone observable\ncounter = observable(0)\nprint(counter.value)  # Must use .value\ncounter.set(5)        # Must use .set()\n\n# Store observable\nclass CounterStore(Store):\n    counter = observable(0)\n\nprint(CounterStore.counter)  # No .value needed\nCounterStore.counter = 5     # No .set() needed\n</code></pre>"},{"location":"generation/markdown/stores/#adding-computed-values","title":"Adding Computed Values","text":"<p>The real power of Stores emerges when you add derived state using the <code>&gt;&gt;</code> operator:</p> <pre><code>class CartStore(Store):\n    items = observable([])\n    tax_rate = observable(0.08)\n\n    # Computed: recalculates when items changes\n    item_count = items &gt;&gt; (lambda items: len(items))\n\n    # Computed: recalculates when items changes\n    subtotal = items &gt;&gt; (\n        lambda items: sum(item['price'] * item['quantity'] for item in items)\n    )\n</code></pre> <p>These computed values update automatically. When you change <code>CartStore.items</code>, both <code>item_count</code> and <code>subtotal</code> recalculate. But they only recalculate when you actually access them\u2014this lazy evaluation means computed values have zero cost until you need them.</p> <pre><code>CartStore.items = [\n    {'name': 'Widget', 'price': 10, 'quantity': 2},\n    {'name': 'Gadget', 'price': 15, 'quantity': 1}\n]\n\nprint(CartStore.item_count)  # 2 (computes now)\nprint(CartStore.subtotal)    # 35.0 (computes now)\n\n# Access again without changes\nprint(CartStore.item_count)  # 2 (returns cached value)\n</code></pre> <p>Computed values memoize their results. After the first access, they return the cached value until their dependencies change.</p>"},{"location":"generation/markdown/stores/#combining-multiple-observables","title":"Combining Multiple Observables","text":"<p>Most computed values depend on more than one observable. Use the <code>|</code> operator to merge observables:</p> <pre><code>class CartStore(Store):\n    items = observable([])\n    tax_rate = observable(0.08)\n\n    subtotal = items &gt;&gt; (\n        lambda items: sum(item['price'] * item['quantity'] for item in items)\n    )\n\n    # Merge subtotal and tax_rate\n    tax_amount = (subtotal | tax_rate) &gt;&gt; (\n        lambda sub, rate: sub * rate\n    )\n\n    # Merge subtotal and tax_amount\n    total = (subtotal | tax_amount) &gt;&gt; (\n        lambda sub, tax: sub + tax\n    )\n</code></pre> <p>The <code>|</code> operator creates a merged observable that emits a tuple. When you transform it with <code>&gt;&gt;</code>, the function receives one argument per observable:</p> <pre><code>CartStore.items = [{'name': 'Widget', 'price': 20, 'quantity': 1}]\n\nprint(CartStore.subtotal)     # 20.0\nprint(CartStore.tax_amount)   # 1.6\nprint(CartStore.total)        # 21.6\n\nCartStore.tax_rate = 0.10\nprint(CartStore.tax_amount)   # 2.0 (recalculated)\nprint(CartStore.total)        # 22.0 (recalculated)\n</code></pre> <p>Any change to a merged observable triggers recomputation. This makes <code>|</code> perfect for values that need to coordinate multiple pieces of state.</p>"},{"location":"generation/markdown/stores/#methods-encapsulating-state-changes","title":"Methods: Encapsulating State Changes","text":"<p>Stores become truly useful when they encapsulate the logic for modifying their own state:</p> <pre><code>class CartStore(Store):\n    items = observable([])\n\n    @classmethod\n    def add_item(cls, name, price, quantity=1):\n        \"\"\"Add an item to the cart or update quantity if it exists.\"\"\"\n        current_items = cls.items\n\n        # Find existing item\n        existing = next((item for item in current_items if item['name'] == name), None)\n\n        if existing:\n            # Update quantity\n            cls.items = [\n                {**item, 'quantity': item['quantity'] + quantity}\n                if item['name'] == name else item\n                for item in current_items\n            ]\n        else:\n            # Add new item\n            cls.items = current_items + [{'name': name, 'price': price, 'quantity': quantity}]\n\n    @classmethod\n    def remove_item(cls, name):\n        \"\"\"Remove an item from the cart.\"\"\"\n        cls.items = [item for item in cls.items if item['name'] != name]\n\n    @classmethod\n    def clear(cls):\n        \"\"\"Remove all items.\"\"\"\n        cls.items = []\n</code></pre> <p>Now cart manipulation is clean and explicit:</p> <pre><code>CartStore.add_item('Widget', 10.0, 2)\nCartStore.add_item('Gadget', 15.0)\nprint(CartStore.item_count)  # 2\n\nCartStore.remove_item('Widget')\nprint(CartStore.item_count)  # 1\n\nCartStore.clear()\nprint(CartStore.item_count)  # 0\n</code></pre> <p>Methods define your Store's public API. Users don't manipulate observables directly\u2014they call methods that express intent. This encapsulation makes your code more maintainable and testable.</p>"},{"location":"generation/markdown/stores/#a-critical-pattern-immutable-updates","title":"A Critical Pattern: Immutable Updates","text":"<p>Notice the pattern in the methods above\u2014we never mutate values in place:</p> <pre><code># Wrong: Mutation doesn't trigger reactivity\ncls.items.append(new_item)\n\n# Right: Create new list\ncls.items = cls.items + [new_item]\n</code></pre> <p>FynX detects changes through assignment. When you mutate an observable's value in place, nothing triggers because from FynX's perspective, the reference hasn't changed. Always create new values:</p> <pre><code># Lists: Create new list\ncls.items = cls.items + [new_item]\ncls.items = [item for item in cls.items if condition]\n\n# Dicts: Create new dict\ncls.user = {**cls.user, 'name': 'New Name'}\n\n# Nested structures: Reconstruct the path\ncls.items = [\n    {**item, 'quantity': item['quantity'] + 1} if item['id'] == target_id else item\n    for item in cls.items\n]\n</code></pre> <p>This immutable update pattern is crucial. It ensures reactivity works correctly and makes your state changes predictable.</p>"},{"location":"generation/markdown/stores/#chaining-computed-values","title":"Chaining Computed Values","text":"<p>Computed values can depend on other computed values, creating transformation pipelines:</p> <pre><code>class AnalyticsStore(Store):\n    values = observable([10, 20, 30, 40, 50])\n\n    # Level 1: Basic stats\n    count = values &gt;&gt; (lambda v: len(v))\n    total = values &gt;&gt; (lambda v: sum(v))\n\n    # Level 2: Depends on count and total\n    mean = (total | count) &gt;&gt; (\n        lambda t, c: t / c if c &gt; 0 else 0\n    )\n\n    # Level 3: Depends on values and mean\n    variance = (values | mean | count) &gt;&gt; (\n        lambda vals, avg, n: (\n            sum((x - avg) ** 2 for x in vals) / (n - 1) if n &gt; 1 else 0\n        )\n    )\n\n    # Level 4: Depends on variance\n    std_dev = variance &gt;&gt; (lambda v: v ** 0.5)\n</code></pre> <p>When <code>values</code> changes, FynX propagates updates through the entire chain in the correct order. Each level recalculates only if its dependencies actually changed:</p> <pre><code>print(f\"Mean: {AnalyticsStore.mean:.2f}\")      # 30.00\nprint(f\"Std Dev: {AnalyticsStore.std_dev:.2f}\") # 15.81\n\nAnalyticsStore.values = [5, 10, 15, 20, 25]\nprint(f\"Mean: {AnalyticsStore.mean:.2f}\")      # 15.00\nprint(f\"Std Dev: {AnalyticsStore.std_dev:.2f}\") # 7.91\n</code></pre> <p>This chaining pattern lets you build complex derived state from simple transformations. Each step is testable and easy to understand.</p>"},{"location":"generation/markdown/stores/#practical-example-user-profile-store","title":"Practical Example: User Profile Store","text":"<p>Let's build a realistic Store that demonstrates all these concepts:</p> <pre><code>from fynx import Store, observable\n\nclass UserProfileStore(Store):\n    # Basic observables\n    first_name = observable(\"\")\n    last_name = observable(\"\")\n    email = observable(\"\")\n    age = observable(0)\n    is_premium = observable(False)\n\n    # Computed: full name\n    full_name = (first_name | last_name) &gt;&gt; (\n        lambda first, last: f\"{first} {last}\".strip()\n    )\n\n    # Computed: display name (falls back if no name)\n    display_name = full_name &gt;&gt; (\n        lambda name: name if name else \"Anonymous User\"\n    )\n\n    # Computed: email validation\n    is_email_valid = email &gt;&gt; (\n        lambda e: '@' in e and '.' in e.split('@')[-1] if e else False\n    )\n\n    # Computed: age validation\n    is_adult = age &gt;&gt; (lambda a: a &gt;= 18)\n\n    # Computed: profile completeness\n    is_complete = (first_name | last_name | email | is_email_valid) &gt;&gt; (\n        lambda first, last, email_addr, email_valid: \n            bool(first and last and email_addr and email_valid)\n    )\n\n    # Computed: user tier\n    user_tier = (is_premium | is_complete) &gt;&gt; (\n        lambda premium, complete: (\n            \"Premium\" if premium else\n            \"Complete\" if complete else\n            \"Basic\"\n        )\n    )\n\n    @classmethod\n    def update_name(cls, first, last):\n        \"\"\"Update the user's name.\"\"\"\n        cls.first_name = first.strip()\n        cls.last_name = last.strip()\n\n    @classmethod\n    def update_email(cls, email):\n        \"\"\"Update the user's email.\"\"\"\n        cls.email = email.strip().lower()\n\n    @classmethod\n    def set_age(cls, age):\n        \"\"\"Update the user's age.\"\"\"\n        if age &gt;= 0:\n            cls.age = age\n\n    @classmethod\n    def upgrade_to_premium(cls):\n        \"\"\"Upgrade the user to premium status.\"\"\"\n        cls.is_premium = True\n\n    @classmethod\n    def reset(cls):\n        \"\"\"Reset all profile data.\"\"\"\n        cls.first_name = \"\"\n        cls.last_name = \"\"\n        cls.email = \"\"\n        cls.age = 0\n        cls.is_premium = False\n</code></pre> <p>Usage demonstrates how everything updates automatically:</p> <pre><code># Initial state\nprint(UserProfileStore.display_name)  # \"Anonymous User\"\nprint(UserProfileStore.user_tier)     # \"Basic\"\n\n# Update name\nUserProfileStore.update_name(\"Alice\", \"Smith\")\nprint(UserProfileStore.display_name)  # \"Alice Smith\"\nprint(UserProfileStore.full_name)     # \"Alice Smith\"\n\n# Update email\nUserProfileStore.update_email(\"alice@example.com\")\nprint(UserProfileStore.is_email_valid)  # True\n\n# Set age\nUserProfileStore.set_age(25)\nprint(UserProfileStore.is_adult)      # True\nprint(UserProfileStore.is_complete)   # True\nprint(UserProfileStore.user_tier)     # \"Complete\"\n\n# Upgrade\nUserProfileStore.upgrade_to_premium()\nprint(UserProfileStore.user_tier)     # \"Premium\"\n</code></pre> <p>Every computed value updates automatically when its dependencies change. You never write synchronization code\u2014just modify observables and watch the effects cascade.</p>"},{"location":"generation/markdown/stores/#cross-store-dependencies","title":"Cross-Store Dependencies","text":"<p>Stores can reference observables from other Stores, enabling modular architecture:</p> <pre><code>class ThemeStore(Store):\n    mode = observable(\"light\")  # \"light\" or \"dark\"\n    font_size = observable(16)\n\nclass UIStore(Store):\n    sidebar_open = observable(True)\n\n    # Depends on ThemeStore\n    background_color = ThemeStore.mode &gt;&gt; (\n        lambda mode: \"#ffffff\" if mode == \"light\" else \"#1a1a1a\"\n    )\n\n    text_color = ThemeStore.mode &gt;&gt; (\n        lambda mode: \"#000000\" if mode == \"light\" else \"#ffffff\"\n    )\n\n    # Depends on multiple observables from ThemeStore\n    css_vars = (ThemeStore.mode | ThemeStore.font_size) &gt;&gt; (\n        lambda mode, size: {\n            '--bg': \"#ffffff\" if mode == \"light\" else \"#1a1a1a\",\n            '--text': \"#000000\" if mode == \"light\" else \"#ffffff\",\n            '--font-size': f\"{size}px\"\n        }\n    )\n</code></pre> <p>This pattern keeps Stores focused while allowing coordination:</p> <pre><code>ThemeStore.mode = \"dark\"\nprint(UIStore.background_color)  # \"#1a1a1a\"\nprint(UIStore.text_color)        # \"#ffffff\"\n\nThemeStore.font_size = 18\nprint(UIStore.css_vars['--font-size'])  # \"18px\"\n</code></pre> <p>Each Store maintains its own domain, but computed values can reach across Store boundaries to create relationships.</p>"},{"location":"generation/markdown/stores/#when-to-use-stores","title":"When to Use Stores","text":"<p>Use Stores when you have:</p> <p>Related state that belongs together: <pre><code># Good: Cart-related state in CartStore\nclass CartStore(Store):\n    items = observable([])\n    discount_code = observable(None)\n    shipping_address = observable(None)\n</code></pre></p> <p>State that needs derived values: <pre><code># Good: Computed values with their source state\nclass FormStore(Store):\n    email = observable(\"\")\n    password = observable(\"\")\n\n    email_valid = email &gt;&gt; (lambda e: '@' in e)\n    password_valid = password &gt;&gt; (lambda p: len(p) &gt;= 8)\n    form_valid = (email_valid | password_valid) &gt;&gt; (lambda e, p: e and p)\n</code></pre></p> <p>State that needs encapsulated modification: <pre><code># Good: Methods that maintain invariants\nclass AccountStore(Store):\n    balance = observable(0)\n\n    @classmethod\n    def deposit(cls, amount):\n        if amount &gt; 0:\n            cls.balance = cls.balance + amount\n\n    @classmethod\n    def withdraw(cls, amount):\n        if 0 &lt; amount &lt;= cls.balance:\n            cls.balance = cls.balance - amount\n</code></pre></p> <p>Don't use Stores for truly independent, single-purpose observables:</p> <pre><code># Overkill: Just use a standalone observable\nclass IsLoadingStore(Store):\n    value = observable(False)\n\n# Better:\nis_loading = observable(False)\n</code></pre>"},{"location":"generation/markdown/stores/#best-practices","title":"Best Practices","text":"<p>1. Keep Stores focused on a single domain</p> <p>Each Store should represent one cohesive area of your application:</p> <pre><code># Good: Focused domains\nclass AuthStore(Store): ...\nclass CartStore(Store): ...\nclass UIStore(Store): ...\n\n# Bad: Everything in one Store\nclass AppStore(Store):\n    user = observable(None)\n    cart_items = observable([])\n    modal_open = observable(False)\n    ...  # 50 more observables\n</code></pre> <p>2. Use class methods for state modifications</p> <p>Encapsulate how state changes:</p> <pre><code># Good: Clear API\n@classmethod\ndef add_item(cls, item):\n    cls.items = cls.items + [item]\n\n# Bad: Direct manipulation everywhere\nSomeStore.items = SomeStore.items + [item]\n</code></pre> <p>3. Always create new values, never mutate</p> <pre><code># Good: New list\ncls.items = cls.items + [new_item]\ncls.items = [item for item in cls.items if item['id'] != id]\n\n# Bad: Mutation (won't trigger reactivity)\ncls.items.append(new_item)\ncls.items.remove(item)\n</code></pre> <p>4. Handle edge cases in computed values</p> <p>Computed values should be defensive:</p> <pre><code># Good: Handles empty list\naverage = values &gt;&gt; (\n    lambda vals: sum(vals) / len(vals) if len(vals) &gt; 0 else 0\n)\n\n# Good: Handles None\nuser_name = user &gt;&gt; (\n    lambda u: u['name'] if u and 'name' in u else \"Guest\"\n)\n</code></pre> <p>5. Name computed values clearly</p> <p>Use names that indicate derivation:</p> <pre><code># Good: Clear that these are derived\nis_valid = email &gt;&gt; (lambda e: '@' in e)\nitem_count = items &gt;&gt; len\ntotal_price = items &gt;&gt; (lambda items: sum(item['price'] for item in items))\n\n# Less clear:\nvalid = email &gt;&gt; (lambda e: '@' in e)\ncount = items &gt;&gt; len\nprice = items &gt;&gt; (lambda items: sum(item['price'] for item in items))\n</code></pre>"},{"location":"generation/markdown/stores/#summary","title":"Summary","text":"<p>Stores organize your reactive state into cohesive, testable units. They combine observables, computed values, and methods into structures that represent distinct domains of your application.</p> <p>Key concepts:</p> <ul> <li>Stores group related observables \u2014 Keep state that belongs together in the same Store</li> <li>Observable descriptors enable clean syntax \u2014 Read and write Store attributes naturally</li> <li>The <code>&gt;&gt;</code> operator creates computed values \u2014 Derived state updates automatically</li> <li>The <code>|</code> operator merges observables \u2014 Combine multiple sources for multi-input computations</li> <li>Always create new values \u2014 Never mutate observable contents in place</li> <li>Methods encapsulate state changes \u2014 Define clear APIs for modifying state</li> <li>Stores can depend on other Stores \u2014 Build modular applications with cross-Store relationships</li> </ul> <p>With Stores, you can build reactive applications that scale from simple counters to complex, multi-domain state management systems. The key is organization: each Store owns its domain, exposes a clean API, and lets FynX handle all the synchronization automatically.</p>"},{"location":"generation/markdown/using-reactive/","title":"@reactive: Automatic Reactions to Change","text":"<p>You've built observables that hold state. You've organized them into Stores with computed properties. But there's still a gap: how do you make things happen when state changes?</p> <p>Right now, if you want to respond to changes, you write this:</p> <pre><code>count = observable(0)\n\ndef log_count(value):\n    print(f\"Count: {value}\")\n\ncount.subscribe(log_count)\n</code></pre> <p>This works. But as your application grows, subscription management becomes tedious:</p> <pre><code># Subscriptions scattered everywhere\ncount.subscribe(update_ui)\ncount.subscribe(save_to_database)\ncount.subscribe(notify_analytics)\nname.subscribe(update_greeting)\nemail.subscribe(validate_email)\n(first_name | last_name).subscribe(update_display_name)\n\n# Later... did you remember to unsubscribe?\ncount.unsubscribe(update_ui)\n# Wait, which function was subscribed to which observable?\n</code></pre> <p>You're back to manual synchronization, just with a different syntax. The subscriptions themselves become state you have to manage.</p> <p>There's a better way.</p>"},{"location":"generation/markdown/using-reactive/#introducing-reactive","title":"Introducing @reactive","text":"<p>The <code>@reactive</code> decorator turns functions into automatic reactions. Instead of manually subscribing, you declare what observables matter and FynX handles the rest:</p> <pre><code>from fynx import observable, reactive\n\ncount = observable(0)\n\n@reactive(count)\ndef log_count(value):\n    print(f\"Count: {value}\")\n\ncount.set(5)   # Prints: \"Count: 5\"\ncount.set(10)  # Prints: \"Count: 10\"\n</code></pre> <p>That's it. No manual subscription. No cleanup. Just a declaration: \"this function reacts to this observable.\"</p> <p>The decorator does three things:</p> <ol> <li>Subscribes automatically \u2014 No need to call <code>.subscribe()</code></li> <li>Runs immediately \u2014 The function executes once when decorated, giving you the initial state</li> <li>Runs on every change \u2014 Whenever the observable changes, the function runs with the new value</li> </ol> <p>This is the bridge from passive state management (observables and stores) to active behavior (side effects that respond to changes).</p>"},{"location":"generation/markdown/using-reactive/#how-it-works-the-execution-model","title":"How It Works: The Execution Model","text":"<p>Understanding when <code>@reactive</code> functions run is crucial:</p> <pre><code>count = observable(0)\n\n@reactive(count)\ndef log_count(value):\n    print(f\"Count: {value}\")\n\n# At this point, log_count has already run once with the initial value (0)\n# Output so far: \"Count: 0\"\n\ncount.set(5)   # log_count runs again\n# Output: \"Count: 5\"\n\ncount.set(5)   # Same value - does log_count run?\n# Output: \"Count: 5\" (yes, it runs even if the value hasn't changed)\n</code></pre> <p>The function runs: - Immediately when decorated \u2014 You see the initial state right away - Every time <code>.set()</code> is called \u2014 Even if the new value equals the old value - Synchronously \u2014 The function completes before <code>.set()</code> returns</p> <p>This synchronous execution is important. When you write <code>count.set(5)</code>, you know that all reactive functions have finished by the time the next line of code runs. This makes reactive code predictable and debuggable.</p>"},{"location":"generation/markdown/using-reactive/#the-mental-model-declarative-side-effects","title":"The Mental Model: Declarative Side Effects","text":"<p>Traditional programming separates \"doing\" from \"reacting\":</p> <pre><code># Traditional: Manual coordination\ndef update_count(new_value):\n    count = new_value\n    update_ui(count)           # Remember to call this\n    save_to_database(count)    # Remember to call this\n    log_change(count)          # Remember to call this\n</code></pre> <p>Every time you modify state, you must remember all the dependent actions. Miss one and your application falls out of sync.</p> <p>With <code>@reactive</code>, you declare the relationships once:</p> <pre><code># Reactive: Declare what should happen\n@reactive(count)\ndef update_ui(value):\n    print(f\"UI: {value}\")\n\n@reactive(count)\ndef save_to_database(value):\n    print(f\"Saving: {value}\")\n\n@reactive(count)\ndef log_change(value):\n    print(f\"Log: {value}\")\n\n# Now just update state\ncount.set(42)\n# All three functions run automatically\n# UI: 42\n# Saving: 42\n# Log: 42\n</code></pre> <p>You've moved from \"remember to update everything\" to \"declare what should stay synchronized.\" The burden of coordination shifts from you to FynX.</p>"},{"location":"generation/markdown/using-reactive/#reacting-to-multiple-observables","title":"Reacting to Multiple Observables","text":"<p>Most real-world reactions depend on multiple pieces of state. <code>@reactive</code> accepts multiple observables:</p> <pre><code>first_name = observable(\"Alice\")\nlast_name = observable(\"Smith\")\n\n@reactive(first_name, last_name)\ndef greet(first, last):\n    print(f\"Hello, {first} {last}!\")\n\n# Runs immediately: \"Hello, Alice Smith!\"\n\nfirst_name.set(\"Bob\")\n# Runs again: \"Hello, Bob Smith!\"\n\nlast_name.set(\"Jones\")\n# Runs again: \"Hello, Bob Jones!\"\n</code></pre> <p>When you pass multiple observables, the function receives their values as separate arguments, in the same order you listed them. Change any observable, and the function runs with all current values.</p> <p>This makes coordinating multiple state sources trivial:</p> <pre><code>class CartStore(Store):\n    items = observable([])\n    tax_rate = observable(0.08)\n\n@reactive(CartStore.items, CartStore.tax_rate)\ndef update_total_display(items, rate):\n    subtotal = sum(item['price'] * item['quantity'] for item in items)\n    tax = subtotal * rate\n    total = subtotal + tax\n    print(f\"Total: ${total:.2f}\")\n\n# Runs when items change OR when tax_rate changes\n</code></pre> <p>You don't write separate subscriptions for each observable. You don't coordinate between them. You just declare: \"this function needs these values, run it when any change.\"</p>"},{"location":"generation/markdown/using-reactive/#reacting-to-entire-stores","title":"Reacting to Entire Stores","text":"<p>Sometimes you want to react to any change in a Store, regardless of which specific observable changed. Pass the Store class itself:</p> <pre><code>class UserStore(Store):\n    name = observable(\"Alice\")\n    age = observable(30)\n    email = observable(\"alice@example.com\")\n\n@reactive(UserStore)\ndef sync_to_server(store_snapshot):\n    print(f\"Syncing: {store_snapshot.name}, {store_snapshot.email}\")\n\n# Runs when name changes:\nUserStore.name = \"Bob\"\n\n# Runs when age changes:\nUserStore.age = 31\n\n# Runs when email changes:\nUserStore.email = \"bob@example.com\"\n</code></pre> <p>The function receives a snapshot of the entire Store. This is perfect for operations that need to consider the complete state\u2014saving to a database, logging changes, synchronizing with a server.</p> <p>Note the subtle difference: when reacting to individual observables, you get the values as arguments. When reacting to a Store, you get the Store snapshot itself as a single argument, and you access observables through it.</p>"},{"location":"generation/markdown/using-reactive/#reacting-to-computed-observables","title":"Reacting to Computed Observables","text":"<p>Everything that's an observable\u2014including computed ones\u2014works with <code>@reactive</code>:</p> <pre><code>class CartStore(Store):\n    items = observable([])\n\n# Computed observable\nitem_count = CartStore.items &gt;&gt; (lambda items: len(items))\n\n@reactive(item_count)\ndef update_badge(count):\n    print(f\"Cart badge: {count}\")\n\nCartStore.items = [{'name': 'Widget', 'price': 10}]\n# Computed value recalculates: 1\n# Reactive function runs: \"Cart badge: 1\"\n\nCartStore.items = CartStore.items + [{'name': 'Gadget', 'price': 15}]\n# Computed value recalculates: 2\n# Reactive function runs: \"Cart badge: 2\"\n</code></pre> <p>You don't react to <code>CartStore.items</code> directly. You react to the computed value. This is powerful: it means you only care about changes in the derived state, not every modification to the underlying data.</p>"},{"location":"generation/markdown/using-reactive/#practical-example-form-validation","title":"Practical Example: Form Validation","text":"<p>Here's where <code>@reactive</code> really shines\u2014coordinating complex UI behavior:</p> <pre><code>class FormStore(Store):\n    email = observable(\"\")\n    password = observable(\"\")\n    confirm_password = observable(\"\")\n\n# Computed validations\nemail_valid = FormStore.email &gt;&gt; (\n    lambda e: '@' in e and '.' in e.split('@')[-1]\n)\n\npassword_valid = FormStore.password &gt;&gt; (\n    lambda p: len(p) &gt;= 8\n)\n\npasswords_match = (FormStore.password | FormStore.confirm_password) &gt;&gt; (\n    lambda pwd, confirm: pwd == confirm and pwd != \"\"\n)\n\nform_valid = (email_valid | password_valid | passwords_match) &gt;&gt; (\n    lambda ev, pv, pm: ev and pv and pm\n)\n\n# Reactive UI updates\n@reactive(email_valid)\ndef update_email_indicator(is_valid):\n    status = \"\u2713\" if is_valid else \"\u2717\"\n    print(f\"Email: {status}\")\n\n@reactive(password_valid)\ndef update_password_indicator(is_valid):\n    status = \"\u2713\" if is_valid else \"\u2717\"\n    print(f\"Password strength: {status}\")\n\n@reactive(passwords_match)\ndef update_match_indicator(match):\n    status = \"\u2713\" if match else \"\u2717\"\n    print(f\"Passwords match: {status}\")\n\n@reactive(form_valid)\ndef update_submit_button(is_valid):\n    state = \"enabled\" if is_valid else \"disabled\"\n    print(f\"Submit button: {state}\")\n\n# Now just update the form fields\nFormStore.email = \"alice@example.com\"\n# Email: \u2713\n# Submit button: disabled (password not valid yet)\n\nFormStore.password = \"secure123\"\n# Password strength: \u2713\n# Passwords match: \u2717\n# Submit button: disabled\n\nFormStore.confirm_password = \"secure123\"\n# Passwords match: \u2713\n# Submit button: enabled\n</code></pre> <p>Every UI element updates automatically in response to the relevant state changes. You never write \"when email changes, check if it's valid and update the indicator.\" You just declare the relationship and FynX handles the orchestration.</p>"},{"location":"generation/markdown/using-reactive/#when-reactive-runs-understanding-execution-order","title":"When @reactive Runs: Understanding Execution Order","text":"<p>When multiple observables change in quick succession, reactive functions run in a predictable order:</p> <pre><code>count = observable(0)\n\n@reactive(count)\ndef first_reaction(value):\n    print(f\"First: {value}\")\n\n@reactive(count)\ndef second_reaction(value):\n    print(f\"Second: {value}\")\n\ncount.set(5)\n# Output:\n# First: 5\n# Second: 5\n</code></pre> <p>Reactive functions run in the order they were decorated. This ordering is deterministic but fragile\u2014if reaction order matters to your application, you're probably doing something wrong. Each reaction should be independent, responding only to the observable values it receives.</p> <p>If you have reactions that depend on each other, consider using computed observables instead:</p> <pre><code># Don't do this: reactions that depend on other reactions\nshared_state = []\n\n@reactive(count)\ndef reaction_one(value):\n    shared_state.append(value)\n\n@reactive(count)\ndef reaction_two(value):\n    # This assumes reaction_one has already run\n    print(f\"Total accumulated: {sum(shared_state)}\")\n\n# Do this instead: express dependencies through computed observables\naccumulated = count &gt;&gt; (lambda c: sum(range(c + 1)))\n\n@reactive(accumulated)\ndef show_total(total):\n    print(f\"Total: {total}\")\n</code></pre>"},{"location":"generation/markdown/using-reactive/#reactive-vs-manual-subscriptions","title":"@reactive vs. Manual Subscriptions","text":"<p>When should you use <code>@reactive</code> instead of calling <code>.subscribe()</code> directly?</p> <p>Use <code>@reactive</code> when:</p> <pre><code># You want declarative, self-documenting code\n@reactive(user_count)\ndef update_dashboard(count):\n    print(f\"Users: {count}\")\n\n# You need the function to run immediately with initial state\n@reactive(theme)\ndef apply_theme(theme_name):\n    load_css(theme_name)  # Runs right away\n\n# You're defining reactions at module level or class definition\nclass UIController:\n    @reactive(AppStore.mode)\n    def sync_mode(mode):\n        update_ui_mode(mode)\n</code></pre> <p>Use <code>.subscribe()</code> when:</p> <pre><code># You need dynamic subscriptions that change at runtime\nif user_wants_notifications:\n    count.subscribe(send_notification)\n\n# You need to unsubscribe conditionally\nsubscription_func = count.subscribe(handler)\nif some_condition:\n    count.unsubscribe(subscription_func)\n\n# You're building a library that accepts observables\ndef create_widget(data_observable):\n    data_observable.subscribe(widget.update)\n</code></pre> <p>The rule of thumb: <code>@reactive</code> for static, declarative reactions that exist for the lifetime of your application. <code>.subscribe()</code> for dynamic, programmatic subscriptions that you manage explicitly.</p>"},{"location":"generation/markdown/using-reactive/#common-patterns","title":"Common Patterns","text":"<p>Pattern 1: Syncing to external systems</p> <pre><code>@reactive(AppStore)\ndef save_state(store):\n    serialized = {\n        'user': store.user,\n        'settings': store.settings\n    }\n    save_to_local_storage('app_state', serialized)\n</code></pre> <p>Pattern 2: Logging and debugging</p> <pre><code>@reactive(UserStore.login_count)\ndef log_logins(count):\n    print(f\"[DEBUG] Login count: {count}\")\n    if count &gt; 100:\n        print(\"[WARN] Unusual login activity detected\")\n</code></pre> <p>Pattern 3: Cross-store coordination</p> <pre><code>@reactive(ThemeStore.mode)\ndef update_editor_theme(mode):\n    EditorStore.syntax_theme = \"dark\" if mode == \"dark\" else \"light\"\n</code></pre> <p>Pattern 4: Analytics and tracking</p> <pre><code>@reactive(CartStore.items)\ndef track_cart_changes(items):\n    analytics.track('cart_updated', {\n        'item_count': len(items),\n        'total_value': sum(item['price'] for item in items)\n    })\n</code></pre>"},{"location":"generation/markdown/using-reactive/#gotchas-and-edge-cases","title":"Gotchas and Edge Cases","text":"<p>1. Infinite loops are possible</p> <pre><code>count = observable(0)\n\n@reactive(count)\ndef increment_forever(value):\n    count.set(value + 1)  # DON'T DO THIS\n\n# This will hang your program\n</code></pre> <p>FynX doesn't prevent infinite loops. If your reactive function modifies an observable it's reacting to, you create a cycle. The solution: reactive functions should perform side effects (UI updates, logging, network calls), not modify the observables they're watching.</p> <p>2. Reactive functions don't track .value reads</p> <pre><code>other_count = observable(10)\n\n@reactive(count)\ndef show_sum(value):\n    print(f\"Sum: {value + other_count.value}\")\n\ncount.set(5)  # Prints: \"Sum: 15\"\nother_count.set(20)  # Doesn't trigger show_sum\n</code></pre> <p>The function only reacts to observables passed to <code>@reactive()</code>. Reading <code>other_count.value</code> inside the function doesn't create a dependency. If you want to react to both, pass both:</p> <pre><code>@reactive(count, other_count)\ndef show_sum(value, other):\n    print(f\"Sum: {value + other}\")\n</code></pre> <p>3. Reactive functions receive values, not observables</p> <pre><code>@reactive(count)\ndef try_to_modify(value):\n    value.set(100)  # ERROR: value is an int, not an observable\n\n# If you need the observable, access it directly:\n@reactive(count)\ndef correct_approach(value):\n    if value &lt; 0:\n        count.set(0)  # Access count directly, not through the argument\n</code></pre> <p>4. Store reactions receive snapshots</p> <pre><code>@reactive(UserStore)\ndef save_user(store):\n    # store is a snapshot of UserStore at this moment\n    # store.name is the current value, not an observable\n    save_to_db(store.name)  # Correct\n\n    # This won't give you an observable:\n    store.name.subscribe(handler)  # ERROR\n</code></pre>"},{"location":"generation/markdown/using-reactive/#performance-considerations","title":"Performance Considerations","text":"<p>Reactive functions run synchronously on every change. For expensive operations, consider:</p> <p>Debouncing through computed observables:</p> <pre><code>search_query = observable(\"\")\n\n# Computed observable that only changes when meaningful\nfiltered_results = search_query &gt;&gt; (\n    lambda q: search_database(q) if len(q) &gt;= 3 else []\n)\n\n@reactive(filtered_results)\ndef update_ui(results):\n    display_results(results)  # Only runs when filter criteria met\n</code></pre> <p>Conditional logic inside reactions:</p> <pre><code>@reactive(mouse_position)\ndef update_tooltip(position):\n    if should_show_tooltip(position):  # Guard clause\n        expensive_tooltip_render(position)\n</code></pre> <p>Batching updates:</p> <pre><code>pending_saves = []\n\n@reactive(DocumentStore.content)\ndef queue_save(content):\n    pending_saves.append(content)\n    # Actual save happens elsewhere, periodically\n</code></pre>"},{"location":"generation/markdown/using-reactive/#whats-next","title":"What's Next","text":"<p><code>@reactive</code> gives you automatic reactions to state changes, but it runs unconditionally\u2014every time the observable changes, the function runs. Sometimes you want more control. Sometimes you only care about specific transitions, like \"when the user becomes eligible for checkout\" or \"when validation passes for the first time.\"</p> <p>That's where <code>@watch</code> comes in. While <code>@reactive</code> says \"run this whenever these observables change,\" <code>@watch</code> says \"run this when a condition becomes true.\" It's the difference between reacting to every change and reacting to specific events within your state.</p> <p>In the next section, you'll learn how to express conditional reactive logic declaratively, without cluttering your code with manual state tracking and conditional checks.</p>"},{"location":"generation/markdown/using-reactive/#summary","title":"Summary","text":"<p>The <code>@reactive</code> decorator transforms functions into automatic reactions that run whenever observables change:</p> <ul> <li>Declarative subscriptions \u2014 No manual <code>.subscribe()</code> calls to manage</li> <li>Runs immediately and on changes \u2014 Get initial state and all updates</li> <li>Works with any observable \u2014 Standalone, Store attributes, computed values, merged observables</li> <li>Multiple observable support \u2014 React to several sources, receive values as arguments</li> <li>Store-level reactions \u2014 React to any change in an entire Store</li> <li>Side effects, not state changes \u2014 Reactive functions should perform effects, not modify watched observables</li> </ul> <p>With <code>@reactive</code>, you declare what should happen when state changes. FynX ensures it happens automatically, in the right order, every time. This eliminates a whole category of synchronization bugs and makes your reactive systems self-maintaining.</p>"},{"location":"generation/markdown/using-watch/","title":"@watch: Conditional Reactions","text":"<p>You've learned how <code>@reactive</code> runs functions automatically whenever observables change. This is perfect for keeping things synchronized\u2014update the UI when state changes, save to the database when data changes, log when values change.</p> <p>But not every reaction should happen on every change. Sometimes you only care about specific moments:</p> <ul> <li>When form validation passes for the first time</li> <li>When a shopping cart becomes eligible for checkout</li> <li>When a user's login count crosses a threshold</li> <li>When a download completes</li> <li>When all required fields become filled</li> </ul> <p>These aren't continuous reactions to every change. They're reactions to events\u2014specific transitions in your application state. Writing these with <code>@reactive</code> leads to awkward code:</p> <pre><code># Awkward: Manual state tracking with @reactive\nlast_valid_state = False\n\n@reactive(form_valid)\ndef on_validation_change(is_valid):\n    global last_valid_state\n    if is_valid and not last_valid_state:\n        # Form just became valid\n        print(\"\u2705 Validation passed!\")\n        enable_submit_button()\n    last_valid_state = is_valid\n</code></pre> <p>You're tracking state manually, checking for transitions, maintaining flags. This is exactly the kind of bookkeeping that reactive programming should eliminate.</p> <p>There's a better way.</p>"},{"location":"generation/markdown/using-watch/#introducing-watch","title":"Introducing @watch","text":"<p>The <code>@watch</code> decorator runs functions when conditions become true. Instead of reacting to every change, you react to specific state transitions:</p> <pre><code>from fynx import watch\n\n@watch(lambda: form_valid.value)\ndef on_validation_pass():\n    print(\"\u2705 Validation passed!\")\n    enable_submit_button()\n</code></pre> <p>That's it. No manual state tracking. No comparing previous and current values. Just a declaration: \"when this condition becomes true, run this function.\"</p> <p>The function runs once when the condition transitions from false to true, and then stays dormant until the condition becomes false and true again. This makes <code>@watch</code> perfect for event-driven reactions\u2014things that should happen at specific moments, not continuously.</p>"},{"location":"generation/markdown/using-watch/#how-it-works-the-transition-model","title":"How It Works: The Transition Model","text":"<p>Understanding when <code>@watch</code> functions run is crucial. They don't run on every change\u2014they run on transitions to true:</p> <pre><code>count = observable(0)\n\n@watch(lambda: count.value &gt; 5)\ndef on_threshold():\n    print(\"Count exceeded 5!\")\n\n# Nothing happens yet - condition is false\n\ncount.set(3)   # Condition still false, nothing happens\ncount.set(6)   # Condition becomes true!\n# Output: \"Count exceeded 5!\"\n\ncount.set(7)   # Condition stays true, nothing happens\ncount.set(8)   # Condition still true, nothing happens\n\ncount.set(2)   # Condition becomes false, nothing happens\ncount.set(10)  # Condition becomes true again!\n# Output: \"Count exceeded 5!\"\n</code></pre> <p>The pattern is clear: - False \u2192 False \u2014 Nothing happens - False \u2192 True \u2014 Function runs - True \u2192 True \u2014 Nothing happens - True \u2192 False \u2014 Nothing happens (function doesn't run) - False \u2192 True \u2014 Function runs again</p> <p>The function fires on the rising edge of the condition\u2014the moment it transitions from false to true. This makes <code>@watch</code> ideal for threshold crossings, status changes, and event detection.</p>"},{"location":"generation/markdown/using-watch/#the-mental-model-state-transitions-as-events","title":"The Mental Model: State Transitions as Events","text":"<p>Traditional programming handles state transitions imperatively:</p> <pre><code># Traditional: Manual transition detection\ndef check_cart_status():\n    if can_checkout() and not previously_could_checkout:\n        show_checkout_button()\n        previously_could_checkout = True\n    elif not can_checkout() and previously_could_checkout:\n        hide_checkout_button()\n        previously_could_checkout = False\n</code></pre> <p>You're explicitly tracking previous state, comparing it to current state, and remembering to check on every relevant update. Miss a check and your UI gets out of sync.</p> <p>With <code>@watch</code>, you declare the transition points:</p> <pre><code># Reactive: Declare what should happen at state transitions\n@watch(lambda: can_checkout.value)\ndef on_checkout_available():\n    show_checkout_button()\n\n@watch(lambda: not can_checkout.value)\ndef on_checkout_unavailable():\n    hide_checkout_button()\n</code></pre> <p>You've moved from \"track and compare state\" to \"declare what happens when.\" The transition detection is automatic. The state tracking is automatic. You just express the events you care about.</p>"},{"location":"generation/markdown/using-watch/#writing-condition-functions","title":"Writing Condition Functions","text":"<p>The <code>@watch</code> decorator accepts a function that returns a boolean\u2014this is your condition. Inside this function, you read observable values using <code>.value</code>:</p> <pre><code>age = observable(16)\n\n@watch(lambda: age.value &gt;= 18)\ndef on_becomes_adult():\n    print(\"User is now an adult!\")\n\nage.set(17)  # Nothing happens\nage.set(18)  # Prints: \"User is now an adult!\"\n</code></pre> <p>The condition function is checked every time any observable it reads changes. When you access <code>age.value</code> inside the lambda, <code>@watch</code> automatically tracks that dependency and re-evaluates the condition whenever <code>age</code> changes.</p> <p>This automatic dependency tracking is what makes <code>@watch</code> powerful. You don't manually list which observables to watch\u2014just write a condition that reads them, and FynX figures out the dependencies.</p>"},{"location":"generation/markdown/using-watch/#multiple-conditions-and-logic","title":"Multiple Conditions: AND Logic","text":"<p>You can pass multiple condition functions to <code>@watch</code>. The decorated function runs when all conditions become true simultaneously:</p> <pre><code>has_items = observable(False)\nis_logged_in = observable(False)\n\n@watch(\n    lambda: has_items.value,\n    lambda: is_logged_in.value\n)\ndef on_ready_to_checkout():\n    print(\"Ready to checkout!\")\n\nhas_items.set(True)      # Only one condition true, nothing happens\nis_logged_in.set(True)   # Both now true!\n# Output: \"Ready to checkout!\"\n</code></pre> <p>This is AND logic: <code>condition1 AND condition2 AND condition3...</code>. All must be true for the function to run. This is perfect for complex state requirements like \"user is logged in AND has items in cart AND has a valid payment method.\"</p> <p>The function fires when the combined condition transitions from false to true. If any individual condition becomes false and then true, but the others remain true, nothing happens. The entire combined condition must transition:</p> <pre><code>@watch(\n    lambda: has_items.value,\n    lambda: is_logged_in.value\n)\ndef on_ready():\n    print(\"Ready!\")\n\n# Initial state: both false\nhas_items.set(True)        # Combined: False (one still false)\nis_logged_in.set(True)     # Combined: True (both now true)\n# Output: \"Ready!\"\n\nhas_items.set(False)       # Combined: False\nhas_items.set(True)        # Combined: True (back to all true)\n# Output: \"Ready!\"\n</code></pre>"},{"location":"generation/markdown/using-watch/#practical-example-form-submission-flow","title":"Practical Example: Form Submission Flow","text":"<p>Here's where <code>@watch</code> shines\u2014expressing multi-step workflows as declarative transitions:</p> <pre><code>class FormStore(Store):\n    email = observable(\"\")\n    password = observable(\"\")\n    terms_accepted = observable(False)\n    is_submitting = observable(False)\n    submission_complete = observable(False)\n\n# Computed validations\nemail_valid = FormStore.email &gt;&gt; (\n    lambda e: '@' in e and len(e) &gt; 3\n)\n\npassword_valid = FormStore.password &gt;&gt; (\n    lambda p: len(p) &gt;= 8\n)\n\nall_valid = (email_valid | password_valid | FormStore.terms_accepted) &gt;&gt; (\n    lambda e, p, t: e and p and t\n)\n\n# Watch for form becoming submittable\n@watch(lambda: all_valid.value)\ndef on_form_valid():\n    print(\"\u2705 Form is valid - submit button enabled\")\n    enable_submit_button()\n\n# Watch for form becoming invalid (using NOT)\n@watch(lambda: not all_valid.value)\ndef on_form_invalid():\n    print(\"\u274c Form is invalid - submit button disabled\")\n    disable_submit_button()\n\n# Watch for submission starting\n@watch(lambda: FormStore.is_submitting.value)\ndef on_submit_start():\n    print(\"\ud83d\udd04 Submitting form...\")\n    show_loading_spinner()\n    actual_submit_to_server()\n\n# Watch for submission completing\n@watch(lambda: FormStore.submission_complete.value)\ndef on_submit_complete():\n    print(\"\u2705 Submission complete!\")\n    hide_loading_spinner()\n    show_success_message()\n    FormStore.is_submitting = False\n\n# Simulate the flow\nprint(\"Initial state:\")\nFormStore.email = \"user@example.com\"\nFormStore.password = \"secure123\"\nFormStore.terms_accepted = True\n# Output: \"\u2705 Form is valid - submit button enabled\"\n\nprint(\"\\nUser clicks submit:\")\nFormStore.is_submitting = True\n# Output: \"\ud83d\udd04 Submitting form...\"\n\nprint(\"\\nServer responds:\")\nFormStore.submission_complete = True\n# Output: \"\u2705 Submission complete!\"\n</code></pre> <p>Each <code>@watch</code> declaration captures one transition in your workflow. The complete behavior emerges from these individual transition handlers, with no manual orchestration code needed.</p>"},{"location":"generation/markdown/using-watch/#watching-complex-conditions","title":"Watching Complex Conditions","text":"<p>Condition functions can contain arbitrary logic. Read multiple observables, perform calculations, call helper functions\u2014anything that returns a boolean:</p> <pre><code>class AnalyticsStore(Store):\n    page_views = observable(0)\n    time_on_site = observable(0)  # seconds\n    items_clicked = observable(0)\n\n@watch(\n    lambda: (\n        AnalyticsStore.page_views.value &gt; 5 and\n        AnalyticsStore.time_on_site.value &gt; 60 and\n        AnalyticsStore.items_clicked.value &gt; 3\n    )\n)\ndef on_engaged_user():\n    print(\"\ud83c\udfaf User is highly engaged!\")\n    show_upgrade_prompt()\n\n@watch(\n    lambda: (\n        AnalyticsStore.page_views.value &gt; 10 or\n        AnalyticsStore.time_on_site.value &gt; 300\n    )\n)\ndef on_power_user():\n    print(\"\u2b50 Power user detected!\")\n    enable_advanced_features()\n</code></pre> <p>FynX tracks all observable reads inside your condition, regardless of how complex the logic. The condition re-evaluates whenever any of those observables change.</p>"},{"location":"generation/markdown/using-watch/#one-time-events-vs-repeating-events","title":"One-Time Events vs. Repeating Events","text":"<p><code>@watch</code> naturally handles both one-time events and repeating events:</p> <pre><code>login_count = observable(0)\n\n# One-time event: fires once, never again (unless condition resets)\n@watch(lambda: login_count.value == 1)\ndef on_first_login():\n    print(\"\ud83c\udf89 Welcome! This is your first login!\")\n    show_tutorial()\n\n# Repeating event: fires every 10 logins\nlast_milestone = 0\n\n@watch(lambda: login_count.value &gt;= last_milestone + 10)\ndef on_login_milestone():\n    global last_milestone\n    last_milestone = login_count.value\n    print(f\"\ud83c\udfc6 Milestone: {login_count.value} logins!\")\n\n# Simulate logins\nfor i in range(1, 25):\n    login_count.set(i)\n\n# Output:\n# \ud83c\udf89 Welcome! This is your first login!\n# \ud83c\udfc6 Milestone: 10 logins!\n# \ud83c\udfc6 Milestone: 20 logins!\n</code></pre> <p>For truly one-time events, you might track state manually. But for most cases, the natural false\u2192true\u2192false\u2192true cycle of conditions handles repetition elegantly.</p>"},{"location":"generation/markdown/using-watch/#watching-store-level-changes","title":"Watching Store-Level Changes","text":"<p>Unlike <code>@reactive</code>, you can't pass entire Stores to <code>@watch</code>. Conditions must be explicit boolean expressions:</p> <pre><code># This won't work - @watch needs a condition function\n@watch(UserStore)  # ERROR\ndef on_user_change():\n    print(\"User changed\")\n\n# Instead, watch specific conditions derived from the Store\n@watch(lambda: UserStore.is_authenticated.value)\ndef on_login():\n    print(\"User logged in!\")\n\n@watch(\n    lambda: (\n        UserStore.profile_complete.value and\n        not UserStore.is_premium.value\n    )\n)\ndef on_eligible_for_upgrade():\n    print(\"User eligible for premium upgrade!\")\n</code></pre> <p>This is by design. <code>@watch</code> is for transitions, and transitions require boolean conditions. If you need to react to any Store change, use <code>@reactive</code> instead.</p>"},{"location":"generation/markdown/using-watch/#combining-watch-with-computed-observables","title":"Combining @watch with Computed Observables","text":"<p>The real power emerges when you combine <code>@watch</code> with computed observables. Compute complex state, then watch for transitions:</p> <pre><code>class ShoppingCartStore(Store):\n    items = observable([])\n    shipping_address = observable(None)\n    payment_method = observable(None)\n\n# Computed: Is cart ready for checkout?\nhas_items = ShoppingCartStore.items &gt;&gt; (lambda items: len(items) &gt; 0)\nhas_shipping = ShoppingCartStore.shipping_address &gt;&gt; (lambda addr: addr is not None)\nhas_payment = ShoppingCartStore.payment_method &gt;&gt; (lambda pm: pm is not None)\n\ncan_checkout = (has_items | has_shipping | has_payment) &gt;&gt; (\n    lambda items, shipping, payment: items and shipping and payment\n)\n\n# Watch the computed condition\n@watch(lambda: can_checkout.value)\ndef on_checkout_ready():\n    print(\"\ud83d\uded2 Ready to checkout!\")\n    enable_checkout_button()\n    send_abandoned_cart_recovery_cancellation()\n\n@watch(lambda: not can_checkout.value)\ndef on_checkout_not_ready():\n    print(\"\u23f8\ufe0f Checkout not available\")\n    disable_checkout_button()\n    schedule_abandoned_cart_email()\n</code></pre> <p>The computed observable encapsulates the business logic. The <code>@watch</code> decorator handles the transition detection. Each piece has a single, clear responsibility.</p>"},{"location":"generation/markdown/using-watch/#common-patterns","title":"Common Patterns","text":"<p>Pattern 1: Threshold crossings</p> <pre><code>score = observable(0)\n\n@watch(lambda: score.value &gt;= 100)\ndef on_level_complete():\n    print(\"\ud83c\udf8a Level complete!\")\n    advance_to_next_level()\n</code></pre> <p>Pattern 2: Status changes</p> <pre><code>@watch(lambda: ConnectionStore.is_connected.value)\ndef on_connect():\n    print(\"\u2705 Connected to server\")\n    sync_data()\n\n@watch(lambda: not ConnectionStore.is_connected.value)\ndef on_disconnect():\n    print(\"\u274c Disconnected from server\")\n    show_offline_mode()\n</code></pre> <p>Pattern 3: Eligibility detection</p> <pre><code>@watch(\n    lambda: UserStore.age.value &gt;= 18,\n    lambda: UserStore.has_verified_email.value,\n    lambda: UserStore.account_age_days.value &gt;= 7\n)\ndef on_eligible_for_feature():\n    print(\"\ud83c\udf81 New feature unlocked!\")\n    show_feature_announcement()\n</code></pre> <p>Pattern 4: Completion tracking</p> <pre><code>@watch(\n    lambda: DownloadStore.progress.value &gt;= 100,\n    lambda: not DownloadStore.has_error.value\n)\ndef on_download_complete():\n    print(\"\u2705 Download complete!\")\n    notify_user()\n    start_installation()\n</code></pre> <p>Pattern 5: Multi-step workflows</p> <pre><code># Step 1: User starts onboarding\n@watch(lambda: OnboardingStore.started.value)\ndef on_onboarding_start():\n    print(\"\ud83d\udc4b Starting onboarding...\")\n    show_welcome_screen()\n\n# Step 2: User completes profile\n@watch(lambda: OnboardingStore.profile_complete.value)\ndef on_profile_complete():\n    print(\"\u2705 Profile complete!\")\n    show_preference_screen()\n\n# Step 3: User sets preferences\n@watch(lambda: OnboardingStore.preferences_complete.value)\ndef on_preferences_complete():\n    print(\"\u2705 Preferences saved!\")\n    show_dashboard()\n    OnboardingStore.finished = True\n\n# Step 4: Onboarding finished\n@watch(lambda: OnboardingStore.finished.value)\ndef on_onboarding_complete():\n    print(\"\ud83c\udf89 Onboarding complete!\")\n    track_onboarding_completion()\n</code></pre>"},{"location":"generation/markdown/using-watch/#watch-vs-reactive-when-to-use-each","title":"@watch vs. @reactive: When to Use Each","text":"<p>The choice between <code>@watch</code> and <code>@reactive</code> depends on what you're modeling:</p> <p>Use <code>@reactive</code> when you want continuous synchronization:</p> <pre><code># Run on EVERY change to keep things in sync\n@reactive(ThemeStore.mode)\ndef sync_theme(mode):\n    update_css_variables(mode)\n    save_preference('theme', mode)\n</code></pre> <p>Use <code>@watch</code> when you want event-driven reactions:</p> <pre><code># Run ONCE when condition becomes true\n@watch(lambda: ThemeStore.mode.value == 'dark')\ndef on_dark_mode_enabled():\n    print(\"\ud83c\udf19 Dark mode activated!\")\n    show_notification(\"Dark mode enabled\")\n</code></pre> <p>Use <code>@reactive</code> for: UI updates, data synchronization, logging every change, keeping derived state current</p> <p>Use <code>@watch</code> for: Notifications, workflow transitions, milestone tracking, one-time setup, threshold alerts</p> <p>A rule of thumb: if you care about what the value is, use <code>@reactive</code>. If you care about when something becomes true, use <code>@watch</code>.</p>"},{"location":"generation/markdown/using-watch/#practical-example-user-engagement-system","title":"Practical Example: User Engagement System","text":"<p>Let's build a complete engagement tracking system that demonstrates both decorators working together:</p> <pre><code>class UserActivityStore(Store):\n    page_views = observable(0)\n    actions_taken = observable(0)\n    time_on_site = observable(0)  # seconds\n    has_account = observable(False)\n    is_premium = observable(False)\n\n# Computed engagement score (0-100)\nengagement_score = (\n    UserActivityStore.page_views |\n    UserActivityStore.actions_taken |\n    UserActivityStore.time_on_site\n) &gt;&gt; (\n    lambda views, actions, time: min(\n        100,\n        (views * 5) + (actions * 10) + (time / 6)\n    )\n)\n\n# Continuous monitoring with @reactive\n@reactive(engagement_score)\ndef update_engagement_display(score):\n    print(f\"\ud83d\udcca Engagement: {score:.0f}/100\")\n    update_progress_bar(score)\n\n@reactive(UserActivityStore.page_views)\ndef track_page_views(views):\n    analytics.track('page_view_count', views)\n\n# Event-driven reactions with @watch\n\n# Engagement milestones\n@watch(lambda: engagement_score.value &gt;= 25)\ndef on_low_engagement():\n    print(\"\ud83d\udfe1 User is browsing\")\n\n@watch(lambda: engagement_score.value &gt;= 50)\ndef on_medium_engagement():\n    print(\"\ud83d\udfe0 User is engaged!\")\n    show_tooltip(\"Enjoying the site? Create an account!\")\n\n@watch(lambda: engagement_score.value &gt;= 75)\ndef on_high_engagement():\n    print(\"\ud83d\udd34 User is highly engaged!\")\n    show_modal(\"Love what you see? Try Premium!\")\n\n# Account creation flow\n@watch(lambda: UserActivityStore.has_account.value)\ndef on_account_created():\n    print(\"\ud83c\udf89 Account created!\")\n    send_welcome_email()\n    unlock_saved_features()\n\n# Premium conversion\n@watch(\n    lambda: UserActivityStore.has_account.value,\n    lambda: engagement_score.value &gt;= 60,\n    lambda: not UserActivityStore.is_premium.value\n)\ndef on_premium_eligible():\n    print(\"\ud83d\udc8e User eligible for Premium!\")\n    show_upgrade_offer()\n\n@watch(lambda: UserActivityStore.is_premium.value)\ndef on_premium_conversion():\n    print(\"\ud83d\ude80 User upgraded to Premium!\")\n    send_thank_you_email()\n    enable_premium_features()\n    track_conversion()\n\n# Simulate user journey\nprint(\"=== User starts browsing ===\")\nUserActivityStore.page_views = 3\nUserActivityStore.time_on_site = 45\n\nprint(\"\\n=== User interacts more ===\")\nUserActivityStore.actions_taken = 2\nUserActivityStore.page_views = 6\n\nprint(\"\\n=== User creates account ===\")\nUserActivityStore.has_account = True\nUserActivityStore.time_on_site = 120\n\nprint(\"\\n=== User upgrades to premium ===\")\nUserActivityStore.is_premium = True\n\n# Output shows both continuous updates and discrete events:\n# \ud83d\udcca Engagement: 45/100\n# \ud83d\udfe1 User is browsing\n# \ud83d\udcca Engagement: 60/100\n# \ud83d\udfe0 User is engaged!\n# \ud83c\udf89 Account created!\n# \ud83d\udc8e User eligible for Premium!\n# \ud83d\udcca Engagement: 80/100\n# \ud83d\udd34 User is highly engaged!\n# \ud83d\ude80 User upgraded to Premium!\n</code></pre> <p>The <code>@reactive</code> decorators handle continuous monitoring\u2014updating displays and tracking metrics. The <code>@watch</code> decorators handle discrete events\u2014milestones, state transitions, business logic triggers. Together they create a complete reactive system.</p>"},{"location":"generation/markdown/using-watch/#gotchas-and-edge-cases","title":"Gotchas and Edge Cases","text":"<p>1. Initial state doesn't trigger @watch</p> <pre><code># Condition starts as true\nready = observable(True)\n\n@watch(lambda: ready.value)\ndef on_ready():\n    print(\"Ready!\")\n\n# Nothing prints - no transition occurred\n# Function only runs when condition goes false \u2192 true\n</code></pre> <p>If you need to handle initial state, check it explicitly or use <code>@reactive</code> instead:</p> <pre><code># Option 1: Check initial state\n@watch(lambda: ready.value)\ndef on_ready():\n    print(\"Ready!\")\n\nif ready.value:\n    on_ready()  # Call manually for initial state\n\n# Option 2: Use @reactive for immediate execution\n@reactive(ready)\ndef on_ready_immediate(is_ready):\n    if is_ready:\n        print(\"Ready!\")\n</code></pre> <p>2. Condition functions should be pure</p> <pre><code># Bad: Side effects in condition\n@watch(lambda: (print(\"Checking...\"), count.value &gt; 5)[1])\ndef on_threshold():\n    print(\"Threshold reached!\")\n\n# The print runs every time the condition is checked,\n# not just when it becomes true\n</code></pre> <p>Condition functions are checked frequently. Keep them pure\u2014no side effects, just boolean logic. Save side effects for the decorated function.</p> <p>3. Complex conditions can mask transitions</p> <pre><code>count = observable(0)\n\n@watch(lambda: count.value &gt; 5 and count.value &lt; 10)\ndef in_range():\n    print(\"In range!\")\n\ncount.set(7)   # Prints: \"In range!\"\ncount.set(8)   # Nothing (condition still true)\ncount.set(15)  # Nothing (condition becomes false)\ncount.set(7)   # Prints: \"In range!\" (condition true again)\ncount.set(5)   # Nothing (condition becomes false)\ncount.set(6)   # Prints: \"In range!\" (condition true again)\n</code></pre> <p>The condition only cares about true/false transitions, not the specific values that made it true. Design your conditions to capture the transitions you care about.</p> <p>4. Watch decorators don't compose</p> <pre><code># This doesn't do what you might expect\n@watch(lambda: condition_a.value)\n@watch(lambda: condition_b.value)\ndef on_either():\n    print(\"Something happened!\")\n\n# Only the innermost @watch takes effect\n</code></pre> <p>Each <code>@watch</code> creates a separate conditional reaction. To watch multiple independent conditions, create separate functions:</p> <pre><code>@watch(lambda: condition_a.value)\ndef on_condition_a():\n    handle_event()\n\n@watch(lambda: condition_b.value)\ndef on_condition_b():\n    handle_event()\n</code></pre> <p>5. Beware of condition evaluation cost</p> <pre><code># Expensive condition checked on every change\n@watch(lambda: expensive_computation(data.value) &gt; threshold.value)\ndef on_expensive_trigger():\n    print(\"Triggered!\")\n</code></pre> <p>The condition function runs every time any observable it reads changes. For expensive checks, compute the result once and watch the computed observable:</p> <pre><code># Better: Compute once, watch the result\nexpensive_result = data &gt;&gt; expensive_computation\nis_above_threshold = (expensive_result | threshold) &gt;&gt; (\n    lambda result, thresh: result &gt; thresh\n)\n\n@watch(lambda: is_above_threshold.value)\ndef on_trigger():\n    print(\"Triggered!\")\n</code></pre>"},{"location":"generation/markdown/using-watch/#debugging-watch-conditions","title":"Debugging Watch Conditions","text":"<p>When a <code>@watch</code> function isn't firing as expected, debug the condition:</p> <pre><code>count = observable(0)\n\ncondition = lambda: count.value &gt; 5\n\n# Debug version\ndef debug_condition():\n    result = count.value &gt; 5\n    print(f\"Condition check: count={count.value}, result={result}\")\n    return result\n\n@watch(debug_condition)\ndef on_threshold():\n    print(\"Threshold crossed!\")\n\ncount.set(3)  # See: Condition check: count=3, result=False\ncount.set(7)  # See: Condition check: count=7, result=True\n              # Then: Threshold crossed!\n</code></pre> <p>Or extract the condition logic for testing:</p> <pre><code>def is_eligible(user):\n    return (\n        user.age &gt;= 18 and\n        user.email_verified and\n        user.account_age_days &gt;= 7\n    )\n\n# Test the condition independently\nassert is_eligible(test_user) == True\n\n# Use it in @watch\n@watch(lambda: is_eligible(UserStore))\ndef on_eligible():\n    unlock_feature()\n</code></pre>"},{"location":"generation/markdown/using-watch/#performance-considerations","title":"Performance Considerations","text":"<p><code>@watch</code> is efficient\u2014conditions are only re-evaluated when observables they read actually change. But consider:</p> <p>Many watchers on the same observables:</p> <pre><code># Each watcher triggers independently\n@watch(lambda: score.value &gt;= 100) def on_level_1(): ...\n@watch(lambda: score.value &gt;= 200) def on_level_2(): ...\n@watch(lambda: score.value &gt;= 300) def on_level_3(): ...\n# ... 50 more watchers\n\nscore.set(150)  # All 50 conditions are checked\n</code></pre> <p>For many similar conditions, consider a single reaction with conditional logic:</p> <pre><code>@reactive(score)\ndef check_milestones(current_score):\n    if current_score &gt;= 300 and not unlocked['level_3']:\n        on_level_3()\n        unlocked['level_3'] = True\n    elif current_score &gt;= 200 and not unlocked['level_2']:\n        on_level_2()\n        unlocked['level_2'] = True\n    # ...\n</code></pre> <p>Frequently changing observables:</p> <pre><code>mouse_position = observable((0, 0))\n\n@watch(lambda: is_hovering_button(mouse_position.value))\ndef on_hover():\n    show_tooltip()\n\n# Condition checked on EVERY mouse move\n</code></pre> <p>For high-frequency updates, debounce or throttle:</p> <pre><code># Debounced hover detection\nhover_stable = mouse_position &gt;&gt; (\n    lambda pos: debounce(lambda: is_hovering_button(pos), 100)\n)\n\n@watch(lambda: hover_stable.value)\ndef on_stable_hover():\n    show_tooltip()\n</code></pre>"},{"location":"generation/markdown/using-watch/#real-world-example-order-processing-pipeline","title":"Real-World Example: Order Processing Pipeline","text":"<p>Let's build a complete order processing system that shows the full power of <code>@watch</code>:</p> <pre><code>class OrderStore(Store):\n    items = observable([])\n    payment_verified = observable(False)\n    inventory_reserved = observable(False)\n    shipping_label_created = observable(False)\n    shipped = observable(False)\n    delivered = observable(False)\n\n# Computed: Order has items\nhas_items = OrderStore.items &gt;&gt; (lambda items: len(items) &gt; 0)\n\n# Stage 1: Order ready for payment\n@watch(lambda: has_items.value)\ndef on_order_created():\n    print(\"\ud83d\udcdd Order created - awaiting payment\")\n    send_order_confirmation_email()\n\n# Stage 2: Payment verified\n@watch(\n    lambda: OrderStore.payment_verified.value,\n    lambda: has_items.value\n)\ndef on_payment_verified():\n    print(\"\ud83d\udcb3 Payment verified - reserving inventory\")\n    reserve_inventory_for_order()\n    # Simulating async inventory reservation\n    OrderStore.inventory_reserved = True\n\n# Stage 3: Inventory reserved\n@watch(lambda: OrderStore.inventory_reserved.value)\ndef on_inventory_reserved():\n    print(\"\ud83d\udce6 Inventory reserved - creating shipping label\")\n    create_shipping_label()\n    OrderStore.shipping_label_created = True\n\n# Stage 4: Shipping label created\n@watch(lambda: OrderStore.shipping_label_created.value)\ndef on_label_created():\n    print(\"\ud83c\udff7\ufe0f Shipping label created - ready to ship\")\n    notify_warehouse_to_ship()\n\n# Stage 5: Order shipped\n@watch(lambda: OrderStore.shipped.value)\ndef on_shipped():\n    print(\"\ud83d\ude9a Order shipped!\")\n    send_shipping_notification()\n    start_delivery_tracking()\n\n# Stage 6: Order delivered\n@watch(lambda: OrderStore.delivered.value)\ndef on_delivered():\n    print(\"\u2705 Order delivered!\")\n    send_delivery_confirmation()\n    request_review()\n    close_order()\n\n# Simulate the order pipeline\nprint(\"=== Customer adds items ===\")\nOrderStore.items = [\n    {'name': 'Widget', 'price': 29.99},\n    {'name': 'Gadget', 'price': 49.99}\n]\n\nprint(\"\\n=== Payment processed ===\")\nOrderStore.payment_verified = True\n\nprint(\"\\n=== Warehouse ships order ===\")\nOrderStore.shipped = True\n\nprint(\"\\n=== Order delivered ===\")\nOrderStore.delivered = True\n\n# Output:\n# === Customer adds items ===\n# \ud83d\udcdd Order created - awaiting payment\n#\n# === Payment processed ===\n# \ud83d\udcb3 Payment verified - reserving inventory\n# \ud83d\udce6 Inventory reserved - creating shipping label\n# \ud83c\udff7\ufe0f Shipping label created - ready to ship\n#\n# === Warehouse ships order ===\n# \ud83d\ude9a Order shipped!\n#\n# === Order delivered ===\n# \u2705 Order delivered!\n</code></pre> <p>Each stage of the pipeline is a separate <code>@watch</code> declaration. The complete workflow emerges from these independent transition handlers, with no central orchestration code. Add a new stage? Just add another <code>@watch</code>. Remove a stage? Delete the corresponding watch. The pipeline is self-documenting and maintainable.</p>"},{"location":"generation/markdown/using-watch/#summary","title":"Summary","text":"<p>The <code>@watch</code> decorator runs functions when conditions transition from false to true:</p> <ul> <li>Event-driven reactions \u2014 Respond to specific state transitions, not every change</li> <li>Boolean conditions \u2014 Pass lambda functions that return true/false</li> <li>Automatic dependency tracking \u2014 Conditions re-evaluate when observables they read change</li> <li>Multiple conditions \u2014 Combine conditions with AND logic for complex requirements</li> <li>One-time per transition \u2014 Function runs once when condition becomes true, then waits for false\u2192true again</li> <li>Compose with computed observables \u2014 Separate business logic (computed) from event handling (watch)</li> </ul> <p>When <code>@reactive</code> gives you continuous synchronization, <code>@watch</code> gives you precise event detection. Together they cover the full spectrum of reactive behaviors\u2014from \"keep this in sync\" to \"do this when that happens.\"</p> <p>With observables, stores, <code>@reactive</code>, and <code>@watch</code>, you have everything you need to build sophisticated reactive applications where state changes automatically propagate through your system, and important transitions trigger the right behaviors at the right times.</p>"},{"location":"generation/markdown/watch-decorator/","title":"@watch Decorator","text":"<p>Decorator for creating conditional reactive functions based on observable conditions.</p>"},{"location":"generation/markdown/watch-decorator/#fynx.watch--fynx-watch-conditional-reactive-utilities","title":"FynX Watch - Conditional Reactive Utilities","text":"<p>This module provides the <code>watch</code> decorator for creating conditional reactive computations that only execute when specific conditions are met. Unlike <code>@reactive</code> decorators that run on every change, <code>@watch</code> decorators only trigger when ALL specified conditions transition from unmet to met.</p>"},{"location":"generation/markdown/watch-decorator/#fynx.watch--when-to-use-watch-vs-reactive","title":"When to Use Watch vs Reactive","text":"<p>Use <code>@watch</code> when you need: - Functions that should only run when specific prerequisites are satisfied - State machines that react differently based on application state - Event filtering to avoid unnecessary operations when conditions aren't right - Resource optimization by avoiding computations when not needed</p> <p>Use <code>@reactive</code> when you need: - Functions that should run on every change to their dependencies - Unconditional side effects like logging or UI updates - Immediate responses to any state change</p>"},{"location":"generation/markdown/watch-decorator/#fynx.watch--key-characteristics","title":"Key Characteristics","text":"<ul> <li>Conditional Execution: Only runs when ALL conditions become true after being false</li> <li>Transition Detection: Triggers on false-&gt;true transitions, not ongoing true states</li> <li>Automatic Discovery: Framework finds observables accessed in condition functions</li> <li>Multiple Conditions: Supports AND logic across multiple conditions</li> <li>Error Resilience: Gracefully handles condition evaluation failures</li> </ul>"},{"location":"generation/markdown/watch-decorator/#fynx.watch--basic-usage","title":"Basic Usage","text":"<pre><code>from fynx import observable, watch\n\n# Setup state\nuser_online = observable(False)\nhas_messages = observable(0)\nnotification_enabled = observable(True)\n\n@watch(\n    lambda: user_online.value,           # User must be online\n    lambda: has_messages.value &gt; 0,      # Must have messages\n    lambda: notification_enabled.value   # Notifications must be enabled\n)\ndef send_notification():\n    print(f\"\ud83d\udcec Sending {has_messages.value} messages to user!\")\n\n# Only triggers when ALL conditions become true\nuser_online.set(True)        # Not yet (no messages)\nhas_messages.set(3)          # Not yet (notifications disabled)\nnotification_enabled.set(True)  # Now triggers: \"\ud83d\udcec Sending 3 messages to user!\"\n\nhas_messages.set(5)          # Triggers again: \"\ud83d\udcec Sending 5 messages to user!\"\nuser_online.set(False)       # Stop triggering\nhas_messages.set(10)         # No trigger (user offline)\n</code></pre>"},{"location":"generation/markdown/watch-decorator/#fynx.watch--advanced-patterns","title":"Advanced Patterns","text":""},{"location":"generation/markdown/watch-decorator/#fynx.watch--complex-conditions","title":"Complex Conditions","text":"<p>Conditions can be arbitrarily complex expressions:</p> <pre><code>temperature = observable(20)\nhumidity = observable(50)\nac_enabled = observable(True)\n\n@watch(\n    lambda: temperature.value &gt; 25,              # Hot enough\n    lambda: humidity.value &lt; 60,                 # Not too humid\n    lambda: ac_enabled.value,                    # AC is enabled\n    lambda: temperature.value &lt; 30 or humidity.value &lt; 40  # Either very hot OR very dry\n)\ndef activate_cooling():\n    print(\"\ud83c\udf21\ufe0f Activating air conditioning!\")\n</code></pre>"},{"location":"generation/markdown/watch-decorator/#fynx.watch--state-machines","title":"State Machines","text":"<p>Use watch decorators to implement state machine transitions:</p> <pre><code>app_state = observable(\"loading\")\nuser_authenticated = observable(False)\ndata_loaded = observable(False)\n\n@watch(lambda: app_state.value == \"loading\")\ndef show_loading_screen():\n    print(\"\u23f3 Showing loading screen...\")\n\n@watch(\n    lambda: user_authenticated.value,\n    lambda: data_loaded.value,\n    lambda: app_state.value == \"ready\"\n)\ndef show_main_app():\n    print(\"\u2705 Showing main application!\")\n\n# State transitions\napp_state.set(\"authenticating\")\nuser_authenticated.set(True)\napp_state.set(\"loading_data\")\ndata_loaded.set(True)\napp_state.set(\"ready\")  # Now triggers show_main_app()\n</code></pre>"},{"location":"generation/markdown/watch-decorator/#fynx.watch--resource-management","title":"Resource Management","text":"<p>Prevent unnecessary operations when resources aren't available:</p> <pre><code>network_available = observable(True)\nbattery_level = observable(100)\ndata_fresh = observable(False)\n\n@watch(\n    lambda: network_available.value,\n    lambda: battery_level.value &gt; 20,    # Don't sync on low battery\n    lambda: not data_fresh.value         # Only sync when data is stale\n)\ndef sync_data():\n    print(\"\ud83d\udd04 Syncing data...\")\n    # Perform expensive network operation\n    data_fresh.set(True)\n\nnetwork_available.set(False)\nbattery_level.set(15)\ndata_fresh.set(False)  # No sync (battery too low)\n\nbattery_level.set(80)\nnetwork_available.set(True)  # Triggers sync\n</code></pre>"},{"location":"generation/markdown/watch-decorator/#fynx.watch--real-world-examples","title":"Real-World Examples","text":""},{"location":"generation/markdown/watch-decorator/#fynx.watch--user-authentication-flow","title":"User Authentication Flow","text":"<pre><code>login_attempted = observable(False)\ncredentials_valid = observable(False)\ntwo_factor_complete = observable(False)\n\n@watch(\n    lambda: login_attempted.value,\n    lambda: credentials_valid.value,\n    lambda: two_factor_complete.value\n)\ndef grant_access():\n    print(\"\ud83d\udd10 Access granted!\")\n    # Redirect to dashboard, set session, etc.\n\n# Login flow\nlogin_attempted.set(True)\ncredentials_valid.set(True)\ntwo_factor_complete.set(True)  # Access granted\n</code></pre>"},{"location":"generation/markdown/watch-decorator/#fynx.watch--shopping-cart-checkout","title":"Shopping Cart Checkout","text":"<pre><code>cart_items = observable([])\npayment_method = observable(None)\nterms_accepted = observable(False)\n\n@watch(\n    lambda: len(cart_items.value) &gt; 0,\n    lambda: payment_method.value is not None,\n    lambda: terms_accepted.value\n)\ndef enable_checkout():\n    print(\"\ud83d\udcb3 Checkout button enabled!\")\n\ncart_items.set([{\"name\": \"Widget\", \"price\": 10}])\npayment_method.set(\"credit_card\")\nterms_accepted.set(True)  # Checkout now enabled\n</code></pre>"},{"location":"generation/markdown/watch-decorator/#fynx.watch--background-task-management","title":"Background Task Management","text":"<pre><code>task_queue = observable([])\nis_online = observable(True)\nbattery_saving = observable(False)\n\n@watch(\n    lambda: len(task_queue.value) &gt; 0,\n    lambda: is_online.value,\n    lambda: not battery_saving.value  # Don't run background tasks in battery saving mode\n)\ndef process_background_tasks():\n    print(f\"\ud83d\udd04 Processing {len(task_queue.value)} background tasks...\")\n\ntask_queue.set([\"sync\", \"backup\", \"cleanup\"])\nbattery_saving.set(True)     # No processing (battery saving)\nbattery_saving.set(False)    # Now triggers processing\n</code></pre>"},{"location":"generation/markdown/watch-decorator/#fynx.watch--performance-considerations","title":"Performance Considerations","text":"<p>Efficient Evaluation: Conditions are only re-evaluated when their dependencies change</p> <p>Dependency Tracking: Only tracks observables actually accessed in conditions</p> <p>Transition Optimization: Only triggers on condition state changes, not every update</p> <p>Memory Management: Automatic cleanup when watch decorators are no longer needed</p>"},{"location":"generation/markdown/watch-decorator/#fynx.watch--best-practices","title":"Best Practices","text":""},{"location":"generation/markdown/watch-decorator/#fynx.watch--keep-conditions-simple","title":"Keep Conditions Simple","text":"<p>Break complex conditions into simpler, more focused ones:</p> <pre><code># Good: Simple, focused conditions\n@watch(lambda: user.is_authenticated)\ndef load_user_data():\n    pass\n\n@watch(lambda: user.has_premium_plan)\ndef enable_premium_features():\n    pass\n\n# Avoid: Complex condition logic\n@watch(lambda: user.is_authenticated and user.has_premium_plan and not user.is_banned)\ndef handle_premium_user():\n    pass\n</code></pre>"},{"location":"generation/markdown/watch-decorator/#fynx.watch--use-descriptive-condition-names","title":"Use Descriptive Condition Names","text":"<p>Make conditions self-documenting:</p> <pre><code>def user_is_eligible():\n    return user.age &gt;= 18 and user.country in ALLOWED_COUNTRIES\n\ndef payment_is_complete():\n    return payment.status == \"completed\" and payment.amount &gt; 0\n\n@watch(user_is_eligible, payment_is_complete)\ndef process_purchase():\n    pass\n</code></pre>"},{"location":"generation/markdown/watch-decorator/#fynx.watch--handle-errors-gracefully","title":"Handle Errors Gracefully","text":"<p>Conditions that fail during evaluation are treated as False:</p> <pre><code>@watch(\n    lambda: user.preferences is not None,  # Safe null check\n    lambda: user.preferences.get(\"notifications\", False)  # Safe dict access\n)\ndef send_notification():\n    pass\n</code></pre>"},{"location":"generation/markdown/watch-decorator/#fynx.watch--common-patterns","title":"Common Patterns","text":"<p>Feature Flags: <pre><code>feature_enabled = observable(False)\nuser_has_access = observable(False)\n\n@watch(lambda: feature_enabled.value and user_has_access.value)\ndef enable_new_feature():\n    print(\"\u2728 New feature enabled!\")\n</code></pre></p> <p>Data Validation: <pre><code>email = observable(\"\")\npassword = observable(\"\")\n\n@watch(\n    lambda: \"@\" in email.value and \".\" in email.value.split(\"@\")[1],\n    lambda: len(password.value) &gt;= 8\n)\ndef enable_submit_button():\n    print(\"\u2705 Submit button enabled\")\n</code></pre></p> <p>Resource Availability: <pre><code>network_online = observable(True)\ndisk_space = observable(100)\n\n@watch(\n    lambda: network_online.value,\n    lambda: disk_space.value &gt; 10  # GB\n)\ndef start_download():\n    print(\"\ud83d\udce5 Starting download...\")\n</code></pre></p>"},{"location":"generation/markdown/watch-decorator/#fynx.watch--limitations","title":"Limitations","text":"<ul> <li>Conditions must be synchronous (no async/await)</li> <li>Only triggers on false-&gt;true transitions (not during sustained true states)</li> <li>Cannot create circular dependencies with watched observables</li> <li>Condition evaluation failures are treated as False</li> </ul>"},{"location":"generation/markdown/watch-decorator/#fynx.watch--troubleshooting","title":"Troubleshooting","text":"<p>Watch function not triggering: Ensure all observables accessed in conditions are properly tracked</p> <pre><code># Wrong: External observable not tracked\nexternal_flag = observable(True)\n@watch(lambda: some_obs.value &gt; 0)\ndef wrong_func():\n    if external_flag.value:  # Not tracked!\n        pass\n\n# Right: Include all dependencies in conditions\n@watch(\n    lambda: some_obs.value &gt; 0,\n    lambda: external_flag.value\n)\ndef right_func():\n    pass\n</code></pre> <p>Unexpected triggering: Remember watch only triggers on transitions, not sustained states</p> <p>Performance issues: Simplify complex conditions or break them into multiple watches</p>"},{"location":"generation/markdown/watch-decorator/#fynx.watch--comparison-with-reactive","title":"Comparison with Reactive","text":"Feature @reactive @watch Execution Every change Condition transitions only Use case Side effects Conditional logic Granularity Fine-grained Coarse-grained Performance Higher overhead Lower overhead Complexity Simple More complex"},{"location":"generation/markdown/watch-decorator/#fynx.watch--see-also","title":"See Also","text":"<ul> <li><code>fynx.reactive</code>: Unconditional reactive functions</li> <li><code>fynx.computed</code>: Derived reactive values</li> <li><code>fynx.store</code>: Reactive state containers</li> <li><code>fynx.observable</code>: Core observable classes</li> </ul>"},{"location":"generation/markdown/watch-decorator/#fynx.watch.watch","title":"watch","text":"<pre><code>watch(*conditions)\n</code></pre> <p>Decorator for conditional reactive functions that run only when conditions are met.</p> <p>The <code>watch</code> decorator creates a reactive function that only executes when ALL specified conditions become true, after previously being false. This enables guarded reactions that wait for specific state combinations before triggering.</p> <p>The decorator automatically discovers which observables are accessed within the condition functions and sets up the appropriate subscriptions. When any of these observables change, the conditions are re-evaluated, and the decorated function runs only if this represents a transition from \"not all conditions met\" to \"all conditions met\".</p> <p>Parameters:</p> Name Type Description Default <code>*conditions</code> <p>Variable number of condition functions. Each condition should be         a callable that returns a boolean value. Condition functions can         access observable values via <code>.value</code> attribute. All conditions         must return <code>True</code> for the decorated function to execute.</p> <code>()</code> <p>Returns:</p> Type Description <code>Callable</code> <p>A decorator function that can be applied to reactive functions.</p> <p>Examples: ```python from fynx import observable, watch</p> <pre><code># Basic conditional reaction\nuser_logged_in = observable(False)\ndata_loaded = observable(False)\n\n@watch(\n    lambda: user_logged_in.value,\n    lambda: data_loaded.value\n)\ndef show_dashboard():\n    print(\"Welcome to your dashboard!\")\n\n# Only shows when both conditions are true\nuser_logged_in.set(True)  # Not yet (data not loaded)\ndata_loaded.set(True)     # Now shows dashboard!\n\n# State-based reactions\napp_state = observable(\"loading\")\nerror_count = observable(0)\n\n@watch(\n    lambda: app_state.value == \"error\",\n    lambda: error_count.value &gt;= 3\n)\ndef show_error_recovery():\n    print(\"Too many errors - showing recovery options\")\n\n# Advanced conditions with computations\ntemperature = observable(20)\nhumidity = observable(50)\n\n@watch(\n    lambda: temperature.value &gt; 30,\n    lambda: humidity.value &lt; 30\n)\ndef activate_cooling():\n    print(\"Hot and dry - activating cooling system!\")\n\n# Conditions can be complex expressions\n@watch(lambda: temperature.value &lt; 0 or temperature.value &gt; 40)\ndef extreme_temperature_alert():\n    print(\"Extreme temperature detected!\")\n```\n</code></pre> Note <ul> <li>Condition functions should be pure and relatively fast</li> <li>The decorated function only runs on the transition from conditions not being   met to conditions being met (not on every change while conditions remain true)</li> <li>If condition evaluation fails during discovery or runtime, it's treated as False</li> <li>Observables accessed in conditions are automatically tracked as dependencies</li> </ul> See Also <p>reactive: For unconditional reactive functions computed: For derived reactive values</p>"},{"location":"specs/v1.0-roadmap/","title":"Fynx Observable System - Product Specification for 1.0","text":"<p>Below is the roadmap for FynX. This represents what we believe is necessary for v1.0.0, but it is not set in stone \u2014 we welcome feedback and anticipate that the roadmap may evolve as we learn more and incorporate new ideas.</p>"},{"location":"specs/v1.0-roadmap/#1-overview","title":"1. Overview","text":"<p>A reactive observable system providing type-safe, composable primitives for finite state management and infinite stream processing with Pythonic operator semantics. Features deterministic concurrency handling through serialized propagation.</p>"},{"location":"specs/v1.0-roadmap/#2-concurrency-model-threading-behavior","title":"2. Concurrency Model &amp; Threading Behavior","text":""},{"location":"specs/v1.0-roadmap/#21-serialized-propagation-architecture","title":"2.1 Serialized Propagation Architecture","text":"<p>Description: All observables use an internal emission queue to ensure deterministic, race-free propagation regardless of emission source (sync thread, async coroutine, or background thread).</p> <p>Core Mechanism:</p> <ol> <li>Each observable (or the global system) maintains an internal emission queue</li> <li>Any emission (via <code>obs &lt;&lt; value</code>, assignment <code>obs = value</code>, or merged sources) enqueues the value</li> <li>A single propagation worker consumes the queue sequentially</li> <li>The worker recalculates derived observables, applies filters, and notifies subscribers in queue order</li> <li>Worker can be a dedicated thread or the current thread in single-threaded contexts</li> </ol> <p>Acceptance Criteria:</p> <ul> <li>[ ] All emissions are enqueued, never propagated directly on caller thread</li> <li>[ ] Propagation worker processes emissions sequentially in enqueue order</li> <li>[ ] Concurrent pushes from multiple threads/coroutines are serialized automatically</li> <li>[ ] No race conditions possible: subscribers never observe partial updates</li> <li>[ ] Merge order (<code>a @ b @ c</code>) determines transformation argument order deterministically</li> <li>[ ] Left-to-right evaluation: <code>(a @ b) @ c</code> processes <code>a</code>, then <code>b</code>, then <code>c</code> emissions in queue order</li> </ul>"},{"location":"specs/v1.0-roadmap/#22-thread-safe-enqueueing","title":"2.2 Thread-Safe Enqueueing","text":"<p>Open Questions: * What is the non-sugar api for this?</p> <p>Acceptance Criteria:</p> <ul> <li>[ ] Push operations (<code>&lt;&lt;</code>, assignment) are thread-safe</li> <li>[ ] Uses thread-safe queue implementation (<code>queue.Queue</code> or equivalent with locks)</li> <li>[ ] Multiple threads can emit concurrently without coordination</li> <li>[ ] Enqueue operation returns immediately (non-blocking for caller)</li> <li>[ ] Propagation happens asynchronously on worker thread/context</li> </ul> <p>Example:</p> <pre><code>stream = InfiniteObservable()\n\n# Thread 1\nstream &lt;&lt; 1\n\n# Thread 2 (concurrent)\nstream &lt;&lt; 2\n\n# Both enqueued safely; propagated sequentially in arrival order\n</code></pre>"},{"location":"specs/v1.0-roadmap/#23-asyncawait-integration","title":"2.3 Async/Await Integration","text":"<p>Acceptance Criteria:</p> <ul> <li>[ ] Supports <code>asyncio</code> integration via <code>asyncio.Queue</code> for propagation</li> <li>[ ] Sync context emissions use <code>loop.call_soon_threadsafe()</code> to enqueue</li> <li>[ ] Async context emissions can directly await queue operations</li> <li>[ ] Propagation coroutine processes emissions sequentially</li> <li>[ ] Users can emit from sync or async contexts transparently</li> <li>[ ] Subscribers can be sync or async callbacks (system handles both)</li> </ul> <p>Example:</p> <pre><code># Sync emission (from any thread)\nstream &lt;&lt; value  # Internally uses call_soon_threadsafe if async loop active\n\n# Async emission\nasync def process():\n    stream &lt;&lt; await fetch_data()\n\n# Async subscriber\nasync def async_handler(value):\n    await save_to_db(value)\n\nstream.subscribe(async_handler)  # System detects async and handles appropriately\n</code></pre>"},{"location":"specs/v1.0-roadmap/#24-propagation-guarantees","title":"2.4 Propagation Guarantees","text":"<p>Acceptance Criteria:</p> <ul> <li>[ ] Deterministic ordering: Emissions processed in exact enqueue order</li> <li>[ ] Atomic propagation: Each emission propagates completely before next emission starts</li> <li>[ ] No race conditions: Derived observables never see partial/inconsistent state</li> <li>[ ] Subscriber safety: All subscribers receive same value in same propagation cycle</li> <li>[ ] Single propagation per emission: Each emission triggers exactly one propagation pass</li> <li>[ ] Merge consistency: Left-to-right merge order preserved across all propagations</li> </ul> <p>Example:</p> <pre><code>a = observable(1)\nb = observable(2)\nmerged = a @ b\nresult = merged &gt;&gt; (lambda x, y: x + y)  # x from a, y from b (deterministic)\n\n# Thread 1\na = 10\n\n# Thread 2 (concurrent)\nb = 20\n\n# Result sees either (10, 2) or (1, 20) or (10, 20)\n# Never partial like (10, &lt;uninitialized&gt;)\n# Order determined by queue arrival, but always consistent\n</code></pre>"},{"location":"specs/v1.0-roadmap/#25-performance-considerations","title":"2.5 Performance Considerations","text":"<p>Latency:</p> <ul> <li>[ ] Slight overhead vs direct synchronous propagation (typically microseconds)</li> <li>[ ] Negligible for most applications</li> <li>[ ] Configurable queue processing batch size for high-throughput scenarios</li> </ul> <p>Backpressure:</p> <ul> <li>[ ] Optional max queue size to prevent unbounded memory growth</li> <li>[ ] Configurable overflow strategies: block, drop oldest, drop newest, raise error</li> <li>[ ] Monitoring API for queue depth inspection</li> </ul> <p>Example:</p> <pre><code># Configure backpressure (optional)\nstream = InfiniteObservable(max_queue_size=1000, overflow='drop_oldest')\n\n# Monitor queue health\nif stream.queue_depth() &gt; 900:\n    warnings.warn(\"Observable queue near capacity\")\n</code></pre>"},{"location":"specs/v1.0-roadmap/#26-user-experience","title":"2.6 User Experience","text":"<p>Acceptance Criteria:</p> <ul> <li>[ ] No API changes required for threading/async support</li> <li>[ ] System automatically detects execution context (sync/async, thread)</li> <li>[ ] Users never need to manage locks, mutexes, or async context explicitly</li> <li>[ ] Standard operators (<code>&lt;&lt;</code>, <code>=</code>, <code>&gt;&gt;</code>, <code>@</code>) work identically regardless of threading</li> <li>[ ] Subscribers always see sequential, deterministic updates</li> <li>[ ] Optional configuration for advanced use cases (queue size, worker threads)</li> </ul> <p>Example:</p> <pre><code># Works identically in all contexts\nstream &lt;&lt; value  # Sync thread\nstream &lt;&lt; value  # Async coroutine\nstream &lt;&lt; value  # Background thread\n\n# User never sees:\n# - Race conditions\n# - Partial updates\n# - Lock/mutex management\n# - async/await complexity (unless desired)\n</code></pre>"},{"location":"specs/v1.0-roadmap/#3-core-observable-types","title":"3. Core Observable Types","text":""},{"location":"specs/v1.0-roadmap/#31-genericobservable-base-type","title":"3.1 GenericObservable (Base Type)","text":"<p>Description: Abstract supertype for all observable types. Provides common interface and enables polymorphic operations across all observable subtypes.</p> <p>Acceptance Criteria:</p> <ul> <li>[ ] All observable types inherit from <code>GenericObservable</code></li> <li>[ ] All operators (<code>&gt;&gt;</code>, <code>@</code>, <code>.where()</code>, <code>.subscribe()</code>) work on <code>GenericObservable</code> instances regardless of concrete subtype</li> <li>[ ] Type system is transparent to users - operations return appropriate concrete types without requiring type-specific logic</li> <li>[ ] Generic observables can be composed with any other generic observable using standard operators</li> <li>[ ] Runtime type determination follows documented promotion rules (e.g., Finite + Infinite \u2192 Infinite)</li> <li>[ ] All emissions go through serialized propagation queue (see Section 2)</li> </ul>"},{"location":"specs/v1.0-roadmap/#32-finiteobservable","title":"3.2 FiniteObservable <p>Description: Single-valued reactive cell holding current value from discrete domain with serialized propagation.</p> <p>Acceptance Criteria:</p> <ul> <li>[ ] Holds exactly one value of type <code>T</code> at any moment</li> <li>[ ] Assignment enqueues value for propagation (not direct synchronous)</li> <li>[ ] Can be created via <code>observable(initial_value)</code> factory function</li> <li>[ ] Supports <code>obs = new_value</code> assignment syntax (thread-safe)</li> <li>[ ] Reading <code>.value</code> returns current value without triggering propagation</li> <li>[ ] Used as Store class property decorator: <code>property_name = observable(default)</code></li> <li>[ ] All dependent observables recalculate atomically during propagation worker pass</li> <li>[ ] Thread-safe: can be assigned from any thread</li> </ul> <p>Example:</p> <pre><code>counter = observable(5)\ndoubled = counter &gt;&gt; (lambda x: x * 2)\ncounter = 10  # Enqueued; doubled becomes 20 after propagation\n</code></pre>","text":""},{"location":"specs/v1.0-roadmap/#33-infiniteobservable","title":"3.3 InfiniteObservable <p>Description: Unbounded stream of values emitted asynchronously over time with serialized propagation.</p> <p>Acceptance Criteria:</p> <ul> <li>[ ] Maintains sequence of emissions with no defined \u201cfinal\u201d value</li> <li>[ ] Created via <code>InfiniteObservable()</code> constructor</li> <li>[ ] Supports <code>&lt;&lt;</code> push operator: <code>stream &lt;&lt; value</code> (thread-safe)</li> <li>[ ] Supports merging another stream: <code>stream &lt;&lt; other_stream</code></li> <li>[ ] Each emission enqueued and triggers downstream propagation independently</li> <li>[ ] Concurrent emissions are serialized: multiple threads can push simultaneously</li> <li>[ ] Emissions processed in queue arrival order</li> <li>[ ] Can emit zero or more values over lifetime</li> <li>[ ] Can merge with transformed streams: <code>stream &lt;&lt; upload.map(fn)</code></li> <li>[ ] Push operations are non-blocking (return immediately after enqueueing)</li> </ul> <p>Memory Management:</p> <ul> <li>[ ] Subscriptions maintain reference to observable</li> <li>[ ] Unsubscribing releases subscription reference but not observable</li> <li>[ ] Long-lived infinite observables should be explicitly disposed when no longer needed</li> <li>[ ] Consider weak references for subscriber management to prevent memory leaks</li> </ul> <p>Concurrent Emission Example:</p> <pre><code>stream = InfiniteObservable()\n\n# Thread 1\nfor i in range(100):\n    stream &lt;&lt; i\n\n# Thread 2 (concurrent)\nfor i in range(100, 200):\n    stream &lt;&lt; i\n\n# Thread 3 (concurrent)\nfor i in range(200, 300):\n    stream &lt;&lt; i\n\n# All 300 emissions safely enqueued and propagated sequentially\n# Subscribers see values in queue arrival order (deterministic per run)\n</code></pre>","text":""},{"location":"specs/v1.0-roadmap/#34-conditionalobservable","title":"3.4 ConditionalObservable <p>Description: Wrapper that filters emissions from source observable based on predicate with propagation queue integration.</p> <p>Acceptance Criteria:</p> <p>Core Filtering:</p> <ul> <li>[ ] Created via <code>.where(predicate)</code> method on any observable</li> <li>[ ] Predicate signature: <code>T \u2192 Bool</code></li> <li>[ ] Only propagates emissions where <code>predicate(value) == True</code></li> <li>[ ] Predicate evaluation happens in propagation worker context</li> <li>[ ] Preserves source type: <code>FiniteObservable.where()</code> \u2192 <code>FiniteObservable</code></li> <li>[ ] Preserves source type: <code>InfiniteObservable.where()</code> \u2192 <code>InfiniteObservable</code></li> <li>[ ] Thread-safe: source emissions can come from any thread</li> </ul> <p>Finite Source Semantics:</p> <ul> <li>[ ] Evaluates condition during propagation worker pass</li> <li>[ ] Suppresses downstream propagation when condition is <code>False</code></li> <li>[ ] No retroactive evaluation of past assignments</li> </ul> <p>Infinite Source Semantics:</p> <ul> <li>[ ] Acts as stream filter during propagation</li> <li>[ ] Does not affect previously emitted values</li> <li>[ ] Each emission independently evaluated against predicate in worker context</li> </ul> <p>Dynamic Conditions:</p> <ul> <li>[ ] Accepts observable predicates: <code>.where(condition_observable)</code></li> <li>[ ] Gates emissions based on current value of condition observable at propagation time</li> <li>[ ] For finite sources: checks condition during propagation worker pass</li> <li>[ ] For infinite sources: checks condition during propagation of each emission</li> </ul> <p>Composition:</p> <ul> <li>[ ] Chained <code>.where()</code> calls compose with AND logic</li> <li>[ ] <code>source.where(P1).where(P2)</code> equivalent to <code>source.where(lambda x: P1(x) and P2(x))</code></li> <li>[ ] Derived observables inherit conditional propagation</li> </ul> <p>Example:</p> <pre><code>stream = InfiniteObservable()\nevens = stream.where(lambda x: x % 2 == 0)\n\n# Thread-safe concurrent pushes\nstream &lt;&lt; 1  # suppressed during propagation\nstream &lt;&lt; 2  # evens emits 2 during propagation\nstream &lt;&lt; 3  # suppressed\nstream &lt;&lt; 4  # evens emits 4\n\ncondition = observable(True)\ngated = stream.where(condition)  # Checks condition at propagation time\n</code></pre>","text":""},{"location":"specs/v1.0-roadmap/#35-mergedobservable","title":"3.5 MergedObservable <p>Description: Unified emission stream combining multiple source observables with deterministic propagation order.</p> <p>Acceptance Criteria:</p> <p>Core Merging:</p> <ul> <li>[ ] Created via <code>@</code> operator: <code>obs1 @ obs2 @ obs3</code></li> <li>[ ] Accepts 2+ source observables of same type <code>T</code></li> <li>[ ] Emits union of all source emissions: <code>\u22c3\u1d62 emissions(s\u1d62)</code></li> <li>[ ] Merge order is deterministic and left-to-right: <code>(a @ b) @ c</code> always processes <code>a</code>, then <code>b</code>, then <code>c</code></li> <li>[ ] Interleaves emissions in queue arrival order (within propagation worker)</li> <li>[ ] Concurrent emissions from different sources serialized by propagation queue</li> </ul> <p>Type Determination:</p> <ul> <li>[ ] All finite sources \u2192 <code>FiniteObservable&lt;T&gt;</code></li> <li>[ ] All infinite sources \u2192 <code>InfiniteObservable&lt;T&gt;</code></li> <li>[ ] Mixed finite + infinite \u2192 <code>InfiniteObservable&lt;T&gt;</code> (most dynamic type wins)</li> </ul> <p>Finite Source Behavior:</p> <ul> <li>[ ] Each source assignment enqueued for propagation</li> <li>[ ] Merged result emits during propagation pass</li> <li>[ ] Sequential assignments preserve per-source ordering in queue</li> </ul> <p>Infinite Source Behavior:</p> <ul> <li>[ ] Each emission enqueued independently</li> <li>[ ] Emissions interleaved in queue arrival order</li> <li>[ ] Thread-safe: sources can emit from different threads concurrently</li> </ul> <p>Mixed Source Behavior:</p> <ul> <li>[ ] Finite sources contribute current value snapshot during propagation</li> <li>[ ] Infinite sources contribute ongoing emissions via queue</li> <li>[ ] Result exhibits both discrete and continuous characteristics</li> </ul> <p>Edge Cases:</p> <ul> <li>[ ] Empty merge <code>MergedObservable()</code> with no sources raises <code>ValueError</code></li> <li>[ ] Single source merge <code>MergedObservable(s)</code> returns identity (equivalent to <code>s</code>)</li> </ul> <p>Algebraic Properties:</p> <ul> <li>[ ] Identity: <code>MergedObservable(s) \u2261 s</code></li> <li>[ ] Associativity: <code>(a @ b) @ c \u2261 a @ (b @ c)</code></li> <li>[ ] Type closure: Result is always an observable</li> <li>[ ] Deterministic ordering: merge order determines transformation argument order (guaranteed by propagation queue)</li> </ul> <p>Concurrent Emission Example:</p> <pre><code>stream1 = InfiniteObservable()\nstream2 = InfiniteObservable()\nmerged = stream1 @ stream2\n\n# Thread 1\nstream1 &lt;&lt; \"A1\"\nstream1 &lt;&lt; \"A2\"\n\n# Thread 2 (concurrent)\nstream2 &lt;&lt; \"B1\"\nstream2 &lt;&lt; \"B2\"\n\n# Propagation worker sees queue like: [A1, B1, A2, B2] (example order)\n# Subscribers see deterministic sequence based on queue arrival\n# Transform receives arguments in merge order (stream1 first, stream2 second)\n\nresult = merged &gt;&gt; (lambda v1, v2: f\"{v1}+{v2}\")\n# v1 always from stream1, v2 always from stream2 (deterministic merge order)\n</code></pre>","text":""},{"location":"specs/v1.0-roadmap/#4-operators","title":"4. Operators","text":""},{"location":"specs/v1.0-roadmap/#41-transform-operator","title":"4.1 Transform Operator (<code>&gt;&gt;</code>) <p>Description: Creates derived observable by applying transformation function during propagation. Never mutates source observable.</p> <p>Acceptance Criteria:</p> <ul> <li>[ ] Signature: <code>Observable&lt;T&gt; &gt;&gt; (T \u2192 U) \u2192 Observable&lt;U&gt;</code></li> <li>[ ] Works on <code>GenericObservable</code> regardless of concrete type</li> <li>[ ] Always creates new observable; source remains unchanged</li> <li>[ ] Derived observable recalculates during propagation worker pass</li> <li>[ ] Supports chaining: <code>obs &gt;&gt; f &gt;&gt; g &gt;&gt; h</code></li> <li>[ ] Lazy evaluation: computes only during propagation pass</li> <li>[ ] Type preservation: Finite \u2192 Finite, Infinite \u2192 Infinite</li> <li>[ ] Multi-argument functions receive values in merge order (deterministic, left-to-right, guaranteed by propagation queue)</li> <li>[ ] Chained transformations compose left-to-right</li> <li>[ ] Transformation function called once per emission/update during propagation</li> <li>[ ] Thread-safe: source emissions can originate from any thread</li> </ul> <p>Example:</p> <pre><code>result = counter &gt;&gt; (lambda x: x * 2) &gt;&gt; (lambda x: x + 10)\n# counter unchanged; result is new observable\n# Transformation happens in propagation worker\n\ntotal = (count @ price) &gt;&gt; (lambda c, p: c * p)\n# c=count, p=price (merge order, deterministic even with concurrent updates)\n</code></pre>","text":""},{"location":"specs/v1.0-roadmap/#42-merge-operator","title":"4.2 Merge Operator (<code>@</code>) <p>Description: Combines multiple observables into unified stream with deterministic propagation order.</p> <p>Acceptance Criteria:</p> <ul> <li>[ ] Signature: <code>Observable&lt;T&gt; @ Observable&lt;T&gt; \u2192 MergedObservable&lt;T&gt;</code></li> <li>[ ] Works on <code>GenericObservable</code> instances</li> <li>[ ] Accepts 2+ operands: <code>a @ b @ c</code></li> <li>[ ] Associative: <code>(a @ b) @ c \u2261 a @ (b @ c)</code></li> <li>[ ] Deterministic left-to-right merge order preserved for downstream transformations (guaranteed by propagation queue)</li> <li>[ ] Result type follows type determination rules (section 3.5)</li> <li>[ ] Can be chained with <code>&gt;&gt;</code>: <code>(a @ b) &gt;&gt; transform_fn</code></li> <li>[ ] Raises <code>ValueError</code> if called with zero operands</li> <li>[ ] Thread-safe: operands can emit from different threads concurrently</li> </ul> <p>Example:</p> <pre><code>combined = obs1 @ obs2 @ obs3\nresult = combined &gt;&gt; (lambda v1, v2, v3: v1 + v2 + v3)\n# v1=obs1, v2=obs2, v3=obs3 (deterministic merge order)\n# Works correctly even if obs1, obs2, obs3 updated from different threads\n</code></pre>","text":""},{"location":"specs/v1.0-roadmap/#43-filter-method-where","title":"4.3 Filter Method (<code>.where()</code>) <p>Description: Creates conditional observable filtering emissions during propagation.</p> <p>Acceptance Criteria:</p> <ul> <li>[ ] Signature: <code>Observable&lt;T&gt;.where(T \u2192 Bool) \u2192 ConditionalObservable&lt;T&gt;</code></li> <li>[ ] Signature (dynamic): <code>Observable&lt;T&gt;.where(Observable&lt;Bool&gt;) \u2192 ConditionalObservable&lt;T&gt;</code></li> <li>[ ] Works on <code>GenericObservable</code></li> <li>[ ] Returns <code>ConditionalObservable</code> preserving source type (Finite/Infinite)</li> <li>[ ] Chainable: <code>obs.where(p1).where(p2)</code> applies AND logic</li> <li>[ ] Can be combined with other operators: <code>obs.where(pred) &gt;&gt; transform</code></li> <li>[ ] Predicate evaluation happens in propagation worker context</li> <li>[ ] Thread-safe: source can emit from any thread</li> </ul> <p>Example:</p> <pre><code>positives = counter.where(lambda x: x &gt; 0)\nevens = stream.where(lambda x: x % 2 == 0)\nfiltered = obs.where(p1).where(p2) &gt;&gt; transform\n# All predicates evaluated during propagation worker pass\n</code></pre>","text":""},{"location":"specs/v1.0-roadmap/#44-push-operator","title":"4.4 Push Operator (<code>&lt;&lt;</code>) <p>Description: Thread-safe emission into infinite observable stream via propagation queue.</p> <p>Acceptance Criteria:</p> <ul> <li>[ ] Signature: <code>InfiniteObservable&lt;T&gt; &lt;&lt; T \u2192 None</code></li> <li>[ ] Signature (merge): <code>InfiniteObservable&lt;T&gt; &lt;&lt; Observable&lt;T&gt; \u2192 None</code></li> <li>[ ] Only valid for <code>InfiniteObservable</code> instances</li> <li>[ ] Pushes single value: <code>stream &lt;&lt; value</code> (enqueues for propagation)</li> <li>[ ] Merges another observable: <code>stream &lt;&lt; other_observable</code></li> <li>[ ] Thread-safe: can be called from any thread concurrently</li> <li>[ ] Non-blocking: returns immediately after enqueueing</li> <li>[ ] Triggers downstream propagation during worker pass</li> <li>[ ] Returns <code>None</code> (side-effect only)</li> </ul> <p>Example:</p> <pre><code>stream &lt;&lt; 42  # Thread-safe, enqueued\nstream &lt;&lt; (upload &gt;&gt; process)  # Merge enqueued\n\n# Concurrent pushes (safe)\nthreading.Thread(target=lambda: stream &lt;&lt; 1).start()\nthreading.Thread(target=lambda: stream &lt;&lt; 2).start()\n# Both enqueued; propagated sequentially by worker\n</code></pre>","text":""},{"location":"specs/v1.0-roadmap/#45-subscribe-method-subscribe","title":"4.5 Subscribe Method (<code>.subscribe()</code>) <p>Description: Registers callback to react to observable changes during propagation.</p> <p>Acceptance Criteria:</p> <ul> <li>[ ] Signature: <code>Observable&lt;T&gt;.subscribe(T \u2192 None) \u2192 Subscription</code></li> <li>[ ] Works on <code>GenericObservable</code></li> <li>[ ] Callback invoked during propagation worker pass for each emission/update</li> <li>[ ] Returns subscription object for unsubscription</li> <li>[ ] Subscription has <code>.unsubscribe()</code> method</li> <li>[ ] Multiple subscribers supported per observable</li> <li>[ ] Callbacks receive current/emitted value as argument</li> <li>[ ] Callbacks execute in propagation worker context (thread-safe by design)</li> <li>[ ] All subscribers see same value in same propagation cycle (no races)</li> </ul> <p>Memory Management:</p> <ul> <li>[ ] Subscription maintains reference to observable and callback</li> <li>[ ] Calling <code>.unsubscribe()</code> releases callback reference</li> <li>[ ] Observable maintains weak references to subscriptions where possible</li> <li>[ ] Unsubscribing does not dispose the observable itself</li> <li>[ ] Subscribers should explicitly unsubscribe when done to prevent memory leaks</li> </ul> <p>Example:</p> <pre><code>subscription = obs.subscribe(lambda x: print(f\"Value: {x}\"))\n# Callback invoked in propagation worker context (safe)\n\nsubscription.unsubscribe()  # Release callback reference\n</code></pre>","text":""},{"location":"specs/v1.0-roadmap/#5-booleancomparison-operators","title":"5. Boolean/Comparison Operators","text":""},{"location":"specs/v1.0-roadmap/#51-boolean-logic-operators","title":"5.1 Boolean Logic Operators <p>Description: Native boolean operations on observables producing reactive boolean results with propagation queue semantics.</p> <p>Acceptance Criteria:</p> <ul> <li>[ ] <code>&amp;</code> operator: <code>obs1 &amp; obs2</code> returns observable evaluating AND during propagation</li> <li>[ ] <code>|</code> operator: <code>obs1 | obs2</code> returns observable evaluating OR during propagation (distinct from merge <code>@</code>)</li> <li>[ ] <code>~</code> operator: <code>~obs</code> returns observable negating value during propagation</li> <li>[ ] Operators work element-wise on current values at propagation time</li> <li>[ ] For finite sources: produces <code>FiniteObservable&lt;bool&gt;</code></li> <li>[ ] For infinite sources: produces stream of boolean evaluations per emission</li> <li>[ ] Results are fully reactive: update during propagation when any operand changes</li> <li>[ ] Works on <code>GenericObservable</code> instances</li> <li>[ ] Thread-safe: operands can be updated from different threads</li> </ul> <p>Mixed Type Behavior:</p> <ul> <li>[ ] <code>FiniteObservable&lt;bool&gt; &amp; InfiniteObservable&lt;bool&gt;</code> \u2192 <code>InfiniteObservable&lt;bool&gt;</code></li> <li>[ ] Finite operand provides current value snapshot; infinite operand drives emission timing</li> <li>[ ] Result emits on each infinite stream emission, using latest finite value at propagation time</li> </ul> <p>Example:</p> <pre><code>ready = uploaded &amp; valid &amp; (~processing)\nany_active = stream1 | stream2  # Boolean OR, not merge\n# All evaluations happen in propagation worker (thread-safe)\n</code></pre>","text":""},{"location":"specs/v1.0-roadmap/#52-comparison-operators","title":"5.2 Comparison Operators <p>Description: Comparison operators for observables returning reactive boolean observables with propagation semantics.</p> <p>Acceptance Criteria:</p> <ul> <li>[ ] Supports: <code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code></li> <li>[ ] Signature: <code>Observable&lt;T&gt; {op} T \u2192 Observable&lt;bool&gt;</code></li> <li>[ ] Signature: <code>Observable&lt;T&gt; {op} Observable&lt;T&gt; \u2192 Observable&lt;bool&gt;</code></li> <li>[ ] Returns reactive boolean observable</li> <li>[ ] Evaluates comparison during propagation worker pass</li> <li>[ ] Works with <code>@watch</code> decorator and standalone</li> <li>[ ] Works on <code>GenericObservable</code></li> <li>[ ] Thread-safe: operands can be updated from different threads</li> </ul> <p>Mixed Type Behavior:</p> <ul> <li>[ ] <code>FiniteObservable&lt;T&gt; &gt;= InfiniteObservable&lt;T&gt;</code> \u2192 <code>InfiniteObservable&lt;bool&gt;</code></li> <li>[ ] <code>InfiniteObservable&lt;T&gt; &gt;= FiniteObservable&lt;T&gt;</code> \u2192 <code>InfiniteObservable&lt;bool&gt;</code></li> <li>[ ] Finite operand provides current value snapshot at propagation time</li> <li>[ ] Infinite operand drives emission timing</li> <li>[ ] Each emission from infinite side triggers comparison with latest finite value during propagation</li> <li>[ ] <code>FiniteObservable&lt;T&gt; &gt;= FiniteObservable&lt;T&gt;</code> \u2192 <code>FiniteObservable&lt;bool&gt;</code> (updates when either changes)</li> <li>[ ] <code>InfiniteObservable&lt;T&gt; &gt;= InfiniteObservable&lt;T&gt;</code> \u2192 <code>InfiniteObservable&lt;bool&gt;</code> (emits when either emits)</li> </ul> <p>Example:</p> <pre><code>is_adult = age &gt;= 18\nis_equal = obs1 == obs2\nmatches = name == \"Alice\"\n\n# Mixed types\nexceeded = infinite_sensor &gt;= finite_threshold  # InfiniteObservable&lt;bool&gt;\n# Comparison happens in propagation worker using latest finite_threshold value\n</code></pre>","text":""},{"location":"specs/v1.0-roadmap/#6-decorator-watch","title":"6. Decorator: <code>@watch</code>","text":"<p>Description: Executes function when all condition observables evaluate to <code>True</code> during propagation. Triggers on every emission/update that satisfies all conditions.</p> <p>Acceptance Criteria:</p> <ul> <li>[ ] Signature: <code>@watch(condition1, condition2, ...) def fn(): ...</code></li> <li>[ ] Accepts multiple condition observables/lambdas</li> <li>[ ] Conditions are lambda expressions returning observables: <code>lambda: age &gt;= 18</code></li> <li>[ ] Lambdas evaluated reactively during propagation: re-evaluates whenever any observable referenced inside changes</li> <li>[ ] Executes function when ALL conditions are <code>True</code> during propagation worker pass</li> <li>[ ] Triggers once per emission/update that satisfies all conditions (no debouncing by default)</li> <li>[ ] Re-evaluates reactively during propagation when any condition observable changes</li> <li>[ ] Supports boolean/comparison operators in conditions</li> <li>[ ] Does not require observables to be used exclusively in <code>@watch</code> context</li> <li>[ ] Each condition lambda may reference multiple observables; any change triggers re-evaluation during propagation</li> <li>[ ] Thread-safe: conditions evaluated in propagation worker context, safe from races</li> </ul> <p>Execution Semantics:</p> <ul> <li>[ ] Function executes in propagation worker context when conditions become <code>True</code></li> <li>[ ] No automatic debouncing or coalescing (user can implement if needed)</li> <li>[ ] If multiple observables change concurrently, executes once during propagation with latest values</li> </ul> <p>Example:</p> <pre><code>@watch(lambda: User.age &gt;= 18, lambda: User.email.endswith('.com'))\ndef process_eligible_user():\n    print(\"Eligible user detected!\")\n# Triggers during propagation when conditions become True\n# Safe even if User.age and User.email updated from different threads\n\n@watch(lambda: (sensor_reading &gt; threshold) &amp; sensor_active)\ndef alert():\n    print(\"Alert!\")\n# Triggers during propagation on each emission where condition is True\n# Evaluation happens in propagation worker (thread-safe)\n</code></pre>"},{"location":"specs/v1.0-roadmap/#7-operator-summary-table","title":"7. Operator Summary Table","text":"Operator Signature Description Example <code>&gt;&gt;</code> <code>Observable&lt;T&gt; &gt;&gt; (T \u2192 U) \u2192 Observable&lt;U&gt;</code> Transform values (creates new observable) <code>doubled = x &gt;&gt; (lambda v: v * 2)</code> <code>@</code> <code>Observable&lt;T&gt; @ Observable&lt;T&gt; \u2192 MergedObservable&lt;T&gt;</code> Merge observables (deterministic order) <code>combined = a @ b</code> <code>.where()</code> <code>Observable&lt;T&gt;.where(T \u2192 Bool) \u2192 ConditionalObservable&lt;T&gt;</code> Filter emissions during propagation <code>pos = x.where(lambda v: v &gt; 0)</code> <code>&lt;&lt;</code> <code>InfiniteObservable&lt;T&gt; &lt;&lt; T \u2192 None</code> Thread-safe push to stream (enqueued) <code>stream &lt;&lt; value</code> <code>.subscribe()</code> <code>Observable&lt;T&gt;.subscribe(T \u2192 None) \u2192 Subscription</code> React to changes during propagation <code>obs.subscribe(print)</code> <code>&amp;</code> <code>Observable&lt;bool&gt; &amp; Observable&lt;bool&gt; \u2192 Observable&lt;bool&gt;</code> Boolean AND (evaluated during propagation) <code>ready = a &amp; b</code> <code>|</code> <code>Observable&lt;bool&gt; | Observable&lt;bool&gt; \u2192 Observable&lt;bool&gt;</code> Boolean OR (evaluated during propagation) <code>any_active = a | b</code> <code>~</code> <code>~Observable&lt;bool&gt; \u2192 Observable&lt;bool&gt;</code> Boolean NOT (evaluated during propagation) <code>inactive = ~active</code> <code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code> <code>Observable&lt;T&gt; {op} T \u2192 Observable&lt;bool&gt;</code> Comparison (evaluated during propagation) <code>adult = age &gt;= 18</code>"},{"location":"specs/v1.0-roadmap/#8-design-principles","title":"8. Design Principles","text":"<p>Acceptance Criteria:</p> <ul> <li>[ ] Type preservation: Operations preserve or predictably promote types per documented rules</li> <li>[ ] Composability: All operators support nesting and chaining</li> <li>[ ] Transparency: Internal taxonomy hidden from users; all operations work on <code>GenericObservable</code></li> <li>[ ] Immutability: Transformations always create new observables; sources never mutated</li> <li>[ ] Determinism: Merge order is left-to-right and consistent; propagation queue ensures sequential processing</li> <li>[ ] Algebraic rigor: Identity, associativity, and type closure properties maintained</li> <li>[ ] Pythonic elegance: Uses familiar Python operators and method chaining</li> <li>[ ] Accessibility: No category theory knowledge required; intuitive semantics</li> <li>[ ] Memory safety: Clear subscription lifecycle; explicit cleanup prevents leaks</li> <li>[ ] Concurrency safety: Serialized propagation queue eliminates race conditions; thread-safe by design</li> <li>[ ] Performance: Minimal latency overhead; configurable backpressure handling</li> </ul>"},{"location":"specs/v1.0-roadmap/#9-full-integration-example","title":"9. Full Integration Example","text":"<p>Acceptance Criteria:</p> <ul> <li>[ ] Following example works end-to-end with all specified features including threading:</li> </ul> <pre><code>class CartStore(Store):\n    item_count = observable(1)\n    price_per_item = observable(10.0)\n    discount_active = observable(False)\n\n# Merge observables (@ operator, deterministic order, thread-safe)\ncart_state = CartStore.item_count @ CartStore.price_per_item\n\n# Calculate subtotal (immutable transform, propagated via queue)\nsubtotal = cart_state &gt;&gt; (lambda count, price: count * price)\n\n# Apply discount conditionally (evaluated during propagation)\nfinal_price = (subtotal @ CartStore.discount_active) &gt;&gt; \\\n    (lambda total, discount: total * 0.9 if discount else total)\n\n# Subscribe to updates (callback runs in propagation worker context)\nsubscription = final_price.subscribe(lambda price: print(f\"Total: ${price:.2f}\"))\n\n# Changes propagate automatically via queue (thread-safe)\nCartStore.item_count = 3           # Enqueued \u2192 Total: $30.00\nCartStore.discount_active = True   # Enqueued \u2192 Total: $27.00\n\n# Thread-safe concurrent updates\nimport threading\nthreading.Thread(target=lambda: CartStore.item_count = 5).start()\nthreading.Thread(target=lambda: CartStore.price_per_item = 15.0).start()\n# Both enqueued; propagated sequentially; final_price sees consistent state\n\n# Cleanup\nsubscription.unsubscribe()\n\n# Boolean operators (| for OR, @ for merge)\npreview_ready = uploaded_file &amp; is_valid &amp; (~is_processing)\nany_error = validation_error | network_error  # Boolean OR\n\n# Mixed type comparisons with concurrent emissions\nsensor_stream = InfiniteObservable()\nthreshold = observable(100)\nalert_stream = sensor_stream &gt;= threshold  # InfiniteObservable&lt;bool&gt;\n\n# Thread-safe concurrent sensor updates\ndef sensor_thread():\n    for reading in sensor_readings:\n        sensor_stream &lt;&lt; reading  # Thread-safe push\n\nthreading.Thread(target=sensor_thread).start()\n\n# Watch decorator (reactive, per-emission trigger, thread-safe)\n@watch(lambda: User.age &gt;= 18, lambda: User.email.endswith('.com'))\ndef process_eligible_user():\n    print(\"Eligible user detected!\")\n# Conditions evaluated in propagation worker (safe from races)\n</code></pre>"},{"location":"specs/v1.0-roadmap/#10-edge-cases-error-handling","title":"10. Edge Cases &amp; Error Handling","text":"<p>Acceptance Criteria:</p> <p>Empty Merge:</p> <ul> <li>[ ] <code>MergedObservable()</code> with no sources raises <code>ValueError</code> with message: \u201cCannot create merge with zero sources\u201d</li> <li>[ ] <code>a @ b @ ...</code> with at least one operand succeeds</li> </ul> <p>Mixed Type Merges:</p> <ul> <li>[ ] <code>FiniteObservable @ InfiniteObservable</code> produces <code>InfiniteObservable</code> (documented in 3.5)</li> <li>[ ] Finite values emit immediately via queue, infinite values emit over time via queue</li> <li>[ ] ConditionalObservable wrapping MergedObservable preserves result type rules</li> </ul> <p>Type Mismatches:</p> <ul> <li>[ ] Merging incompatible types (e.g., <code>Observable&lt;int&gt; @ Observable&lt;str&gt;</code>) raises <code>TypeError</code></li> <li>[ ] Comparison operators require comparable types or raise <code>TypeError</code></li> </ul> <p>Null/None Handling:</p> <ul> <li>[ ] Observables can hold <code>None</code> as valid value</li> <li>[ ] Predicates/transforms receive <code>None</code></li> </ul>"}]}