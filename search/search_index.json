{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"FynX","text":""},{"location":"#fynx-python-reactive-state-management-library","title":"FynX - Python Reactive State Management Library","text":"<p>FynX is a lightweight, transparent reactive state management library for Python, inspired by MobX. It enables reactive programming patterns where state changes automatically propagate through your application, eliminating the need for manual state synchronization.</p>"},{"location":"#what-is-reactive-programming","title":"What is Reactive Programming?","text":"<p>Reactive programming is a paradigm where you declare how your application should respond to changes in data. Instead of manually updating UI elements, API calls, or derived values when data changes, you define relationships between data and let the framework handle the updates automatically.</p> <p>FynX makes reactive programming in Python simple and intuitive - no complex syntax or framework-specific patterns required. Just use regular Python objects and let FynX handle the reactivity behind the scenes.</p>"},{"location":"#core-concepts","title":"Core Concepts","text":"<p>Observables: Values that can be watched for changes. When an observable value changes, all dependent computations and reactions automatically update.</p> <p>Computed Values: Derived values that automatically recalculate when their dependencies change, with built-in memoization for performance.</p> <p>Reactions: Functions that run automatically when their observed dependencies change, enabling side effects like UI updates or API calls.</p> <p>Stores: Classes that group related observables together with convenient subscription and state management methods.</p> <p>Conditional Reactions: Functions that only run when specific conditions are met, perfect for state machines, validation, and event filtering.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Transparent Reactivity: No special syntax needed - just use regular Python objects</li> <li>Automatic Dependency Tracking: Observables automatically track what depends on them</li> <li>Lazy Evaluation: Computed values only recalculate when needed</li> <li>Type Safety: Full type hint support for better IDE experience and static analysis</li> <li>Memory Efficient: Automatic cleanup of unused reactive contexts</li> <li>Composable: Easy to combine and nest reactive components</li> <li>Flexible Operators: Use <code>|</code>, <code>&gt;&gt;</code>, <code>&amp;</code>, and <code>~</code> operators for expressive reactive logic</li> </ul>"},{"location":"#quick-start-example","title":"Quick Start Example","text":"<pre><code>from fynx import Store, observable, computed, reactive, watch\n\n# Create a reactive store\nclass UserStore(Store):\n    name = observable(\"Alice\")\n    age = observable(30)\n    is_online = observable(False)\n\n    @computed\n    def greeting(self):\n        return f\"Hello, {self.name}! You are {self.age} years old.\"\n\n# React to all changes\n@reactive(UserStore.name, UserStore.age)\ndef on_user_change(name, age):\n    print(f\"User updated: {name}, {age}\")\n\n# React only when conditions are met\n@watch(\n    lambda: UserStore.is_online.value,\n    lambda: UserStore.age.value &gt;= 18\n)\ndef on_adult_online():\n    print(f\"Adult user {UserStore.name.value} is now online!\")\n\n# Changes trigger reactions automatically\nUserStore.name = \"Bob\"      # Prints: User updated: Bob, 30\nUserStore.age = 25          # Prints: User updated: Bob, 25\nUserStore.is_online = True  # Prints: Adult user Bob is now online!\n</code></pre>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install fynx\n</code></pre>"},{"location":"#documentation","title":"Documentation","text":"<ul> <li>API Reference - Complete API documentation</li> <li>Examples - Working examples and patterns</li> <li>GitHub Repository - Source code and issues</li> </ul>"},{"location":"#common-patterns","title":"Common Patterns","text":"<p>State Management: Group related data in Store classes for organized state management.</p> <p>Derived Data: Use computed values for data that depends on other data.</p> <p>Side Effects: Use reactive decorators for UI updates, API calls, or logging.</p> <p>Conditional Logic: Use watch decorators for state machines and conditional behavior.</p> <p>Data Flow: Use operators (<code>|</code>, <code>&gt;&gt;</code>, <code>&amp;</code>) for composing complex reactive relationships.</p>"},{"location":"#contributing","title":"Contributing","text":"<p>Contributions are welcome! Please see the GitHub repository for contribution guidelines.</p>"},{"location":"#license","title":"License","text":"<p>FynX is released under the MIT License. See the LICENSE file for details.</p>"},{"location":"1.0_TODO/","title":"Fynx Observable System - Product Specification for 1.0","text":"<p>Below is the roadmap for Fynx</p>"},{"location":"1.0_TODO/#1-overview","title":"1. Overview","text":"<p>A reactive observable system providing type-safe, composable primitives for finite state management and infinite stream processing with Pythonic operator semantics. Features deterministic concurrency handling through serialized propagation.</p>"},{"location":"1.0_TODO/#2-concurrency-model-threading-behavior","title":"2. Concurrency Model &amp; Threading Behavior","text":""},{"location":"1.0_TODO/#21-serialized-propagation-architecture","title":"2.1 Serialized Propagation Architecture","text":"<p>Description: All observables use an internal emission queue to ensure deterministic, race-free propagation regardless of emission source (sync thread, async coroutine, or background thread).</p> <p>Core Mechanism:</p> <ol> <li>Each observable (or the global system) maintains an internal emission queue</li> <li>Any emission (via <code>obs &lt;&lt; value</code>, assignment <code>obs = value</code>, or merged sources) enqueues the value</li> <li>A single propagation worker consumes the queue sequentially</li> <li>The worker recalculates derived observables, applies filters, and notifies subscribers in queue order</li> <li>Worker can be a dedicated thread or the current thread in single-threaded contexts</li> </ol> <p>Acceptance Criteria:</p> <ul> <li>[ ] All emissions are enqueued, never propagated directly on caller thread</li> <li>[ ] Propagation worker processes emissions sequentially in enqueue order</li> <li>[ ] Concurrent pushes from multiple threads/coroutines are serialized automatically</li> <li>[ ] No race conditions possible: subscribers never observe partial updates</li> <li>[ ] Merge order (<code>a @ b @ c</code>) determines transformation argument order deterministically</li> <li>[ ] Left-to-right evaluation: <code>(a @ b) @ c</code> processes <code>a</code>, then <code>b</code>, then <code>c</code> emissions in queue order</li> </ul>"},{"location":"1.0_TODO/#22-thread-safe-enqueueing","title":"2.2 Thread-Safe Enqueueing","text":"<p>Open Questions: * What is the non-sugar api for this?</p> <p>Acceptance Criteria:</p> <ul> <li>[ ] Push operations (<code>&lt;&lt;</code>, assignment) are thread-safe</li> <li>[ ] Uses thread-safe queue implementation (<code>queue.Queue</code> or equivalent with locks)</li> <li>[ ] Multiple threads can emit concurrently without coordination</li> <li>[ ] Enqueue operation returns immediately (non-blocking for caller)</li> <li>[ ] Propagation happens asynchronously on worker thread/context</li> </ul> <p>Example:</p> <pre><code>stream = InfiniteObservable()\n\n# Thread 1\nstream &lt;&lt; 1\n\n# Thread 2 (concurrent)\nstream &lt;&lt; 2\n\n# Both enqueued safely; propagated sequentially in arrival order\n</code></pre>"},{"location":"1.0_TODO/#23-asyncawait-integration","title":"2.3 Async/Await Integration","text":"<p>Acceptance Criteria:</p> <ul> <li>[ ] Supports <code>asyncio</code> integration via <code>asyncio.Queue</code> for propagation</li> <li>[ ] Sync context emissions use <code>loop.call_soon_threadsafe()</code> to enqueue</li> <li>[ ] Async context emissions can directly await queue operations</li> <li>[ ] Propagation coroutine processes emissions sequentially</li> <li>[ ] Users can emit from sync or async contexts transparently</li> <li>[ ] Subscribers can be sync or async callbacks (system handles both)</li> </ul> <p>Example:</p> <pre><code># Sync emission (from any thread)\nstream &lt;&lt; value  # Internally uses call_soon_threadsafe if async loop active\n\n# Async emission\nasync def process():\n    stream &lt;&lt; await fetch_data()\n\n# Async subscriber\nasync def async_handler(value):\n    await save_to_db(value)\n\nstream.subscribe(async_handler)  # System detects async and handles appropriately\n</code></pre>"},{"location":"1.0_TODO/#24-propagation-guarantees","title":"2.4 Propagation Guarantees","text":"<p>Acceptance Criteria:</p> <ul> <li>[ ] Deterministic ordering: Emissions processed in exact enqueue order</li> <li>[ ] Atomic propagation: Each emission propagates completely before next emission starts</li> <li>[ ] No race conditions: Derived observables never see partial/inconsistent state</li> <li>[ ] Subscriber safety: All subscribers receive same value in same propagation cycle</li> <li>[ ] Single propagation per emission: Each emission triggers exactly one propagation pass</li> <li>[ ] Merge consistency: Left-to-right merge order preserved across all propagations</li> </ul> <p>Example:</p> <pre><code>a = observable(1)\nb = observable(2)\nmerged = a @ b\nresult = merged &gt;&gt; (lambda x, y: x + y)  # x from a, y from b (deterministic)\n\n# Thread 1\na = 10\n\n# Thread 2 (concurrent)\nb = 20\n\n# Result sees either (10, 2) or (1, 20) or (10, 20)\n# Never partial like (10, &lt;uninitialized&gt;)\n# Order determined by queue arrival, but always consistent\n</code></pre>"},{"location":"1.0_TODO/#25-performance-considerations","title":"2.5 Performance Considerations","text":"<p>Latency:</p> <ul> <li>[ ] Slight overhead vs direct synchronous propagation (typically microseconds)</li> <li>[ ] Negligible for most applications</li> <li>[ ] Configurable queue processing batch size for high-throughput scenarios</li> </ul> <p>Backpressure:</p> <ul> <li>[ ] Optional max queue size to prevent unbounded memory growth</li> <li>[ ] Configurable overflow strategies: block, drop oldest, drop newest, raise error</li> <li>[ ] Monitoring API for queue depth inspection</li> </ul> <p>Example:</p> <pre><code># Configure backpressure (optional)\nstream = InfiniteObservable(max_queue_size=1000, overflow='drop_oldest')\n\n# Monitor queue health\nif stream.queue_depth() &gt; 900:\n    warnings.warn(\"Observable queue near capacity\")\n</code></pre>"},{"location":"1.0_TODO/#26-user-experience","title":"2.6 User Experience","text":"<p>Acceptance Criteria:</p> <ul> <li>[ ] No API changes required for threading/async support</li> <li>[ ] System automatically detects execution context (sync/async, thread)</li> <li>[ ] Users never need to manage locks, mutexes, or async context explicitly</li> <li>[ ] Standard operators (<code>&lt;&lt;</code>, <code>=</code>, <code>&gt;&gt;</code>, <code>@</code>) work identically regardless of threading</li> <li>[ ] Subscribers always see sequential, deterministic updates</li> <li>[ ] Optional configuration for advanced use cases (queue size, worker threads)</li> </ul> <p>Example:</p> <pre><code># Works identically in all contexts\nstream &lt;&lt; value  # Sync thread\nstream &lt;&lt; value  # Async coroutine\nstream &lt;&lt; value  # Background thread\n\n# User never sees:\n# - Race conditions\n# - Partial updates\n# - Lock/mutex management\n# - async/await complexity (unless desired)\n</code></pre>"},{"location":"1.0_TODO/#3-core-observable-types","title":"3. Core Observable Types","text":""},{"location":"1.0_TODO/#31-genericobservable-base-type","title":"3.1 GenericObservable (Base Type)","text":"<p>Description: Abstract supertype for all observable types. Provides common interface and enables polymorphic operations across all observable subtypes.</p> <p>Acceptance Criteria:</p> <ul> <li>[ ] All observable types inherit from <code>GenericObservable</code></li> <li>[ ] All operators (<code>&gt;&gt;</code>, <code>@</code>, <code>.where()</code>, <code>.subscribe()</code>) work on <code>GenericObservable</code> instances regardless of concrete subtype</li> <li>[ ] Type system is transparent to users - operations return appropriate concrete types without requiring type-specific logic</li> <li>[ ] Generic observables can be composed with any other generic observable using standard operators</li> <li>[ ] Runtime type determination follows documented promotion rules (e.g., Finite + Infinite \u2192 Infinite)</li> <li>[ ] All emissions go through serialized propagation queue (see Section 2)</li> </ul>"},{"location":"1.0_TODO/#32-finiteobservable","title":"3.2 FiniteObservable <p>Description: Single-valued reactive cell holding current value from discrete domain with serialized propagation.</p> <p>Acceptance Criteria:</p> <ul> <li>[ ] Holds exactly one value of type <code>T</code> at any moment</li> <li>[ ] Assignment enqueues value for propagation (not direct synchronous)</li> <li>[ ] Can be created via <code>observable(initial_value)</code> factory function</li> <li>[ ] Supports <code>obs = new_value</code> assignment syntax (thread-safe)</li> <li>[ ] Reading <code>.value</code> returns current value without triggering propagation</li> <li>[ ] Used as Store class property decorator: <code>property_name = observable(default)</code></li> <li>[ ] All dependent observables recalculate atomically during propagation worker pass</li> <li>[ ] Thread-safe: can be assigned from any thread</li> </ul> <p>Example:</p> <pre><code>counter = observable(5)\ndoubled = counter &gt;&gt; (lambda x: x * 2)\ncounter = 10  # Enqueued; doubled becomes 20 after propagation\n</code></pre>","text":""},{"location":"1.0_TODO/#33-infiniteobservable","title":"3.3 InfiniteObservable <p>Description: Unbounded stream of values emitted asynchronously over time with serialized propagation.</p> <p>Acceptance Criteria:</p> <ul> <li>[ ] Maintains sequence of emissions with no defined \u201cfinal\u201d value</li> <li>[ ] Created via <code>InfiniteObservable()</code> constructor</li> <li>[ ] Supports <code>&lt;&lt;</code> push operator: <code>stream &lt;&lt; value</code> (thread-safe)</li> <li>[ ] Supports merging another stream: <code>stream &lt;&lt; other_stream</code></li> <li>[ ] Each emission enqueued and triggers downstream propagation independently</li> <li>[ ] Concurrent emissions are serialized: multiple threads can push simultaneously</li> <li>[ ] Emissions processed in queue arrival order</li> <li>[ ] Can emit zero or more values over lifetime</li> <li>[ ] Can merge with transformed streams: <code>stream &lt;&lt; upload.map(fn)</code></li> <li>[ ] Push operations are non-blocking (return immediately after enqueueing)</li> </ul> <p>Memory Management:</p> <ul> <li>[ ] Subscriptions maintain reference to observable</li> <li>[ ] Unsubscribing releases subscription reference but not observable</li> <li>[ ] Long-lived infinite observables should be explicitly disposed when no longer needed</li> <li>[ ] Consider weak references for subscriber management to prevent memory leaks</li> </ul> <p>Concurrent Emission Example:</p> <pre><code>stream = InfiniteObservable()\n\n# Thread 1\nfor i in range(100):\n    stream &lt;&lt; i\n\n# Thread 2 (concurrent)\nfor i in range(100, 200):\n    stream &lt;&lt; i\n\n# Thread 3 (concurrent)\nfor i in range(200, 300):\n    stream &lt;&lt; i\n\n# All 300 emissions safely enqueued and propagated sequentially\n# Subscribers see values in queue arrival order (deterministic per run)\n</code></pre>","text":""},{"location":"1.0_TODO/#34-conditionalobservable","title":"3.4 ConditionalObservable <p>Description: Wrapper that filters emissions from source observable based on predicate with propagation queue integration.</p> <p>Acceptance Criteria:</p> <p>Core Filtering:</p> <ul> <li>[ ] Created via <code>.where(predicate)</code> method on any observable</li> <li>[ ] Predicate signature: <code>T \u2192 Bool</code></li> <li>[ ] Only propagates emissions where <code>predicate(value) == True</code></li> <li>[ ] Predicate evaluation happens in propagation worker context</li> <li>[ ] Preserves source type: <code>FiniteObservable.where()</code> \u2192 <code>FiniteObservable</code></li> <li>[ ] Preserves source type: <code>InfiniteObservable.where()</code> \u2192 <code>InfiniteObservable</code></li> <li>[ ] Thread-safe: source emissions can come from any thread</li> </ul> <p>Finite Source Semantics:</p> <ul> <li>[ ] Evaluates condition during propagation worker pass</li> <li>[ ] Suppresses downstream propagation when condition is <code>False</code></li> <li>[ ] No retroactive evaluation of past assignments</li> </ul> <p>Infinite Source Semantics:</p> <ul> <li>[ ] Acts as stream filter during propagation</li> <li>[ ] Does not affect previously emitted values</li> <li>[ ] Each emission independently evaluated against predicate in worker context</li> </ul> <p>Dynamic Conditions:</p> <ul> <li>[ ] Accepts observable predicates: <code>.where(condition_observable)</code></li> <li>[ ] Gates emissions based on current value of condition observable at propagation time</li> <li>[ ] For finite sources: checks condition during propagation worker pass</li> <li>[ ] For infinite sources: checks condition during propagation of each emission</li> </ul> <p>Composition:</p> <ul> <li>[ ] Chained <code>.where()</code> calls compose with AND logic</li> <li>[ ] <code>source.where(P1).where(P2)</code> equivalent to <code>source.where(lambda x: P1(x) and P2(x))</code></li> <li>[ ] Derived observables inherit conditional propagation</li> </ul> <p>Example:</p> <pre><code>stream = InfiniteObservable()\nevens = stream.where(lambda x: x % 2 == 0)\n\n# Thread-safe concurrent pushes\nstream &lt;&lt; 1  # suppressed during propagation\nstream &lt;&lt; 2  # evens emits 2 during propagation\nstream &lt;&lt; 3  # suppressed\nstream &lt;&lt; 4  # evens emits 4\n\ncondition = observable(True)\ngated = stream.where(condition)  # Checks condition at propagation time\n</code></pre>","text":""},{"location":"1.0_TODO/#35-mergedobservable","title":"3.5 MergedObservable <p>Description: Unified emission stream combining multiple source observables with deterministic propagation order.</p> <p>Acceptance Criteria:</p> <p>Core Merging:</p> <ul> <li>[ ] Created via <code>@</code> operator: <code>obs1 @ obs2 @ obs3</code></li> <li>[ ] Accepts 2+ source observables of same type <code>T</code></li> <li>[ ] Emits union of all source emissions: <code>\u22c3\u1d62 emissions(s\u1d62)</code></li> <li>[ ] Merge order is deterministic and left-to-right: <code>(a @ b) @ c</code> always processes <code>a</code>, then <code>b</code>, then <code>c</code></li> <li>[ ] Interleaves emissions in queue arrival order (within propagation worker)</li> <li>[ ] Concurrent emissions from different sources serialized by propagation queue</li> </ul> <p>Type Determination:</p> <ul> <li>[ ] All finite sources \u2192 <code>FiniteObservable&lt;T&gt;</code></li> <li>[ ] All infinite sources \u2192 <code>InfiniteObservable&lt;T&gt;</code></li> <li>[ ] Mixed finite + infinite \u2192 <code>InfiniteObservable&lt;T&gt;</code> (most dynamic type wins)</li> </ul> <p>Finite Source Behavior:</p> <ul> <li>[ ] Each source assignment enqueued for propagation</li> <li>[ ] Merged result emits during propagation pass</li> <li>[ ] Sequential assignments preserve per-source ordering in queue</li> </ul> <p>Infinite Source Behavior:</p> <ul> <li>[ ] Each emission enqueued independently</li> <li>[ ] Emissions interleaved in queue arrival order</li> <li>[ ] Thread-safe: sources can emit from different threads concurrently</li> </ul> <p>Mixed Source Behavior:</p> <ul> <li>[ ] Finite sources contribute current value snapshot during propagation</li> <li>[ ] Infinite sources contribute ongoing emissions via queue</li> <li>[ ] Result exhibits both discrete and continuous characteristics</li> </ul> <p>Edge Cases:</p> <ul> <li>[ ] Empty merge <code>MergedObservable()</code> with no sources raises <code>ValueError</code></li> <li>[ ] Single source merge <code>MergedObservable(s)</code> returns identity (equivalent to <code>s</code>)</li> </ul> <p>Algebraic Properties:</p> <ul> <li>[ ] Identity: <code>MergedObservable(s) \u2261 s</code></li> <li>[ ] Associativity: <code>(a @ b) @ c \u2261 a @ (b @ c)</code></li> <li>[ ] Type closure: Result is always an observable</li> <li>[ ] Deterministic ordering: merge order determines transformation argument order (guaranteed by propagation queue)</li> </ul> <p>Concurrent Emission Example:</p> <pre><code>stream1 = InfiniteObservable()\nstream2 = InfiniteObservable()\nmerged = stream1 @ stream2\n\n# Thread 1\nstream1 &lt;&lt; \"A1\"\nstream1 &lt;&lt; \"A2\"\n\n# Thread 2 (concurrent)\nstream2 &lt;&lt; \"B1\"\nstream2 &lt;&lt; \"B2\"\n\n# Propagation worker sees queue like: [A1, B1, A2, B2] (example order)\n# Subscribers see deterministic sequence based on queue arrival\n# Transform receives arguments in merge order (stream1 first, stream2 second)\n\nresult = merged &gt;&gt; (lambda v1, v2: f\"{v1}+{v2}\")\n# v1 always from stream1, v2 always from stream2 (deterministic merge order)\n</code></pre>","text":""},{"location":"1.0_TODO/#4-operators","title":"4. Operators","text":""},{"location":"1.0_TODO/#41-transform-operator","title":"4.1 Transform Operator (<code>&gt;&gt;</code>) <p>Description: Creates derived observable by applying transformation function during propagation. Never mutates source observable.</p> <p>Acceptance Criteria:</p> <ul> <li>[ ] Signature: <code>Observable&lt;T&gt; &gt;&gt; (T \u2192 U) \u2192 Observable&lt;U&gt;</code></li> <li>[ ] Works on <code>GenericObservable</code> regardless of concrete type</li> <li>[ ] Always creates new observable; source remains unchanged</li> <li>[ ] Derived observable recalculates during propagation worker pass</li> <li>[ ] Supports chaining: <code>obs &gt;&gt; f &gt;&gt; g &gt;&gt; h</code></li> <li>[ ] Lazy evaluation: computes only during propagation pass</li> <li>[ ] Type preservation: Finite \u2192 Finite, Infinite \u2192 Infinite</li> <li>[ ] Multi-argument functions receive values in merge order (deterministic, left-to-right, guaranteed by propagation queue)</li> <li>[ ] Chained transformations compose left-to-right</li> <li>[ ] Transformation function called once per emission/update during propagation</li> <li>[ ] Thread-safe: source emissions can originate from any thread</li> </ul> <p>Example:</p> <pre><code>result = counter &gt;&gt; (lambda x: x * 2) &gt;&gt; (lambda x: x + 10)\n# counter unchanged; result is new observable\n# Transformation happens in propagation worker\n\ntotal = (count @ price) &gt;&gt; (lambda c, p: c * p)\n# c=count, p=price (merge order, deterministic even with concurrent updates)\n</code></pre>","text":""},{"location":"1.0_TODO/#42-merge-operator","title":"4.2 Merge Operator (<code>@</code>) <p>Description: Combines multiple observables into unified stream with deterministic propagation order.</p> <p>Acceptance Criteria:</p> <ul> <li>[ ] Signature: <code>Observable&lt;T&gt; @ Observable&lt;T&gt; \u2192 MergedObservable&lt;T&gt;</code></li> <li>[ ] Works on <code>GenericObservable</code> instances</li> <li>[ ] Accepts 2+ operands: <code>a @ b @ c</code></li> <li>[ ] Associative: <code>(a @ b) @ c \u2261 a @ (b @ c)</code></li> <li>[ ] Deterministic left-to-right merge order preserved for downstream transformations (guaranteed by propagation queue)</li> <li>[ ] Result type follows type determination rules (section 3.5)</li> <li>[ ] Can be chained with <code>&gt;&gt;</code>: <code>(a @ b) &gt;&gt; transform_fn</code></li> <li>[ ] Raises <code>ValueError</code> if called with zero operands</li> <li>[ ] Thread-safe: operands can emit from different threads concurrently</li> </ul> <p>Example:</p> <pre><code>combined = obs1 @ obs2 @ obs3\nresult = combined &gt;&gt; (lambda v1, v2, v3: v1 + v2 + v3)\n# v1=obs1, v2=obs2, v3=obs3 (deterministic merge order)\n# Works correctly even if obs1, obs2, obs3 updated from different threads\n</code></pre>","text":""},{"location":"1.0_TODO/#43-filter-method-where","title":"4.3 Filter Method (<code>.where()</code>) <p>Description: Creates conditional observable filtering emissions during propagation.</p> <p>Acceptance Criteria:</p> <ul> <li>[ ] Signature: <code>Observable&lt;T&gt;.where(T \u2192 Bool) \u2192 ConditionalObservable&lt;T&gt;</code></li> <li>[ ] Signature (dynamic): <code>Observable&lt;T&gt;.where(Observable&lt;Bool&gt;) \u2192 ConditionalObservable&lt;T&gt;</code></li> <li>[ ] Works on <code>GenericObservable</code></li> <li>[ ] Returns <code>ConditionalObservable</code> preserving source type (Finite/Infinite)</li> <li>[ ] Chainable: <code>obs.where(p1).where(p2)</code> applies AND logic</li> <li>[ ] Can be combined with other operators: <code>obs.where(pred) &gt;&gt; transform</code></li> <li>[ ] Predicate evaluation happens in propagation worker context</li> <li>[ ] Thread-safe: source can emit from any thread</li> </ul> <p>Example:</p> <pre><code>positives = counter.where(lambda x: x &gt; 0)\nevens = stream.where(lambda x: x % 2 == 0)\nfiltered = obs.where(p1).where(p2) &gt;&gt; transform\n# All predicates evaluated during propagation worker pass\n</code></pre>","text":""},{"location":"1.0_TODO/#44-push-operator","title":"4.4 Push Operator (<code>&lt;&lt;</code>) <p>Description: Thread-safe emission into infinite observable stream via propagation queue.</p> <p>Acceptance Criteria:</p> <ul> <li>[ ] Signature: <code>InfiniteObservable&lt;T&gt; &lt;&lt; T \u2192 None</code></li> <li>[ ] Signature (merge): <code>InfiniteObservable&lt;T&gt; &lt;&lt; Observable&lt;T&gt; \u2192 None</code></li> <li>[ ] Only valid for <code>InfiniteObservable</code> instances</li> <li>[ ] Pushes single value: <code>stream &lt;&lt; value</code> (enqueues for propagation)</li> <li>[ ] Merges another observable: <code>stream &lt;&lt; other_observable</code></li> <li>[ ] Thread-safe: can be called from any thread concurrently</li> <li>[ ] Non-blocking: returns immediately after enqueueing</li> <li>[ ] Triggers downstream propagation during worker pass</li> <li>[ ] Returns <code>None</code> (side-effect only)</li> </ul> <p>Example:</p> <pre><code>stream &lt;&lt; 42  # Thread-safe, enqueued\nstream &lt;&lt; (upload &gt;&gt; process)  # Merge enqueued\n\n# Concurrent pushes (safe)\nthreading.Thread(target=lambda: stream &lt;&lt; 1).start()\nthreading.Thread(target=lambda: stream &lt;&lt; 2).start()\n# Both enqueued; propagated sequentially by worker\n</code></pre>","text":""},{"location":"1.0_TODO/#45-subscribe-method-subscribe","title":"4.5 Subscribe Method (<code>.subscribe()</code>) <p>Description: Registers callback to react to observable changes during propagation.</p> <p>Acceptance Criteria:</p> <ul> <li>[ ] Signature: <code>Observable&lt;T&gt;.subscribe(T \u2192 None) \u2192 Subscription</code></li> <li>[ ] Works on <code>GenericObservable</code></li> <li>[ ] Callback invoked during propagation worker pass for each emission/update</li> <li>[ ] Returns subscription object for unsubscription</li> <li>[ ] Subscription has <code>.unsubscribe()</code> method</li> <li>[ ] Multiple subscribers supported per observable</li> <li>[ ] Callbacks receive current/emitted value as argument</li> <li>[ ] Callbacks execute in propagation worker context (thread-safe by design)</li> <li>[ ] All subscribers see same value in same propagation cycle (no races)</li> </ul> <p>Memory Management:</p> <ul> <li>[ ] Subscription maintains reference to observable and callback</li> <li>[ ] Calling <code>.unsubscribe()</code> releases callback reference</li> <li>[ ] Observable maintains weak references to subscriptions where possible</li> <li>[ ] Unsubscribing does not dispose the observable itself</li> <li>[ ] Subscribers should explicitly unsubscribe when done to prevent memory leaks</li> </ul> <p>Example:</p> <pre><code>subscription = obs.subscribe(lambda x: print(f\"Value: {x}\"))\n# Callback invoked in propagation worker context (safe)\n\nsubscription.unsubscribe()  # Release callback reference\n</code></pre>","text":""},{"location":"1.0_TODO/#5-booleancomparison-operators","title":"5. Boolean/Comparison Operators","text":""},{"location":"1.0_TODO/#51-boolean-logic-operators","title":"5.1 Boolean Logic Operators <p>Description: Native boolean operations on observables producing reactive boolean results with propagation queue semantics.</p> <p>Acceptance Criteria:</p> <ul> <li>[ ] <code>&amp;</code> operator: <code>obs1 &amp; obs2</code> returns observable evaluating AND during propagation</li> <li>[ ] <code>|</code> operator: <code>obs1 | obs2</code> returns observable evaluating OR during propagation (distinct from merge <code>@</code>)</li> <li>[ ] <code>~</code> operator: <code>~obs</code> returns observable negating value during propagation</li> <li>[ ] Operators work element-wise on current values at propagation time</li> <li>[ ] For finite sources: produces <code>FiniteObservable&lt;bool&gt;</code></li> <li>[ ] For infinite sources: produces stream of boolean evaluations per emission</li> <li>[ ] Results are fully reactive: update during propagation when any operand changes</li> <li>[ ] Works on <code>GenericObservable</code> instances</li> <li>[ ] Thread-safe: operands can be updated from different threads</li> </ul> <p>Mixed Type Behavior:</p> <ul> <li>[ ] <code>FiniteObservable&lt;bool&gt; &amp; InfiniteObservable&lt;bool&gt;</code> \u2192 <code>InfiniteObservable&lt;bool&gt;</code></li> <li>[ ] Finite operand provides current value snapshot; infinite operand drives emission timing</li> <li>[ ] Result emits on each infinite stream emission, using latest finite value at propagation time</li> </ul> <p>Example:</p> <pre><code>ready = uploaded &amp; valid &amp; (~processing)\nany_active = stream1 | stream2  # Boolean OR, not merge\n# All evaluations happen in propagation worker (thread-safe)\n</code></pre>","text":""},{"location":"1.0_TODO/#52-comparison-operators","title":"5.2 Comparison Operators <p>Description: Comparison operators for observables returning reactive boolean observables with propagation semantics.</p> <p>Acceptance Criteria:</p> <ul> <li>[ ] Supports: <code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code></li> <li>[ ] Signature: <code>Observable&lt;T&gt; {op} T \u2192 Observable&lt;bool&gt;</code></li> <li>[ ] Signature: <code>Observable&lt;T&gt; {op} Observable&lt;T&gt; \u2192 Observable&lt;bool&gt;</code></li> <li>[ ] Returns reactive boolean observable</li> <li>[ ] Evaluates comparison during propagation worker pass</li> <li>[ ] Works with <code>@watch</code> decorator and standalone</li> <li>[ ] Works on <code>GenericObservable</code></li> <li>[ ] Thread-safe: operands can be updated from different threads</li> </ul> <p>Mixed Type Behavior:</p> <ul> <li>[ ] <code>FiniteObservable&lt;T&gt; &gt;= InfiniteObservable&lt;T&gt;</code> \u2192 <code>InfiniteObservable&lt;bool&gt;</code></li> <li>[ ] <code>InfiniteObservable&lt;T&gt; &gt;= FiniteObservable&lt;T&gt;</code> \u2192 <code>InfiniteObservable&lt;bool&gt;</code></li> <li>[ ] Finite operand provides current value snapshot at propagation time</li> <li>[ ] Infinite operand drives emission timing</li> <li>[ ] Each emission from infinite side triggers comparison with latest finite value during propagation</li> <li>[ ] <code>FiniteObservable&lt;T&gt; &gt;= FiniteObservable&lt;T&gt;</code> \u2192 <code>FiniteObservable&lt;bool&gt;</code> (updates when either changes)</li> <li>[ ] <code>InfiniteObservable&lt;T&gt; &gt;= InfiniteObservable&lt;T&gt;</code> \u2192 <code>InfiniteObservable&lt;bool&gt;</code> (emits when either emits)</li> </ul> <p>Example:</p> <pre><code>is_adult = age &gt;= 18\nis_equal = obs1 == obs2\nmatches = name == \"Alice\"\n\n# Mixed types\nexceeded = infinite_sensor &gt;= finite_threshold  # InfiniteObservable&lt;bool&gt;\n# Comparison happens in propagation worker using latest finite_threshold value\n</code></pre>","text":""},{"location":"1.0_TODO/#6-decorator-watch","title":"6. Decorator: <code>@watch</code>","text":"<p>Description: Executes function when all condition observables evaluate to <code>True</code> during propagation. Triggers on every emission/update that satisfies all conditions.</p> <p>Acceptance Criteria:</p> <ul> <li>[ ] Signature: <code>@watch(condition1, condition2, ...) def fn(): ...</code></li> <li>[ ] Accepts multiple condition observables/lambdas</li> <li>[ ] Conditions are lambda expressions returning observables: <code>lambda: age &gt;= 18</code></li> <li>[ ] Lambdas evaluated reactively during propagation: re-evaluates whenever any observable referenced inside changes</li> <li>[ ] Executes function when ALL conditions are <code>True</code> during propagation worker pass</li> <li>[ ] Triggers once per emission/update that satisfies all conditions (no debouncing by default)</li> <li>[ ] Re-evaluates reactively during propagation when any condition observable changes</li> <li>[ ] Supports boolean/comparison operators in conditions</li> <li>[ ] Does not require observables to be used exclusively in <code>@watch</code> context</li> <li>[ ] Each condition lambda may reference multiple observables; any change triggers re-evaluation during propagation</li> <li>[ ] Thread-safe: conditions evaluated in propagation worker context, safe from races</li> </ul> <p>Execution Semantics:</p> <ul> <li>[ ] Function executes in propagation worker context when conditions become <code>True</code></li> <li>[ ] No automatic debouncing or coalescing (user can implement if needed)</li> <li>[ ] If multiple observables change concurrently, executes once during propagation with latest values</li> </ul> <p>Example:</p> <pre><code>@watch(lambda: User.age &gt;= 18, lambda: User.email.endswith('.com'))\ndef process_eligible_user():\n    print(\"Eligible user detected!\")\n# Triggers during propagation when conditions become True\n# Safe even if User.age and User.email updated from different threads\n\n@watch(lambda: (sensor_reading &gt; threshold) &amp; sensor_active)\ndef alert():\n    print(\"Alert!\")\n# Triggers during propagation on each emission where condition is True\n# Evaluation happens in propagation worker (thread-safe)\n</code></pre>"},{"location":"1.0_TODO/#7-operator-summary-table","title":"7. Operator Summary Table","text":"Operator Signature Description Example <code>&gt;&gt;</code> <code>Observable&lt;T&gt; &gt;&gt; (T \u2192 U) \u2192 Observable&lt;U&gt;</code> Transform values (creates new observable) <code>doubled = x &gt;&gt; (lambda v: v * 2)</code> <code>@</code> <code>Observable&lt;T&gt; @ Observable&lt;T&gt; \u2192 MergedObservable&lt;T&gt;</code> Merge observables (deterministic order) <code>combined = a @ b</code> <code>.where()</code> <code>Observable&lt;T&gt;.where(T \u2192 Bool) \u2192 ConditionalObservable&lt;T&gt;</code> Filter emissions during propagation <code>pos = x.where(lambda v: v &gt; 0)</code> <code>&lt;&lt;</code> <code>InfiniteObservable&lt;T&gt; &lt;&lt; T \u2192 None</code> Thread-safe push to stream (enqueued) <code>stream &lt;&lt; value</code> <code>.subscribe()</code> <code>Observable&lt;T&gt;.subscribe(T \u2192 None) \u2192 Subscription</code> React to changes during propagation <code>obs.subscribe(print)</code> <code>&amp;</code> <code>Observable&lt;bool&gt; &amp; Observable&lt;bool&gt; \u2192 Observable&lt;bool&gt;</code> Boolean AND (evaluated during propagation) <code>ready = a &amp; b</code> <code>|</code> <code>Observable&lt;bool&gt; | Observable&lt;bool&gt; \u2192 Observable&lt;bool&gt;</code> Boolean OR (evaluated during propagation) <code>any_active = a | b</code> <code>~</code> <code>~Observable&lt;bool&gt; \u2192 Observable&lt;bool&gt;</code> Boolean NOT (evaluated during propagation) <code>inactive = ~active</code> <code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code> <code>Observable&lt;T&gt; {op} T \u2192 Observable&lt;bool&gt;</code> Comparison (evaluated during propagation) <code>adult = age &gt;= 18</code>"},{"location":"1.0_TODO/#8-design-principles","title":"8. Design Principles","text":"<p>Acceptance Criteria:</p> <ul> <li>[ ] Type preservation: Operations preserve or predictably promote types per documented rules</li> <li>[ ] Composability: All operators support nesting and chaining</li> <li>[ ] Transparency: Internal taxonomy hidden from users; all operations work on <code>GenericObservable</code></li> <li>[ ] Immutability: Transformations always create new observables; sources never mutated</li> <li>[ ] Determinism: Merge order is left-to-right and consistent; propagation queue ensures sequential processing</li> <li>[ ] Algebraic rigor: Identity, associativity, and type closure properties maintained</li> <li>[ ] Pythonic elegance: Uses familiar Python operators and method chaining</li> <li>[ ] Accessibility: No category theory knowledge required; intuitive semantics</li> <li>[ ] Memory safety: Clear subscription lifecycle; explicit cleanup prevents leaks</li> <li>[ ] Concurrency safety: Serialized propagation queue eliminates race conditions; thread-safe by design</li> <li>[ ] Performance: Minimal latency overhead; configurable backpressure handling</li> </ul>"},{"location":"1.0_TODO/#9-full-integration-example","title":"9. Full Integration Example","text":"<p>Acceptance Criteria:</p> <ul> <li>[ ] Following example works end-to-end with all specified features including threading:</li> </ul> <pre><code>class CartStore(Store):\n    item_count = observable(1)\n    price_per_item = observable(10.0)\n    discount_active = observable(False)\n\n# Merge observables (@ operator, deterministic order, thread-safe)\ncart_state = CartStore.item_count @ CartStore.price_per_item\n\n# Calculate subtotal (immutable transform, propagated via queue)\nsubtotal = cart_state &gt;&gt; (lambda count, price: count * price)\n\n# Apply discount conditionally (evaluated during propagation)\nfinal_price = (subtotal @ CartStore.discount_active) &gt;&gt; \\\n    (lambda total, discount: total * 0.9 if discount else total)\n\n# Subscribe to updates (callback runs in propagation worker context)\nsubscription = final_price.subscribe(lambda price: print(f\"Total: ${price:.2f}\"))\n\n# Changes propagate automatically via queue (thread-safe)\nCartStore.item_count = 3           # Enqueued \u2192 Total: $30.00\nCartStore.discount_active = True   # Enqueued \u2192 Total: $27.00\n\n# Thread-safe concurrent updates\nimport threading\nthreading.Thread(target=lambda: CartStore.item_count = 5).start()\nthreading.Thread(target=lambda: CartStore.price_per_item = 15.0).start()\n# Both enqueued; propagated sequentially; final_price sees consistent state\n\n# Cleanup\nsubscription.unsubscribe()\n\n# Boolean operators (| for OR, @ for merge)\npreview_ready = uploaded_file &amp; is_valid &amp; (~is_processing)\nany_error = validation_error | network_error  # Boolean OR\n\n# Mixed type comparisons with concurrent emissions\nsensor_stream = InfiniteObservable()\nthreshold = observable(100)\nalert_stream = sensor_stream &gt;= threshold  # InfiniteObservable&lt;bool&gt;\n\n# Thread-safe concurrent sensor updates\ndef sensor_thread():\n    for reading in sensor_readings:\n        sensor_stream &lt;&lt; reading  # Thread-safe push\n\nthreading.Thread(target=sensor_thread).start()\n\n# Watch decorator (reactive, per-emission trigger, thread-safe)\n@watch(lambda: User.age &gt;= 18, lambda: User.email.endswith('.com'))\ndef process_eligible_user():\n    print(\"Eligible user detected!\")\n# Conditions evaluated in propagation worker (safe from races)\n</code></pre>"},{"location":"1.0_TODO/#10-edge-cases-error-handling","title":"10. Edge Cases &amp; Error Handling","text":"<p>Acceptance Criteria:</p> <p>Empty Merge:</p> <ul> <li>[ ] <code>MergedObservable()</code> with no sources raises <code>ValueError</code> with message: \u201cCannot create merge with zero sources\u201d</li> <li>[ ] <code>a @ b @ ...</code> with at least one operand succeeds</li> </ul> <p>Mixed Type Merges:</p> <ul> <li>[ ] <code>FiniteObservable @ InfiniteObservable</code> produces <code>InfiniteObservable</code> (documented in 3.5)</li> <li>[ ] Finite values emit immediately via queue, infinite values emit over time via queue</li> <li>[ ] ConditionalObservable wrapping MergedObservable preserves result type rules</li> </ul> <p>Type Mismatches:</p> <ul> <li>[ ] Merging incompatible types (e.g., <code>Observable&lt;int&gt; @ Observable&lt;str&gt;</code>) raises <code>TypeError</code></li> <li>[ ] Comparison operators require comparable types or raise <code>TypeError</code></li> </ul> <p>Null/None Handling:</p> <ul> <li>[ ] Observables can hold <code>None</code> as valid value</li> <li>[ ] Predicates/transforms receive <code>None</code></li> </ul>"},{"location":"api/api/","title":"API Reference","text":""},{"location":"api/api/#fynx","title":"fynx","text":""},{"location":"api/api/#fynx-python-reactive-state-management-library","title":"FynX - Python Reactive State Management Library","text":"<p>FynX is a lightweight, transparent reactive state management library for Python, inspired by MobX. It enables reactive programming patterns where state changes automatically propagate through your application, eliminating the need for manual state synchronization.</p>"},{"location":"api/api/#core-concepts","title":"Core Concepts","text":"<p>Observables: Values that can be watched for changes. When an observable value changes, all dependent computations and reactions automatically update.</p> <p>Computed Values: Derived values that automatically recalculate when their dependencies change, with built-in memoization for performance.</p> <p>Reactions: Functions that run automatically when their observed dependencies change, enabling side effects like UI updates or API calls.</p> <p>Stores: Classes that group related observables together with convenient subscription and state management methods.</p>"},{"location":"api/api/#key-features","title":"Key Features","text":"<ul> <li>Transparent Reactivity: No special syntax needed - just use regular Python objects</li> <li>Automatic Dependency Tracking: Observables automatically track what depends on them</li> <li>Lazy Evaluation: Computed values only recalculate when needed</li> <li>Type Safety: Full type hint support for better IDE experience and static analysis</li> <li>Memory Efficient: Automatic cleanup of unused reactive contexts</li> <li>Composable: Easy to combine and nest reactive components</li> </ul>"},{"location":"api/api/#quick-example","title":"Quick Example","text":"<pre><code>from fynx import Store, observable, computed, reactive\n\n# Create a reactive store\nclass UserStore(Store):\n    name = observable(\"Alice\")\n    age = observable(30)\n\n    @computed\n    def greeting(self):\n        return f\"Hello, {self.name}! You are {self.age} years old.\"\n\n# React to changes\n@reactive(UserStore.name, UserStore.age)\ndef on_user_change(name, age):\n    print(f\"User updated: {name}, {age}\")\n\n# Changes trigger reactions automatically\nUserStore.name = \"Bob\"  # Prints: User updated: Bob, 30\nUserStore.age = 31      # Prints: User updated: Bob, 31\n</code></pre> <p>For more examples and detailed documentation, see the README.md file.</p> <p></p>"},{"location":"api/api/#fynxobservable","title":"fynx.observable","text":""},{"location":"api/api/#fynx-observable-module-core-reactive-classes","title":"FynX Observable Module - Core Reactive Classes","text":"<p>This module contains the fundamental building blocks of FynX's reactive programming system. It provides classes and utilities for creating observable values, managing reactive dependencies, and composing complex reactive behaviors.</p>"},{"location":"api/api/#understanding-observables","title":"Understanding Observables","text":"<p>At its core, an observable is a value that can notify others when it changes. Unlike regular variables, observables automatically track what depends on them and update those dependencies when their value changes.</p> <p>The reactive programming paradigm in FynX enables automatic propagation of state changes through your application, eliminating the need for manual synchronization of dependent values and side effects.</p>"},{"location":"api/api/#core-classes","title":"Core Classes","text":"<p>Observable: The foundation of reactivity - a value that automatically notifies subscribers when it changes. Observables behave like regular values but provide reactive capabilities.</p> <p>ReactiveContext: Manages the execution context for reactive functions, handling automatic dependency tracking and coordinating updates when dependencies change.</p> <p>MergedObservable: Combines multiple observables into a single reactive unit using the <code>|</code> operator. Useful for coordinating related values and passing them as a group to computed functions.</p> <p>ConditionalObservable: Filters reactive streams based on boolean conditions using the <code>&amp;</code> operator. Only emits values when all specified conditions are met.</p> <p>ComputedObservable: A read-only observable that derives its value from other observables. Computed values automatically recalculate when their dependencies change.</p> <p>ObservableValue: A transparent wrapper that makes reactive attributes behave like regular values while providing access to observable methods.</p> <p>SubscriptableDescriptor: Descriptor class for creating observable attributes in Store classes and other contexts where class-level observables are needed.</p>"},{"location":"api/api/#reactive-operators","title":"Reactive Operators","text":"<p>FynX provides intuitive operators for composing reactive behaviors:</p> <p>Merge (<code>|</code>): Combines observables into tuples for coordinated updates: <pre><code>point = x | y  # Creates (x.value, y.value) that updates when either changes\n</code></pre></p> <p>Transform (<code>&gt;&gt;</code>): Applies functions to create computed values: <pre><code>doubled = counter &gt;&gt; (lambda x: x * 2)  # Computed value\n</code></pre></p> <p>Filter (<code>&amp;</code>): Creates conditional observables that only emit when conditions are met: <pre><code>valid_data = data &amp; is_valid  # Only emits when is_valid is True\n</code></pre></p> <p>Negate (<code>~</code>): Creates boolean observables with inverted logic: <pre><code>is_not_loading = ~is_loading  # True when is_loading is False\n</code></pre></p>"},{"location":"api/api/#key-concepts","title":"Key Concepts","text":"<p>Dependency Tracking: Observables automatically track which reactive contexts depend on them during execution, enabling precise and efficient updates.</p> <p>Transparent Behavior: Reactive classes behave like their underlying values in most contexts, making them easy to integrate into existing code.</p> <p>Lazy Evaluation: Computed values only recalculate when accessed and dependencies have changed, improving performance.</p> <p>Automatic Cleanup: Reactive contexts are automatically cleaned up when no longer needed, preventing memory leaks.</p> <p>Type Safety: Full generic type support ensures type-safe reactive programming with excellent IDE support and static analysis.</p> <p>Circular Dependency Detection: FynX automatically detects and prevents circular dependencies at runtime.</p>"},{"location":"api/api/#practical-examples","title":"Practical Examples","text":""},{"location":"api/api/#basic-observable-usage","title":"Basic Observable Usage","text":"<pre><code>from fynx.observable import Observable\n\n# Create an observable value\ncounter = Observable(\"counter\", 0)\nprint(counter.value)  # 0\n\n# Subscribe to changes\ndef on_change():\n    print(f\"Counter changed to: {counter.value}\")\n\ncounter.subscribe(on_change)\ncounter.set(5)  # Prints: \"Counter changed to: 5\"\n</code></pre>"},{"location":"api/api/#merging-observables","title":"Merging Observables","text":"<pre><code># Create multiple observables\nwidth = Observable(\"width\", 10)\nheight = Observable(\"height\", 20)\n\n# Merge them into a single reactive unit\ndimensions = width | height\nprint(dimensions.value)  # (10, 20)\n\n# Changes to either update the merged observable\nwidth.set(15)\nprint(dimensions.value)  # (15, 20)\n</code></pre>"},{"location":"api/api/#conditional-observables","title":"Conditional Observables","text":"<pre><code>temperature = Observable(\"temp\", 20)\nis_heating_on = Observable(\"heating\", False)\n\n# Only emit temperature when heating is on\nheating_temp = temperature &amp; is_heating_on\n\ndef activate_heating(temp):\n    print(f\"Maintaining temperature at {temp}\u00b0C\")\n\nheating_temp.subscribe(activate_heating)\n\ntemperature.set(22)     # No output (heating is off)\nis_heating_on.set(True) # Prints: \"Maintaining temperature at 22\u00b0C\"\ntemperature.set(25)     # Prints: \"Maintaining temperature at 25\u00b0C\"\n</code></pre>"},{"location":"api/api/#computed-values","title":"Computed Values","text":"<pre><code>from fynx.computed import computed\n\n# Create computed observables\narea = computed(lambda w, h: w * h, dimensions)\nprint(area.value)  # 300\n\nwidth.set(20)\nprint(area.value)  # 400 (automatically recalculated)\n</code></pre>"},{"location":"api/api/#performance-considerations","title":"Performance Considerations","text":"<ul> <li>Lazy Evaluation: Computed values only recalculate when accessed</li> <li>Dependency Tracking: Only tracks actual dependencies, not speculative ones</li> <li>Memory Management: Automatic cleanup of unused reactive contexts</li> <li>Efficient Updates: Only notifies observers when values actually change</li> </ul>"},{"location":"api/api/#common-patterns","title":"Common Patterns","text":"<ul> <li>State Synchronization: Use observables to keep UI and data in sync</li> <li>Derived State: Use computed values for calculated properties</li> <li>Event Filtering: Use conditional observables for selective reactivity</li> <li>Data Composition: Use merged observables for related value coordination</li> </ul>"},{"location":"api/api/#see-also","title":"See Also","text":"<ul> <li><code>fynx.computed</code>: For creating derived values from observables</li> <li><code>fynx.store</code>: For grouping observables into reactive state containers</li> <li><code>fynx.watch</code>: For conditional reactive functions</li> <li><code>fynx.reactive</code>: For reactive decorators and subscriptions</li> </ul>"},{"location":"api/api/#fynxcomputed","title":"fynx.computed","text":""},{"location":"api/api/#fynx-computed-computed-observable-utilities","title":"FynX Computed - Computed Observable Utilities","text":"<p>This module provides the <code>computed</code> function for creating derived observables whose values are automatically calculated from other observables. Computed values enable you to create reactive properties that depend on other reactive values, automatically updating whenever their dependencies change.</p>"},{"location":"api/api/#what-are-computed-values","title":"What are Computed Values?","text":"<p>Computed values are read-only observables that derive their value from other observables. They automatically recalculate when their dependencies change, providing a way to create derived state without manual synchronization.</p> <p>Computed values are essential for: - Derived State: Properties that depend on other properties - Data Transformation: Converting or formatting data reactively - Business Logic: Calculated values based on raw data - Performance: Avoiding redundant computations through memoization</p>"},{"location":"api/api/#key-characteristics","title":"Key Characteristics","text":"<ul> <li>Read-only: Computed values cannot be set directly</li> <li>Lazy Evaluation: Only recalculate when accessed and dependencies changed</li> <li>Automatic Dependencies: Framework tracks what observables are accessed</li> <li>Pure Functions: Computation functions should be pure (no side effects)</li> <li>Memoization: Results are cached until dependencies change</li> </ul>"},{"location":"api/api/#basic-usage","title":"Basic Usage","text":"<pre><code>from fynx import observable, computed\n\n# Create base observables\nprice = observable(10.0)\nquantity = observable(5)\n\n# Create computed value\ntotal = computed(lambda p, q: p * q, price | quantity)\nprint(total.value)  # 50.0\n\n# Changes propagate automatically\nprice.set(12.0)\nprint(total.value)  # 60.0 (automatically recalculated)\n</code></pre>"},{"location":"api/api/#advanced-patterns","title":"Advanced Patterns","text":""},{"location":"api/api/#single-observable-computations","title":"Single Observable Computations","text":"<pre><code>counter = observable(5)\ndoubled = computed(lambda x: x * 2, counter)\nprint(doubled.value)  # 10\n\ncounter.set(7)\nprint(doubled.value)  # 14\n</code></pre>"},{"location":"api/api/#complex-computations","title":"Complex Computations","text":"<pre><code># Multiple observables\nwidth = observable(10)\nheight = observable(20)\ndepth = observable(5)\n\n# Computed volume\nvolume = computed(lambda w, h, d: w * h * d, width | height | depth)\nprint(volume.value)  # 1000\n\n# Computed surface area\nsurface_area = computed(\n    lambda w, h, d: 2 * (w*h + h*d + d*w),\n    width | height | depth\n)\nprint(surface_area.value)  # 400\n</code></pre>"},{"location":"api/api/#chaining-computations","title":"Chaining Computations","text":"<pre><code>base_price = observable(100)\ntax_rate = observable(0.08)\n\n# First computation\nsubtotal = computed(lambda price: price * 1.1, base_price)  # 10% markup\n\n# Second computation based on first\ntax = computed(lambda subtotal: subtotal * tax_rate.value, subtotal)\n\n# Final computation\ntotal = computed(lambda subtotal: subtotal + tax.value, subtotal)\n\nprint(f\"Base: ${base_price.value}, Total: ${total.value}\")\n# Base: $100, Total: $118.8\n</code></pre>"},{"location":"api/api/#dictionaryobject-computations","title":"Dictionary/Object Computations","text":"<pre><code>user = observable({\"name\": \"Alice\", \"age\": 30})\n\n# Computed display name\ndisplay_name = computed(\n    lambda u: f\"{u['name']} ({u['age']} years old)\",\n    user\n)\nprint(display_name.value)  # \"Alice (30 years old)\"\n\nuser.set({\"name\": \"Bob\", \"age\": 25})\nprint(display_name.value)  # \"Bob (25 years old)\"\n</code></pre>"},{"location":"api/api/#store-integration","title":"Store Integration","text":"<p>Computed values work seamlessly with Stores:</p> <pre><code>from fynx import Store, observable, computed\n\nclass CartStore(Store):\n    items = observable([\n        {\"name\": \"Widget\", \"price\": 10, \"quantity\": 2},\n        {\"name\": \"Gadget\", \"price\": 15, \"quantity\": 1}\n    ])\n\n    @computed\n    def total_items(self):\n        return sum(item[\"quantity\"] for item in self.items)\n\n    @computed\n    def total_price(self):\n        return sum(item[\"price\"] * item[\"quantity\"] for item in self.items)\n\nprint(f\"Items: {CartStore.total_items}, Total: ${CartStore.total_price}\")\n# Items: 3, Total: $35\n\n# Add new item reactively\nCartStore.items = CartStore.items + [{\"name\": \"Tool\", \"price\": 20, \"quantity\": 1}]\nprint(f\"Items: {CartStore.total_items}, Total: ${CartStore.total_price}\")\n# Items: 4, Total: $55\n</code></pre>"},{"location":"api/api/#performance-optimization","title":"Performance Optimization","text":"<p>Computed values include several performance optimizations:</p> <p>Lazy Evaluation: Values only recalculate when accessed after dependencies change:</p> <pre><code>expensive_calc = computed(lambda: slow_computation(), some_obs)\n# slow_computation() only runs when expensive_calc.value is accessed\n</code></pre> <p>Dependency Tracking: Only tracks observables actually accessed during computation:</p> <pre><code>result = computed(\n    lambda: some_obs.value if condition else default_value,\n    some_obs  # Only some_obs is tracked as dependency\n)\n</code></pre> <p>Memoization: Results are cached until dependencies actually change:</p> <pre><code># This computation runs once, then is cached\nmemoized = computed(lambda: expensive_op(), obs)\nprint(memoized.value)  # Runs expensive_op()\nprint(memoized.value)  # Returns cached result\n\nobs.set(new_value)     # Cache invalidated\nprint(memoized.value)  # Runs expensive_op() again\n</code></pre>"},{"location":"api/api/#best-practices","title":"Best Practices","text":""},{"location":"api/api/#function-purity","title":"Function Purity","text":"<p>Computed functions should be pure (no side effects):</p> <pre><code># Good: Pure function\nclean_total = computed(lambda items: sum(item.price for item in items), items)\n\n# Bad: Side effects\ndirty_total = computed(\n    lambda items: print(\"Calculating...\") or sum(item.price for item in items),\n    items\n)\n</code></pre>"},{"location":"api/api/#error-handling","title":"Error Handling","text":"<p>Handle potential errors gracefully:</p> <pre><code>safe_division = computed(\n    lambda a, b: a / b if b != 0 else 0,\n    num | denom\n)\n</code></pre>"},{"location":"api/api/#complex-dependencies","title":"Complex Dependencies","text":"<p>For complex dependency logic, consider breaking into smaller computations:</p> <pre><code># Instead of one complex computation\ncomplex_calc = computed(\n    lambda a, b, c, d: expensive_calc(a + b, c * d),\n    obs_a | obs_b | obs_c | obs_d\n)\n\n# Break into smaller, more efficient computations\nsum_ab = computed(lambda a, b: a + b, obs_a | obs_b)\nprod_cd = computed(lambda c, d: c * d, obs_c | obs_d)\nfinal = computed(lambda ab, cd: expensive_calc(ab, cd), sum_ab | prod_cd)\n</code></pre>"},{"location":"api/api/#common-patterns_1","title":"Common Patterns","text":"<p>Filtering and Transformation: <pre><code>numbers = observable([1, 2, 3, 4, 5])\nevens = computed(lambda nums: [n for n in nums if n % 2 == 0], numbers)\nsum_even = computed(lambda evens: sum(evens), evens)\n</code></pre></p> <p>Validation: <pre><code>email = observable(\"user@example.com\")\nis_valid_email = computed(\n    lambda e: \"@\" in e and \".\" in e.split(\"@\")[1],\n    email\n)\n</code></pre></p> <p>Formatting: <pre><code>amount = observable(1234.56)\nformatted = computed(lambda a: f\"${a:,.2f}\", amount)\n</code></pre></p> <p>Conditional Logic: <pre><code>status = observable(\"loading\")\nis_loading = computed(lambda s: s == \"loading\", status)\nis_error = computed(lambda s: s == \"error\", status)\nis_success = computed(lambda s: s == \"success\", status)\n</code></pre></p>"},{"location":"api/api/#limitations","title":"Limitations","text":"<ul> <li>Computed functions cannot modify observables (would create circular dependencies)</li> <li>Dependencies must be accessed synchronously during computation</li> <li>Computed values cannot depend on external state that changes independently</li> </ul>"},{"location":"api/api/#troubleshooting","title":"Troubleshooting","text":"<p>Computation not updating: Check that all accessed observables are properly passed to computed()</p> <pre><code># Wrong: external_obs not passed as dependency\nexternal_obs = observable(10)\nwrong = computed(lambda: external_obs.value * 2, some_obs)  # Won't track external_obs\n\n# Right: include all dependencies\nright = computed(lambda: external_obs.value * 2, some_obs | external_obs)\n</code></pre> <p>Performance issues: Break complex computations into smaller ones to enable better caching</p> <p>Circular dependencies: Computed values cannot depend on themselves or create cycles</p>"},{"location":"api/api/#see-also_1","title":"See Also","text":"<ul> <li><code>fynx.observable</code>: Core observable classes and operators</li> <li><code>fynx.store</code>: Organizing observables into reactive state containers</li> <li><code>fynx.watch</code>: Conditional reactive functions</li> </ul>"},{"location":"api/api/#computed","title":"computed","text":"<pre><code>def computed(func: Callable, observable) -&gt; ComputedObservable\n</code></pre> <p>Create a computed observable that derives its value from other observables.</p> <p>The <code>computed</code> function creates a new observable whose value is automatically calculated by applying the given function to the values of the input observable(s). When the input observable(s) change, the computed observable automatically updates.</p> <p>This implements the functorial map operation over observables, allowing you to transform observable values through pure functions while preserving reactivity.</p> <p>Arguments:</p> <ul> <li><code>func</code> - A pure function that computes the derived value. For merged observables,   the function receives individual values as separate arguments. For single   observables, it receives the single value.</li> <li><code>observable</code> - The source observable(s) to compute from. Can be a single Observable   or a MergedObservable (created with the <code>|</code> operator).</li> </ul> <p>Returns:</p> <p>A new ComputedObservable containing the computed values. The observable will   automatically update whenever the source observable(s) change.</p> <p>Examples:</p> <pre><code>```python\nfrom fynx import observable, computed\n\n# Single observable computation\ncounter = observable(5)\ndoubled = computed(lambda x: x * 2, counter)\nprint(doubled.value)  # 10\n\ncounter.set(7)\nprint(doubled.value)  # 14\n\n# Merged observable computation\nwidth = observable(10)\nheight = observable(20)\ndimensions = width | height\n\narea = computed(lambda w, h: w * h, dimensions)\nprint(area.value)  # 200\n\n# More complex computation\nperson = observable({\"name\": \"Alice\", \"age\": 30})\ngreeting = computed(\n    lambda p: f\"Hello {p['name']}, you are {p['age']} years old!\",\n    person\n)\nprint(greeting.value)  # \"Hello Alice, you are 30 years old!\"\n```\n</code></pre> <p>Notes:</p> <p>Computed functions should be pure (no side effects) and relatively fast,   as they may be called frequently when dependencies change.</p> <p>See Also:</p> <ul> <li><code>observable</code> - Create basic observables</li> <li><code>ComputedObservable</code> - The returned observable type</li> <li><code>MergedObservable</code> - For combining multiple observables</li> </ul> <p></p>"},{"location":"api/api/#fynxreactive","title":"fynx.reactive","text":""},{"location":"api/api/#fynx-reactive-reactive-decorators-and-utilities","title":"FynX Reactive - Reactive Decorators and Utilities","text":"<p>This module provides decorators and utilities for creating reactive relationships between observables and functions. Reactive decorators enable automatic execution of functions when their observable dependencies change, perfect for side effects like UI updates, API calls, logging, and other imperative operations.</p>"},{"location":"api/api/#what-are-reactive-functions","title":"What are Reactive Functions?","text":"<p>Reactive functions are functions that automatically re-run whenever the observables they depend on change. Unlike computed values (which are declarative and return derived data), reactive functions are imperative and perform side effects.</p> <p>Reactive functions are ideal for: - UI Updates: Automatically updating displays when data changes - API Calls: Triggering network requests when relevant data changes - Logging: Recording changes for debugging or analytics - Side Effects: Any imperative operation that should respond to data changes - Synchronization: Keeping external systems in sync with reactive state</p>"},{"location":"api/api/#key-characteristics_1","title":"Key Characteristics","text":"<ul> <li>Automatic Execution: Functions run whenever dependencies change</li> <li>Imperative: Designed for side effects, not data transformation</li> <li>Dependency Tracking: Framework automatically tracks accessed observables</li> <li>Unsubscription: Easy cleanup when reactive functions are no longer needed</li> <li>Multiple Targets: Can react to multiple observables or entire stores</li> </ul>"},{"location":"api/api/#basic-usage_1","title":"Basic Usage","text":"<pre><code>```python\nfrom fynx import Store, observable, reactive\n</code></pre> <p>class CounterStore(Store):     count = observable(0)     name = observable(\"Counter\")</p> <p>@reactive(CounterStore.count, CounterStore.name) def log_counter_changes(count, name):     print(f\"Counter '{name}' changed to: {count}\")</p> <p>Changes trigger the reactive function automatically</p> <p>CounterStore.count = 5   # Prints: \"Counter 'Counter' changed to: 5\" CounterStore.name = \"My Counter\"  # Prints: \"Counter 'My Counter' changed to: 5\" CounterStore.count = 10  # Prints: \"Counter 'My Counter' changed to: 10\" <pre><code>Advanced Patterns\n-----------------\n\n### Store-Level Reactions\n\nReact to any change in an entire store:\n\n```python\n    class UserStore(Store):\n        name = observable(\"Alice\")\n        age = observable(30)\n    email = observable(\"alice@example.com\")\n\n@reactive(UserStore)  # Reacts to any change in UserStore\ndef on_any_user_change():\n    snapshot = UserStore.to_dict()\n    print(f\"User data changed: {snapshot}\")\n\nUserStore.name = \"Bob\"   # Triggers: User data changed: {'name': 'Bob', 'age': 30, 'email': 'alice@example.com'}\nUserStore.age = 31       # Triggers again with updated data\n</code></pre></p>"},{"location":"api/api/#mixed-observable-types","title":"Mixed Observable Types","text":"<p>Combine store-level and individual observable reactions:</p> <pre><code>__React to store changes and a specific external observable__\n\nis_online = observable(True)\n\n@reactive(UserStore, is_online)\ndef on_user_or_online_change():\n    user_data = UserStore.to_dict()\n    online_status = \"online\" if is_online.value else \"offline\"\n    print(f\"User {user_data['name']} is {online_status}\")\n\nUserStore.name = \"Charlie\"  # Triggers with current online status\nis_online.set(False)       # Triggers with current user data\n</code></pre>"},{"location":"api/api/#cleanup-and-unsubscription","title":"Cleanup and Unsubscription","text":"<p>Reactive functions can be unsubscribed when no longer needed:</p> <pre><code>__The reactive decorator returns the original function__\n\n__so you can unsubscribe later if needed__\n\nunsubscribe_func = reactive(CounterStore.count)(log_changes)\n__Later...__\n\n__CounterStore.count.unsubscribe(log_changes)  # Unsubscribe specific function__\n</code></pre>"},{"location":"api/api/#real-world-examples","title":"Real-World Examples","text":""},{"location":"api/api/#ui-update-simulation","title":"UI Update Simulation","text":"<pre><code>class ViewModel(Store):\n    search_query = observable(\"\")\n    results = observable([])\n    is_loading = observable(False)\n\n@reactive(ViewModel.search_query)\ndef update_search_results(query):\n    if query:\n        ViewModel.is_loading = True\n        # Simulate API call\n        ViewModel.results = [f\"Result for '{query}'\"]\n        ViewModel.is_loading = False\n    else:\n        ViewModel.results = []\n\n@reactive(ViewModel.results, ViewModel.is_loading)\ndef update_ui(results, loading):\n    if loading:\n        print(\"\ud83d\udd04 Loading...\")\n    else:\n        print(f\"\ud83d\udccb Found {len(results)} results: {results}\")\n\nViewModel.search_query = \"python\"  # Triggers both functions\n</code></pre>"},{"location":"api/api/#form-validation","title":"Form Validation","text":"<pre><code>class FormStore(Store):\n    email = observable(\"\")\n    password = observable(\"\")\n    is_submitting = observable(False)\n\n@reactive(FormStore.email)\ndef validate_email(email):\n    is_valid = \"@\" in email and len(email) &gt; 5\n    print(f\"Email valid: {is_valid}\")\n\n@reactive(FormStore.password)\ndef validate_password(password):\n    is_strong = len(password) &gt;= 8\n    print(f\"Password strong: {is_strong}\")\n\nFormStore.email = \"user@\"       # Email valid: False\nFormStore.email = \"user@example.com\"  # Email valid: True\nFormStore.password = \"123\"      # Password strong: False\nFormStore.password = \"secure123\" # Password strong: True\n</code></pre>"},{"location":"api/api/#analytics-tracking","title":"Analytics Tracking","text":"<pre><code>class AnalyticsStore(Store):\n    page_views = observable(0)\n    unique_visitors = observable(0)\n    current_page = observable(\"home\")\n\n@reactive(AnalyticsStore.page_views)\ndef track_page_views(views):\n    print(f\"\ud83d\udcca Analytics: {views} page views\")\n\n@reactive(AnalyticsStore.current_page)\ndef track_page_changes(page):\n    print(f\"\ud83d\udccd User navigated to: {page}\")\n\nAnalyticsStore.page_views = 150\nAnalyticsStore.current_page = \"products\"\nAnalyticsStore.page_views = 151  # Both functions trigger\n</code></pre>"},{"location":"api/api/#performance-considerations_1","title":"Performance Considerations","text":"<p>Reactive functions include several performance optimizations:</p> <p>Efficient Tracking: Only tracks observables actually accessed during function execution</p> <p>Batch Updates: Multiple observable changes in quick succession trigger the function only once</p> <p>Memory Management: Automatic cleanup when reactive contexts are no longer needed</p> <p>Selective Execution: Functions only run when their specific dependencies change</p>"},{"location":"api/api/#best-practices_1","title":"Best Practices","text":""},{"location":"api/api/#keep-functions-focused","title":"Keep Functions Focused","text":"<p>Each reactive function should have a single, clear responsibility:</p> <pre><code>__Good: Focused responsibilities__\n\n@reactive(user_data)\ndef update_profile_ui(user_data):\n    # Only handles UI updates\n    pass\n\n@reactive(user_data)\ndef sync_to_server(user_data):\n    # Only handles server sync\n    pass\n\n__Avoid: Mixed responsibilities__\n\n@reactive(user_data)\ndef handle_user_change(user_data):\n    # Updates UI, syncs to server, logs analytics...\n    pass\n</code></pre>"},{"location":"api/api/#handle-errors-gracefully","title":"Handle Errors Gracefully","text":"<p>Reactive functions should handle exceptions to prevent breaking the reactive system:</p> <pre><code>@reactive(data)\ndef process_data_safely(data):\n    try:\n        # Process data...\n        result = expensive_operation(data)\n        update_ui(result)\n    except Exception as e:\n        print(f\"Error processing data: {e}\")\n        show_error_message()\n</code></pre>"},{"location":"api/api/#use-appropriate-granularity","title":"Use Appropriate Granularity","text":"<p>Choose the right level of reactivity for your use case:</p> <pre><code>__Fine-grained: React to specific changes__\n\n@reactive(store.specific_field)\ndef handle_specific_change(value):\n    pass\n\n__Coarse-grained: React to any store change__\n\n@reactive(store)\ndef handle_any_change():\n    pass\n</code></pre>"},{"location":"api/api/#common-patterns_2","title":"Common Patterns","text":"<p>Event Logging: <pre><code>@reactive(store)\ndef log_all_changes():\n    print(f\"State changed at {datetime.now()}: {store.to_dict()}\")\n</code></pre></p> <p>Cache Invalidation: <pre><code>cache = {}\n@reactive(data_version)\ndef invalidate_cache(version):\n    cache.clear()\n    print(f\"Cache invalidated for version {version}\")\n</code></pre></p> <p>External System Sync: <pre><code>@reactive(local_data)\ndef sync_to_external_system(data):\n    external_api.update(data)\n    print(\"Synced to external system\")\n</code></pre></p>"},{"location":"api/api/#limitations_1","title":"Limitations","text":"<ul> <li>Reactive functions cannot return values (use computed for that)</li> <li>Dependencies must be accessed synchronously during execution</li> <li>Functions execute for every dependency change (no debouncing built-in)</li> <li>Cannot create circular dependencies with observables</li> </ul>"},{"location":"api/api/#troubleshooting_1","title":"Troubleshooting","text":"<p>Function not triggering: Ensure all accessed observables are passed as arguments to @reactive</p> <pre><code>__Wrong: external_obs not declared as dependency__\n\nexternal_obs = observable(10)\n@reactive(some_obs)\ndef wrong_func():\n    value = external_obs.value  # Not tracked!\n\n__Right: Declare all dependencies__\n\n@reactive(some_obs, external_obs)\ndef right_func(some_val, external_val):\n    pass\n</code></pre> <p>Too many executions: Consider using @watch for conditional execution instead</p> <p>Performance issues: Break large reactive functions into smaller, focused ones</p>"},{"location":"api/api/#comparison-with-other-approaches","title":"Comparison with Other Approaches","text":"<p>vs Manual Subscriptions: <pre><code>__Manual (error-prone)__\n\ndef setup():\n    obs.subscribe(callback)\n    obs2.subscribe(callback)\n    # Must manually unsubscribe later...\n\n__Reactive (declarative)__\n\n@reactive(obs, obs2)\ndef callback():\n    pass  # Automatically managed\n</code></pre></p> <p>vs Computed Values: - Use @reactive for side effects (UI updates, API calls) - Use @computed for derived data (calculations, transformations)</p> <p>vs Watch Decorators: - Use @reactive for unconditional reactions to changes - Use @watch for conditional execution (only when conditions met)</p>"},{"location":"api/api/#see-also_2","title":"See Also","text":"<ul> <li><code>fynx.watch</code>: Conditional reactive functions</li> <li><code>fynx.computed</code>: Derived reactive values</li> <li><code>fynx.store</code>: Reactive state containers</li> <li><code>fynx.observable</code>: Core observable classes</li> </ul>"},{"location":"api/api/#reactivehandler-objects","title":"ReactiveHandler Objects","text":"<pre><code>class ReactiveHandler()\n</code></pre> <p>Manages reactive function subscriptions and handles different target types.</p> <p>ReactiveHandler is the core implementation behind the <code>@reactive</code> decorator. It intelligently handles different types of targets (Store classes, individual observables) and creates the appropriate subscription mechanism.</p> <p>The handler supports: - Store class subscriptions (reacts to any change in the store) - Individual observable subscriptions (reacts to specific observables) - Mixed subscriptions (combination of stores and observables)</p> <p>This class is typically used indirectly through the <code>@reactive</code> decorator rather than instantiated directly.</p> <p>Example:</p> <pre><code>```python\n# These all use ReactiveHandler internally:\n@reactive(store_instance)      # Store subscription\n@reactive(obs1, obs2)          # Multiple observables\n@reactive(store_class.attr)    # Single observable\n```\n</code></pre> <p></p>"},{"location":"api/api/#__init__","title":"__init__","text":"<pre><code>def __init__(*targets)\n</code></pre> <p>Initialize the reactive handler with target observables/stores.</p> <p>Arguments:</p> <ul> <li><code>*targets</code> - Variable number of observables, stores, or store attributes   to monitor for changes.</li> </ul> <p></p>"},{"location":"api/api/#__call__","title":"__call__","text":"<pre><code>def __call__(func: Callable) -&gt; Callable\n</code></pre> <p>Decorator implementation that makes the function reactive.</p> <p>This method is called when the ReactiveHandler is used as a decorator. It sets up the reactive context for the decorated function and returns the original function (decorators typically return the same function).</p> <p>Arguments:</p> <ul> <li><code>func</code> - The function to make reactive</li> </ul> <p>Returns:</p> <p>The original function, now configured to react to target changes</p> <p>Example:</p> <pre><code>```python\n@reactive(store.count, store.name)\ndef update_display(count, name):\n    print(f\"Count: {count}, Name: {name}\")\n\n# This is equivalent to:\n# reactive_handler = ReactiveHandler(store.count, store.name)\n# update_display = reactive_handler(update_display)\n```\n</code></pre> <p></p>"},{"location":"api/api/#reactive","title":"reactive","text":"<pre><code>def reactive(*targets)\n</code></pre> <p>Create a reactive handler that works as a decorator.</p> <p>This is a convenience wrapper around subscribe() that works as a decorator.</p> <p>As decorator: @reactive(store) - reacts to all observables in store @reactive(observable) - reacts to single observable @reactive(obs1, obs2, ...) - reacts to multiple observables</p> <p>Arguments:</p> <ul> <li><code>*targets</code> - Store class, Observable instance(s), or multiple Observable instances</li> </ul> <p>Returns:</p> <p>ReactiveHandler that can be used as decorator</p> <p></p>"},{"location":"api/api/#fynxregistry","title":"fynx.registry","text":""},{"location":"api/api/#fynx-registry-global-reactive-context-management","title":"FynX Registry - Global Reactive Context Management","text":"<p>This module provides global registries that track reactive contexts and their relationships. These registries enable efficient subscription management and cleanup across the entire FynX reactive system.</p> <p>Global Registries: - _all_reactive_contexts: Set of all active ReactiveContext instances - _func_to_contexts: Mapping from user functions to their reactive contexts</p> <p>These registries support: - Efficient Unsubscription: O(1) lookup of contexts by function - Memory Management: Tracking all active contexts for cleanup - Cross-Component Coordination: Managing reactive relationships globally - Debugging Support: Inspecting active reactive contexts</p> <p>The registries are primarily used internally by Observable and Store classes for managing subscriptions and ensuring proper cleanup when reactive contexts are no longer needed.</p> <p></p>"},{"location":"api/api/#fynxstore","title":"fynx.store","text":""},{"location":"api/api/#fynx-store-reactive-state-management-components","title":"FynX Store - Reactive State Management Components","text":"<p>This module provides the core components for reactive state management in FynX, enabling you to create organized, reactive state containers that group related observables together with convenient subscription and state management methods.</p>"},{"location":"api/api/#why-use-stores","title":"Why Use Stores?","text":"<p>Stores help you organize your application's reactive state into logical units. Instead of having observables scattered throughout your codebase, Stores group related data together and provide convenient methods for subscribing to changes, serializing state, and managing the reactive lifecycle.</p> <p>Stores are particularly useful for: - Application State: Global app state like user preferences, theme settings - Feature State: State for specific features like shopping cart, user profile - Component State: Local state that needs to be shared across multiple components - Business Logic: Computed values and derived state based on raw data</p>"},{"location":"api/api/#core-components","title":"Core Components","text":"<p>Store: A base class for creating reactive state containers. Store classes can define observable attributes using the <code>observable()</code> descriptor, and automatically provide methods for subscribing to changes and managing state.</p> <p>observable: A descriptor function that creates observable attributes on Store classes. Use this to define reactive properties in your Store subclasses.</p> <p>StoreSnapshot: An immutable snapshot of store state at a specific point in time, useful for debugging, logging, and ensuring consistent state access.</p> <p>StoreMeta: A metaclass that automatically converts observable attributes to descriptors and provides type hint compatibility for mypy.</p>"},{"location":"api/api/#key-features_1","title":"Key Features","text":"<ul> <li>Automatic Observable Management: Store metaclass handles observable creation</li> <li>Convenient Subscriptions: Subscribe to all changes or individual observables</li> <li>State Serialization: Save and restore store state with <code>to_dict()</code> and <code>load_state()</code></li> <li>Type Safety: Full type hint support for better IDE experience</li> <li>Memory Efficient: Automatic cleanup and efficient change detection</li> <li>Composable: Easy to combine and nest multiple stores</li> </ul>"},{"location":"api/api/#basic-usage_2","title":"Basic Usage","text":"<pre><code>from fynx import Store, observable\n\nclass CounterStore(Store):\n    count = observable(0)\n    name = observable(\"My Counter\")\n\n# Access values like regular attributes\nprint(CounterStore.count)  # 0\nCounterStore.count = 5     # Updates the observable\n\n# Subscribe to all changes in the store\n@CounterStore.subscribe\ndef on_store_change(snapshot):\n    print(f\"Store changed: count={snapshot.count}, name={snapshot.name}\")\n\nCounterStore.count = 10  # Triggers: \"Store changed: count=10, name=My Counter\"\n</code></pre>"},{"location":"api/api/#advanced-patterns_1","title":"Advanced Patterns","text":""},{"location":"api/api/#computed-properties-in-stores","title":"Computed Properties in Stores","text":"<pre><code>from fynx import Store, observable, computed\n\nclass UserStore(Store):\n    first_name = observable(\"John\")\n    last_name = observable(\"Doe\")\n    age = observable(30)\n\n    @computed\n    def full_name(self):\n        return f\"{self.first_name} {self.last_name}\"\n\n    @computed\n    def is_adult(self):\n        return self.age &gt;= 18\n\nprint(UserStore.full_name)  # \"John Doe\"\nUserStore.first_name = \"Jane\"\nprint(UserStore.full_name)  # \"Jane Doe\" (automatically updated)\n</code></pre>"},{"location":"api/api/#state-persistence","title":"State Persistence","text":"<pre><code># Save store state\nstate = CounterStore.to_dict()\n# state = {\"count\": 10, \"name\": \"My Counter\"}\n\n# Restore state later\nCounterStore.load_state(state)\nprint(CounterStore.count)  # 10\n</code></pre>"},{"location":"api/api/#store-composition","title":"Store Composition","text":"<pre><code>class AppStore(Store):\n    theme = observable(\"light\")\n    language = observable(\"en\")\n\nclass UserStore(Store):\n    name = observable(\"Alice\")\n    preferences = observable({})\n\n# Use both stores independently\nAppStore.theme = \"dark\"\nUserStore.name = \"Bob\"\n</code></pre>"},{"location":"api/api/#store-lifecycle","title":"Store Lifecycle","text":"<p>Stores automatically manage the lifecycle of their observables:</p> <ol> <li> <p>Creation: When you define a Store subclass, the metaclass automatically    converts <code>observable()</code> calls into reactive descriptors.</p> </li> <li> <p>Access: When you access store attributes, you get transparent reactive values    that behave like regular Python attributes.</p> </li> <li> <p>Updates: When you assign to store attributes, the underlying observables are    updated and all dependent computations and reactions are notified.</p> </li> <li> <p>Cleanup: Reactive contexts are automatically cleaned up when no longer needed.</p> </li> </ol>"},{"location":"api/api/#performance-considerations_2","title":"Performance Considerations","text":"<ul> <li>Efficient Updates: Only notifies subscribers when values actually change</li> <li>Lazy Evaluation: Computed properties only recalculate when accessed</li> <li>Memory Management: Automatic cleanup of unused reactive contexts</li> <li>Batch Updates: Multiple changes in quick succession are efficiently handled</li> </ul>"},{"location":"api/api/#best-practices_2","title":"Best Practices","text":"<ul> <li>Group Related State: Keep related observables together in the same store</li> <li>Use Descriptive Names: Name your stores and observables clearly</li> <li>Avoid Large Stores: Split very large stores into smaller, focused ones</li> <li>Use Computed for Derived State: Don't store derived values manually</li> <li>Handle Errors: Reactive functions should handle exceptions gracefully</li> <li>Document Store Purpose: Use docstrings to explain what each store manages</li> </ul>"},{"location":"api/api/#common-patterns_3","title":"Common Patterns","text":"<p>Singleton Stores: Use class-level access for global state:</p> <pre><code>class GlobalStore(Store):\n    is_loading = observable(False)\n    current_user = observable(None)\n\n# Access globally\nGlobalStore.is_loading = True\n</code></pre> <p>Instance Stores: Create store instances for per-component state:</p> <pre><code>class TodoStore(Store):\n    items = observable([])\n    filter = observable(\"all\")\n\nstore = TodoStore()  # Instance with its own state\n</code></pre> <p>Store Communication: Stores can reference each other:</p> <pre><code>class AuthStore(Store):\n    is_logged_in = observable(False)\n    user_id = observable(None)\n\nclass DataStore(Store):\n    @computed\n    def can_fetch_data(self):\n        return AuthStore.is_logged_in\n</code></pre>"},{"location":"api/api/#migration-from-plain-observables","title":"Migration from Plain Observables","text":"<p>If you're using plain observables and want to migrate to Stores:</p> <pre><code># Before: Plain observables\nuser_name = observable(\"Alice\")\nuser_age = observable(30)\n\n# After: Store-based\nclass UserStore(Store):\n    name = observable(\"Alice\")\n    age = observable(30)\n\n# Access remains similar\nUserStore.name = \"Bob\"  # Instead of user_name.set(\"Bob\")\n</code></pre>"},{"location":"api/api/#error-handling_1","title":"Error Handling","text":"<p>Stores handle errors gracefully:</p> <ul> <li>Observable updates that fail don't break the reactive system</li> <li>Computed property errors are logged but don't prevent other updates</li> <li>Store serialization handles missing or invalid data</li> </ul>"},{"location":"api/api/#debugging","title":"Debugging","text":"<p>Use StoreSnapshot for debugging:</p> <pre><code># Capture current state\nsnapshot = StoreSnapshot(CounterStore, CounterStore._get_observable_attrs())\nprint(snapshot)  # Shows all observable values\n\n# Compare states\nold_snapshot = snapshot\n# ... do some operations ...\nnew_snapshot = StoreSnapshot(CounterStore, CounterStore._get_observable_attrs())\n# Compare old_snapshot and new_snapshot\n</code></pre>"},{"location":"api/api/#see-also_3","title":"See Also","text":"<ul> <li><code>fynx.observable</code>: Core observable classes and operators</li> <li><code>fynx.computed</code>: Creating computed properties</li> <li><code>fynx.reactive</code>: Reactive decorators for side effects</li> <li><code>fynx.watch</code>: Conditional reactive functions</li> </ul>"},{"location":"api/api/#storesnapshot-objects","title":"StoreSnapshot Objects","text":"<pre><code>class StoreSnapshot()\n</code></pre> <p>Immutable snapshot of store observable values at a specific point in time.</p> <p></p>"},{"location":"api/api/#__getattr__","title":"__getattr__","text":"<pre><code>def __getattr__(name: str) -&gt; Any\n</code></pre> <p>Access snapshot values or fall back to class attributes.</p> <p></p>"},{"location":"api/api/#observable","title":"observable","text":"<pre><code>def observable(initial_value: Optional[T] = None) -&gt; Any\n</code></pre> <p>Create an observable with an initial value, used as a descriptor in Store classes.</p> <p></p>"},{"location":"api/api/#storemeta-objects","title":"StoreMeta Objects","text":"<pre><code>class StoreMeta(type)\n</code></pre> <p>Metaclass for Store to automatically convert observable attributes to descriptors and adjust type hints for mypy compatibility.</p> <p></p>"},{"location":"api/api/#__setattr__","title":"__setattr__","text":"<pre><code>def __setattr__(cls, name: str, value: Any) -&gt; None\n</code></pre> <p>Intercept class attribute assignment for observables.</p> <p></p>"},{"location":"api/api/#store-objects","title":"Store Objects","text":"<pre><code>class Store(metaclass=StoreMeta)\n</code></pre> <p>Base class for reactive state containers with observable attributes.</p> <p>Store provides a convenient way to group related observable values together and manage their lifecycle as a cohesive unit. Store subclasses can define observable attributes using the <code>observable()</code> descriptor, and Store provides methods for subscribing to changes, serializing state, and managing the reactive relationships.</p> <p>Key Features: - Automatic observable attribute detection and management - Convenient subscription methods for reacting to state changes - Serialization/deserialization support for persistence - Snapshot functionality for debugging and state inspection</p> <p>Example:</p> <pre><code>```python\nfrom fynx import Store, observable\n\nclass CounterStore(Store):\n    count = observable(0)\n    name = observable(\"Counter\")\n\n# Subscribe to all changes\n@CounterStore.subscribe\ndef on_change(snapshot):\n    print(f\"Counter: {snapshot.count}, Name: {snapshot.name}\")\n\n# Changes trigger reactions\nCounterStore.count = 5  # Prints: Counter: 5, Name: Counter\nCounterStore.name = \"My Counter\"  # Prints: Counter: 5, Name: My Counter\n```\n</code></pre> <p>Notes:</p> <p>Store uses a metaclass to intercept attribute assignment, allowing   <code>Store.attr = value</code> syntax to work seamlessly with observables.</p> <p></p>"},{"location":"api/api/#to_dict","title":"to_dict","text":"<pre><code>@classmethod\ndef to_dict(cls) -&gt; Dict[str, SessionValue]\n</code></pre> <p>Serialize all observable values to a dictionary.</p> <p></p>"},{"location":"api/api/#load_state","title":"load_state","text":"<pre><code>@classmethod\ndef load_state(cls, state_dict: Dict[str, SessionValue]) -&gt; None\n</code></pre> <p>Load state from a dictionary into the store's observables.</p> <p></p>"},{"location":"api/api/#subscribe","title":"subscribe","text":"<pre><code>@classmethod\ndef subscribe(cls, func: Callable[[StoreSnapshot], None]) -&gt; None\n</code></pre> <p>Subscribe a function to react to all observable changes.</p> <p></p>"},{"location":"api/api/#unsubscribe","title":"unsubscribe","text":"<pre><code>@classmethod\ndef unsubscribe(cls, func: Callable) -&gt; None\n</code></pre> <p>Unsubscribe a function from all observables.</p> <p></p>"},{"location":"api/api/#fynxwatch","title":"fynx.watch","text":""},{"location":"api/api/#fynx-watch-conditional-reactive-utilities","title":"FynX Watch - Conditional Reactive Utilities","text":"<p>This module provides the <code>watch</code> decorator for creating conditional reactive computations that only execute when specific conditions are met. Unlike <code>@reactive</code> decorators that run on every change, <code>@watch</code> decorators only trigger when ALL specified conditions transition from unmet to met.</p>"},{"location":"api/api/#when-to-use-watch-vs-reactive","title":"When to Use Watch vs Reactive","text":"<p>Use <code>@watch</code> when you need: - Functions that should only run when specific prerequisites are satisfied - State machines that react differently based on application state - Event filtering to avoid unnecessary operations when conditions aren't right - Resource optimization by avoiding computations when not needed</p> <p>Use <code>@reactive</code> when you need: - Functions that should run on every change to their dependencies - Unconditional side effects like logging or UI updates - Immediate responses to any state change</p>"},{"location":"api/api/#key-characteristics_2","title":"Key Characteristics","text":"<ul> <li>Conditional Execution: Only runs when ALL conditions become true after being false</li> <li>Transition Detection: Triggers on false\u2192true transitions, not ongoing true states</li> <li>Automatic Discovery: Framework finds observables accessed in condition functions</li> <li>Multiple Conditions: Supports AND logic across multiple conditions</li> <li>Error Resilience: Gracefully handles condition evaluation failures</li> </ul>"},{"location":"api/api/#basic-usage_3","title":"Basic Usage","text":"<pre><code>from fynx import observable, watch\n\n# Setup state\nuser_online = observable(False)\nhas_messages = observable(0)\nnotification_enabled = observable(True)\n\n@watch(\n    lambda: user_online.value,           # User must be online\n    lambda: has_messages.value &gt; 0,      # Must have messages\n    lambda: notification_enabled.value   # Notifications must be enabled\n)\ndef send_notification():\n    print(f\"\ud83d\udcec Sending {has_messages.value} messages to user!\")\n\n# Only triggers when ALL conditions become true\nuser_online.set(True)        # Not yet (no messages)\nhas_messages.set(3)          # Not yet (notifications disabled)\nnotification_enabled.set(True)  # Now triggers: \"\ud83d\udcec Sending 3 messages to user!\"\n\nhas_messages.set(5)          # Triggers again: \"\ud83d\udcec Sending 5 messages to user!\"\nuser_online.set(False)       # Stop triggering\nhas_messages.set(10)         # No trigger (user offline)\n</code></pre>"},{"location":"api/api/#advanced-patterns_2","title":"Advanced Patterns","text":""},{"location":"api/api/#complex-conditions","title":"Complex Conditions","text":"<p>Conditions can be arbitrarily complex expressions:</p> <pre><code>temperature = observable(20)\nhumidity = observable(50)\nac_enabled = observable(True)\n\n@watch(\n    lambda: temperature.value &gt; 25,              # Hot enough\n    lambda: humidity.value &lt; 60,                 # Not too humid\n    lambda: ac_enabled.value,                    # AC is enabled\n    lambda: temperature.value &lt; 30 or humidity.value &lt; 40  # Either very hot OR very dry\n)\ndef activate_cooling():\n    print(\"\ud83c\udf21\ufe0f Activating air conditioning!\")\n</code></pre>"},{"location":"api/api/#state-machines","title":"State Machines","text":"<p>Use watch decorators to implement state machine transitions:</p> <pre><code>app_state = observable(\"loading\")\nuser_authenticated = observable(False)\ndata_loaded = observable(False)\n\n@watch(lambda: app_state.value == \"loading\")\ndef show_loading_screen():\n    print(\"\u23f3 Showing loading screen...\")\n\n@watch(\n    lambda: user_authenticated.value,\n    lambda: data_loaded.value,\n    lambda: app_state.value == \"ready\"\n)\ndef show_main_app():\n    print(\"\u2705 Showing main application!\")\n\n# State transitions\napp_state.set(\"authenticating\")\nuser_authenticated.set(True)\napp_state.set(\"loading_data\")\ndata_loaded.set(True)\napp_state.set(\"ready\")  # Now triggers show_main_app()\n</code></pre>"},{"location":"api/api/#resource-management","title":"Resource Management","text":"<p>Prevent unnecessary operations when resources aren't available:</p> <pre><code>network_available = observable(True)\nbattery_level = observable(100)\ndata_fresh = observable(False)\n\n@watch(\n    lambda: network_available.value,\n    lambda: battery_level.value &gt; 20,    # Don't sync on low battery\n    lambda: not data_fresh.value         # Only sync when data is stale\n)\ndef sync_data():\n    print(\"\ud83d\udd04 Syncing data...\")\n    # Perform expensive network operation\n    data_fresh.set(True)\n\nnetwork_available.set(False)\nbattery_level.set(15)\ndata_fresh.set(False)  # No sync (battery too low)\n\nbattery_level.set(80)\nnetwork_available.set(True)  # Triggers sync\n</code></pre>"},{"location":"api/api/#real-world-examples_1","title":"Real-World Examples","text":""},{"location":"api/api/#user-authentication-flow","title":"User Authentication Flow","text":"<pre><code>login_attempted = observable(False)\ncredentials_valid = observable(False)\ntwo_factor_complete = observable(False)\n\n@watch(\n    lambda: login_attempted.value,\n    lambda: credentials_valid.value,\n    lambda: two_factor_complete.value\n)\ndef grant_access():\n    print(\"\ud83d\udd10 Access granted!\")\n    # Redirect to dashboard, set session, etc.\n\n# Login flow\nlogin_attempted.set(True)\ncredentials_valid.set(True)\ntwo_factor_complete.set(True)  # Access granted\n</code></pre>"},{"location":"api/api/#shopping-cart-checkout","title":"Shopping Cart Checkout","text":"<pre><code>cart_items = observable([])\npayment_method = observable(None)\nterms_accepted = observable(False)\n\n@watch(\n    lambda: len(cart_items.value) &gt; 0,\n    lambda: payment_method.value is not None,\n    lambda: terms_accepted.value\n)\ndef enable_checkout():\n    print(\"\ud83d\udcb3 Checkout button enabled!\")\n\ncart_items.set([{\"name\": \"Widget\", \"price\": 10}])\npayment_method.set(\"credit_card\")\nterms_accepted.set(True)  # Checkout now enabled\n</code></pre>"},{"location":"api/api/#background-task-management","title":"Background Task Management","text":"<pre><code>task_queue = observable([])\nis_online = observable(True)\nbattery_saving = observable(False)\n\n@watch(\n    lambda: len(task_queue.value) &gt; 0,\n    lambda: is_online.value,\n    lambda: not battery_saving.value  # Don't run background tasks in battery saving mode\n)\ndef process_background_tasks():\n    print(f\"\ud83d\udd04 Processing {len(task_queue.value)} background tasks...\")\n\ntask_queue.set([\"sync\", \"backup\", \"cleanup\"])\nbattery_saving.set(True)     # No processing (battery saving)\nbattery_saving.set(False)    # Now triggers processing\n</code></pre>"},{"location":"api/api/#performance-considerations_3","title":"Performance Considerations","text":"<p>Efficient Evaluation: Conditions are only re-evaluated when their dependencies change</p> <p>Dependency Tracking: Only tracks observables actually accessed in conditions</p> <p>Transition Optimization: Only triggers on condition state changes, not every update</p> <p>Memory Management: Automatic cleanup when watch decorators are no longer needed</p>"},{"location":"api/api/#best-practices_3","title":"Best Practices","text":""},{"location":"api/api/#keep-conditions-simple","title":"Keep Conditions Simple","text":"<p>Break complex conditions into simpler, more focused ones:</p> <pre><code># Good: Simple, focused conditions\n@watch(lambda: user.is_authenticated)\ndef load_user_data():\n    pass\n\n@watch(lambda: user.has_premium_plan)\ndef enable_premium_features():\n    pass\n\n# Avoid: Complex condition logic\n@watch(lambda: user.is_authenticated and user.has_premium_plan and not user.is_banned)\ndef handle_premium_user():\n    pass\n</code></pre>"},{"location":"api/api/#use-descriptive-condition-names","title":"Use Descriptive Condition Names","text":"<p>Make conditions self-documenting:</p> <pre><code>def user_is_eligible():\n    return user.age &gt;= 18 and user.country in ALLOWED_COUNTRIES\n\ndef payment_is_complete():\n    return payment.status == \"completed\" and payment.amount &gt; 0\n\n@watch(user_is_eligible, payment_is_complete)\ndef process_purchase():\n    pass\n</code></pre>"},{"location":"api/api/#handle-errors-gracefully_1","title":"Handle Errors Gracefully","text":"<p>Conditions that fail during evaluation are treated as False:</p> <pre><code>@watch(\n    lambda: user.preferences is not None,  # Safe null check\n    lambda: user.preferences.get(\"notifications\", False)  # Safe dict access\n)\ndef send_notification():\n    pass\n</code></pre>"},{"location":"api/api/#common-patterns_4","title":"Common Patterns","text":"<p>Feature Flags: <pre><code>feature_enabled = observable(False)\nuser_has_access = observable(False)\n\n@watch(lambda: feature_enabled.value and user_has_access.value)\ndef enable_new_feature():\n    print(\"\u2728 New feature enabled!\")\n</code></pre></p> <p>Data Validation: <pre><code>email = observable(\"\")\npassword = observable(\"\")\n\n@watch(\n    lambda: \"@\" in email.value and \".\" in email.value.split(\"@\")[1],\n    lambda: len(password.value) &gt;= 8\n)\ndef enable_submit_button():\n    print(\"\u2705 Submit button enabled\")\n</code></pre></p> <p>Resource Availability: <pre><code>network_online = observable(True)\ndisk_space = observable(100)\n\n@watch(\n    lambda: network_online.value,\n    lambda: disk_space.value &gt; 10  # GB\n)\ndef start_download():\n    print(\"\ud83d\udce5 Starting download...\")\n</code></pre></p>"},{"location":"api/api/#limitations_2","title":"Limitations","text":"<ul> <li>Conditions must be synchronous (no async/await)</li> <li>Only triggers on false\u2192true transitions (not during sustained true states)</li> <li>Cannot create circular dependencies with watched observables</li> <li>Condition evaluation failures are treated as False</li> </ul>"},{"location":"api/api/#troubleshooting_2","title":"Troubleshooting","text":"<p>Watch function not triggering: Ensure all observables accessed in conditions are properly tracked</p> <pre><code># Wrong: External observable not tracked\nexternal_flag = observable(True)\n@watch(lambda: some_obs.value &gt; 0)\ndef wrong_func():\n    if external_flag.value:  # Not tracked!\n        pass\n\n# Right: Include all dependencies in conditions\n@watch(\n    lambda: some_obs.value &gt; 0,\n    lambda: external_flag.value\n)\ndef right_func():\n    pass\n</code></pre> <p>Unexpected triggering: Remember watch only triggers on transitions, not sustained states</p> <p>Performance issues: Simplify complex conditions or break them into multiple watches</p>"},{"location":"api/api/#comparison-with-reactive","title":"Comparison with Reactive","text":"Feature @reactive @watch Execution Every change Condition transitions only Use case Side effects Conditional logic Granularity Fine-grained Coarse-grained Performance Higher overhead Lower overhead Complexity Simple More complex"},{"location":"api/api/#see-also_4","title":"See Also","text":"<ul> <li><code>fynx.reactive</code>: Unconditional reactive functions</li> <li><code>fynx.computed</code>: Derived reactive values</li> <li><code>fynx.store</code>: Reactive state containers</li> <li><code>fynx.observable</code>: Core observable classes</li> </ul>"},{"location":"api/api/#watch","title":"watch","text":"<pre><code>def watch(*conditions) -&gt; Callable\n</code></pre> <p>Decorator for conditional reactive functions that run only when conditions are met.</p> <p>The <code>watch</code> decorator creates a reactive function that only executes when ALL specified conditions become true, after previously being false. This enables guarded reactions that wait for specific state combinations before triggering.</p> <p>The decorator automatically discovers which observables are accessed within the condition functions and sets up the appropriate subscriptions. When any of these observables change, the conditions are re-evaluated, and the decorated function runs only if this represents a transition from \"not all conditions met\" to \"all conditions met\".</p> <p>Arguments:</p> <ul> <li><code>*conditions</code> - Variable number of condition functions. Each condition should be   a callable that returns a boolean value. Condition functions can   access observable values via <code>.value</code> attribute. All conditions   must return <code>True</code> for the decorated function to execute.</li> </ul> <p>Returns:</p> <p>A decorator function that can be applied to reactive functions.</p> <p>Examples:</p> <pre><code>```python\nfrom fynx import observable, watch\n\n# Basic conditional reaction\nuser_logged_in = observable(False)\ndata_loaded = observable(False)\n\n@watch(\n    lambda: user_logged_in.value,\n    lambda: data_loaded.value\n)\ndef show_dashboard():\n    print(\"Welcome to your dashboard!\")\n\n# Only shows when both conditions are true\nuser_logged_in.set(True)  # Not yet (data not loaded)\ndata_loaded.set(True)     # Now shows dashboard!\n\n# State-based reactions\napp_state = observable(\"loading\")\nerror_count = observable(0)\n\n@watch(\n    lambda: app_state.value == \"error\",\n    lambda: error_count.value &gt;= 3\n)\ndef show_error_recovery():\n    print(\"Too many errors - showing recovery options\")\n\n# Advanced conditions with computations\ntemperature = observable(20)\nhumidity = observable(50)\n\n@watch(\n    lambda: temperature.value &gt; 30,\n    lambda: humidity.value &lt; 30\n)\ndef activate_cooling():\n    print(\"Hot and dry - activating cooling system!\")\n\n# Conditions can be complex expressions\n@watch(lambda: temperature.value &lt; 0 or temperature.value &gt; 40)\ndef extreme_temperature_alert():\n    print(\"Extreme temperature detected!\")\n```\n</code></pre> <p>Notes:</p> <ul> <li>Condition functions should be pure and relatively fast</li> <li>The decorated function only runs on the transition from conditions not being   met to conditions being met (not on every change while conditions remain true)</li> <li>If condition evaluation fails during discovery or runtime, it's treated as False</li> <li>Observables accessed in conditions are automatically tracked as dependencies</li> </ul> <p>See Also:</p> <ul> <li><code>reactive</code> - For unconditional reactive functions</li> <li><code>computed</code> - For derived reactive values</li> </ul>"}]}