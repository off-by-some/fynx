{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"FynX","text":"<p>FynX (\"Finks\") = Functional Yielding Observable Networks</p>"},{"location":"#overview","title":"Overview","text":"<p>FynX is a lightweight reactive state management library for Python that brings the elegance of reactive programming to your applications. Inspired by MobX, FynX eliminates the complexity of manual state synchronization by automatically propagating changes through your application's data flow. When one piece of state changes, everything that depends on it updates automatically\u2014no boilerplate, no explicit update calls, just transparent reactivity.</p>"},{"location":"#understanding-reactive-programming","title":"Understanding Reactive Programming","text":"<p>Traditional imperative programming requires you to manually orchestrate updates: when data changes, you must explicitly call update methods, refresh UI components, or invalidate caches. This creates brittle, error-prone code where it's easy to forget an update or create inconsistent states.</p> <p>Reactive programming inverts this model. Instead of imperatively triggering updates, you declare relationships between data. When a value changes, the framework automatically propagates that change to everything that depends on it. Think of it like a spreadsheet: when you change a cell, all formulas referencing that cell recalculate automatically. FynX brings this same automatic dependency tracking and update propagation to Python.</p> <p>What makes FynX special is its transparency. You don't need to learn special syntax or wrap everything in framework-specific abstractions. Just use normal Python objects and assignment\u2014FynX handles the reactivity behind the scenes through automatic dependency tracking.</p>"},{"location":"#core-concepts","title":"Core Concepts","text":"<p>FynX's design centers on four fundamental building blocks that work together to create reactive data flows:</p>"},{"location":"#observables","title":"Observables","text":"<p>Observables are the foundation of reactivity. An observable is simply a value that FynX watches for changes. When you modify an observable, FynX automatically notifies everything that depends on it. Think of observables as the source nodes in your application's dependency graph\u2014they're the raw state that drives everything else.</p>"},{"location":"#computed-values","title":"Computed Values","text":"<p>Computed values are derived data that automatically recalculates when their dependencies change. They provide memoization by default, meaning they only recompute when one of their inputs actually changes\u2014not on every access. This makes them both convenient and performant for expensive calculations. Computed values form the intermediate nodes in your dependency graph, transforming observables into the exact shape your application needs.</p>"},{"location":"#reactions","title":"Reactions","text":"<p>Reactions are side effects that execute automatically when their observed dependencies change. Use reactions for actions like updating a UI, making an API call, logging, or any other effect that should happen in response to state changes. While observables and computed values represent your data, reactions represent what your application does with that data.</p>"},{"location":"#stores","title":"Stores","text":"<p>Stores provide organizational structure by grouping related observables, computed values, and methods together. They offer convenient patterns for subscribing to changes and managing related state as a cohesive unit. Stores aren't required, but they help you organize complex state into logical, reusable components.</p>"},{"location":"#conditional-reactions","title":"Conditional Reactions","text":"<p>Conditional reactions extend the basic reaction pattern by only executing when specific conditions are met. They're perfect for implementing state machines, validation rules, or any scenario where you need fine-grained control over when effects trigger. This allows you to express complex conditional logic declaratively rather than scattering imperative checks throughout your code.</p>"},{"location":"#why-fynx","title":"Why FynX?","text":"<p>Transparent Reactivity: FynX requires no special syntax. Use standard Python assignment, method calls, and attribute access\u2014reactivity works automatically without wrapper objects or proxy patterns.</p> <p>Automatic Dependency Tracking: FynX observables track their dependents automatically during execution. You never manually register or unregister dependencies; the framework infers them from how your code actually runs.</p> <p>Lazy Evaluation with Memoization: Computed values only recalculate when their dependencies change, and only when accessed. This combines the convenience of automatic updates with the performance of intelligent caching.</p> <p>Full Type Safety: FynX provides complete type hints, giving you autocomplete, inline documentation, and static analysis throughout your reactive code.</p> <p>Memory Efficient: FynX automatically cleans up reactive contexts when they're no longer needed, preventing memory leaks in long-running applications.</p> <p>Composable Architecture: Observables, computed values, and reactions compose naturally. You can nest stores, chain computed values, and combine reactions to build complex reactive systems from simple, reusable pieces.</p> <p>Expressive Operators: FynX provides intuitive operators (<code>|</code>, <code>&gt;&gt;</code>, <code>&amp;</code>, <code>~</code>) that let you compose reactive logic clearly and concisely, making your data flow explicit and easy to understand.</p>"},{"location":"#quick-start-example","title":"Quick Start Example","text":"<p>Here's a complete example showing how FynX's concepts work together:</p> <pre><code>from fynx import Store, observable, computed, reactive, watch\n\n# Create a reactive store grouping related state\nclass UserStore(Store):\n    name = observable(\"Alice\")\n    age = observable(30)\n    is_online = observable(False)\n\n    @computed\n    def greeting(self):\n        # This automatically recomputes when name or age changes\n        return f\"Hello, {self.name}! You are {self.age} years old.\"\n\n# React to any change in name or age\n@reactive(UserStore.name, UserStore.age)\ndef on_user_change(name, age):\n    print(f\"User updated: {name}, {age}\")\n\n# React only when specific conditions are met\n@watch(\n    lambda: UserStore.is_online.value,\n    lambda: UserStore.age.value &gt;= 18\n)\ndef on_adult_online():\n    print(f\"Adult user {UserStore.name.value} is now online!\")\n\n# Changes trigger appropriate reactions automatically\nUserStore.name = \"Bob\"      # Prints: User updated: Bob, 30\nUserStore.age = 25          # Prints: User updated: Bob, 25\nUserStore.is_online = True  # Prints: Adult user Bob is now online!\n</code></pre> <p>Notice how natural the code looks\u2014no explicit update calls, no subscription management, just straightforward Python that happens to be reactive.</p>"},{"location":"#installation","title":"Installation","text":"<p>Install FynX from PyPI using pip:</p> <pre><code>pip install fynx\n</code></pre> <p>FynX has no required dependencies and works with Python 3.8 and above.</p>"},{"location":"#common-patterns","title":"Common Patterns","text":"<p>As you work with FynX, you'll find these patterns emerge naturally:</p> <p>State Management: Group related observables in Store classes to create logical boundaries in your application. Each store becomes a self-contained module of state with its own computed values and methods.</p> <p>Derived Data: Use computed values whenever you need data that depends on other data. The automatic memoization means you can freely access computed values without worrying about performance\u2014they only recalculate when necessary.</p> <p>Side Effects: Attach reactions to observables for any effect that should happen in response to state changes: updating a UI, sending analytics, making API calls, or writing to a database.</p> <p>Conditional Logic: Use watch decorators to implement state machines, validation rules, or event filtering. This keeps conditional logic declarative and colocated with the relevant state.</p> <p>Data Flow Composition: Use FynX's operators (<code>|</code> for piping values, <code>&gt;&gt;</code> for chaining, <code>&amp;</code> for combining) to build clear, expressive data transformation pipelines.</p>"},{"location":"#documentation","title":"Documentation","text":"<ul> <li>API Reference - Complete API documentation with organized sections</li> <li>Examples - Working examples and patterns</li> <li>GitHub Repository - Source code and issues</li> </ul>"},{"location":"#contributing","title":"Contributing","text":"<p>We welcome contributions! Please visit the GitHub repository for contribution guidelines, issue tracking, and development setup instructions.</p>"},{"location":"#license","title":"License","text":"<p>FynX is released under the MIT License. See the LICENSE file for complete terms.</p>"},{"location":"generation/markdown/api/","title":"API Reference","text":"<p>This page provides an overview of FynX's API structure. The complete API documentation is organized across multiple pages for better navigation.</p>"},{"location":"generation/markdown/api/#api-documentation-structure","title":"API Documentation Structure","text":"<ul> <li>Core API - Main FynX exports and public API</li> <li>Observable Types - Individual pages for each type of observable:</li> <li>Observable - Core reactive values</li> <li>ComputedObservable - Derived reactive values</li> <li>MergedObservable - Combined observables</li> <li>ConditionalObservable - Conditional reactive values</li> <li>Observable Descriptors - Class attribute descriptors</li> <li>Observable Operators - Reactive operators</li> <li>Reactive Decorators - Individual pages for each decorator and utility:</li> <li>@computed - Create computed observables</li> <li>@reactive - React to observable changes</li> <li>@watch - Conditional reactive functions</li> <li>Store &amp; @observable - State containers and reactive attributes</li> </ul>"},{"location":"generation/markdown/api/#quick-reference","title":"Quick Reference","text":""},{"location":"generation/markdown/api/#core-classes","title":"Core Classes","text":"<ul> <li><code>Observable</code> - Reactive values that notify subscribers on change</li> <li><code>Store</code> - Container for grouping related observables</li> <li><code>ReactiveContext</code> - Manages reactive execution and dependency tracking</li> </ul>"},{"location":"generation/markdown/api/#decorators","title":"Decorators","text":"<ul> <li><code>@observable</code> - Makes class attributes reactive</li> <li><code>@computed</code> - Creates derived values from observables</li> <li><code>@reactive</code> - Runs functions when observables change</li> <li><code>@watch</code> - Runs functions when conditions are met</li> </ul>"},{"location":"generation/markdown/api/#operators","title":"Operators","text":"<ul> <li><code>|</code> (merge) - Combines observables into tuples</li> <li><code>&gt;&gt;</code> (transform) - Creates computed values from functions</li> <li><code>&amp;</code> (filter) - Creates conditional observables</li> <li><code>~</code> (negate) - Inverts boolean observables</li> </ul>"},{"location":"generation/markdown/api/#getting-started","title":"Getting Started","text":"<pre><code>from fynx import Store, observable, computed, reactive\n\n# Create a reactive store\nclass UserStore(Store):\n    name = observable(\"Alice\")\n    age = observable(30)\n\n    @computed\n    def greeting(self):\n        return f\"Hello, {self.name}! You are {self.age} years old.\"\n\n# React to changes\n@reactive(UserStore.name, UserStore.age)\ndef on_user_change(name, age):\n    print(f\"User updated: {name}, {age}\")\n\n# Changes trigger reactions automatically\nUserStore.name = \"Bob\"  # Prints: User updated: Bob, 30\n</code></pre> <p>For detailed documentation on each module, see the individual API pages linked above.</p>"},{"location":"generation/markdown/computed-decorator/","title":"@computed Decorator","text":"<p>Function for creating computed observables from other reactive values.</p> <pre><code>Create a computed observable that derives its value from other observables.\n\nThe `computed` function creates a new observable whose value is automatically\ncalculated by applying the given function to the values of the input observable(s).\nWhen the input observable(s) change, the computed observable automatically updates.\n\nThis implements the functorial map operation over observables, allowing you to\ntransform observable values through pure functions while preserving reactivity.\n\nArgs:\n    func: A pure function that computes the derived value. For merged observables,\n          the function receives individual values as separate arguments. For single\n          observables, it receives the single value.\n    observable: The source observable(s) to compute from. Can be a single Observable\n               or a MergedObservable (created with the `|` operator).\n\nReturns:\n    A new ComputedObservable containing the computed values. The observable will\n    automatically update whenever the source observable(s) change.\n\nExamples:\n    ```python\n    from fynx import observable, computed\n\n    # Single observable computation\n    counter = observable(5)\n    doubled = computed(lambda x: x * 2, counter)\n    print(doubled.value)  # 10\n\n    counter.set(7)\n    print(doubled.value)  # 14\n\n    # Merged observable computation\n    width = observable(10)\n    height = observable(20)\n    dimensions = width | height\n\n    area = computed(lambda w, h: w * h, dimensions)\n</code></pre> <p>print(area.value)  # 200</p> <pre><code>    # More complex computation\n    person = observable({\"name\": \"Alice\", \"age\": 30})\n    greeting = computed(\n        lambda p: f\"Hello {p['name']}, you are {p['age']} years old!\",\n        person\n    )\n    print(greeting.value)  # \"Hello Alice, you are 30 years old!\"\n    ```\n\nNote:\n    Computed functions should be pure (no side effects) and relatively fast,\n    as they may be called frequently when dependencies change.\n\nSee Also:\n    observable: Create basic observables\n    ComputedObservable: The returned observable type\n    MergedObservable: For combining multiple observables\n</code></pre>"},{"location":"generation/markdown/computed-observable/","title":"ComputedObservable","text":"<p>Read-only observables that derive their values from other observables.</p> <p>A read-only observable that derives its value from other observables.</p> <p>ComputedObservable is a subclass of Observable that represents computed/derived values. Unlike regular observables, computed observables are read-only and cannot be set directly - their values are automatically calculated from their dependencies.</p> <p>This provides type-based distinction from regular observables, eliminating the need for magic strings or runtime checks. Computed observables maintain the same interface as regular observables for reading values and subscribing to changes, but enforce immutability at runtime.</p> Example <pre><code># Regular observable\ncounter = observable(0)\n\n# Computed observable (read-only)\ndoubled = ComputedObservable(\"doubled\", lambda: counter.value * 2)\ndoubled.set(10)  # Raises ValueError: Computed observables are read-only\n</code></pre>"},{"location":"generation/markdown/computed-observable/#fynx.observable.computed.ComputedObservable.set","title":"set","text":"<pre><code>set(value)\n</code></pre> <p>Prevent direct modification of computed observable values.</p> <p>Computed observables are read-only by design because their values are automatically calculated from other observables. Attempting to set them directly would break the reactive relationship and defeat the purpose of computed values.</p> <p>To create a computed observable, use the <code>computed()</code> function instead:</p> <pre><code>from fynx import observable, computed\n\nbase = observable(5)\n# Correct: Create computed value\ndoubled = computed(lambda x: x * 2, base)\n\n# Incorrect: Try to set computed value directly\ndoubled.set(10)  # Raises ValueError\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Optional[T]</code> <p>The value that would be set (ignored).   This parameter exists for API compatibility but is not used.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>Always raised to prevent direct modification of computed values.        Use the <code>computed()</code> function to create derived observables instead.</p> See Also <p>computed: Function for creating computed observables _set_computed_value: Internal method used by the framework</p>"},{"location":"generation/markdown/conditional-observable/","title":"ConditionalObservable","text":"<p>Observables that only emit values when specific conditions are met.</p>"},{"location":"generation/markdown/conditional-observable/#fynx.observable.conditional--fynx-conditionalobservable-conditional-reactive-computations","title":"FynX ConditionalObservable - Conditional Reactive Computations","text":"<p>This module provides the ConditionalObservable class, which enables filtering reactive streams based on boolean conditions. Conditional observables only emit values from a source observable when all specified conditions are satisfied.</p>"},{"location":"generation/markdown/conditional-observable/#fynx.observable.conditional--when-to-use-conditional-observables","title":"When to Use Conditional Observables","text":"<p>Conditional observables are perfect for scenarios where you need to react to data changes only under specific circumstances:</p> <ul> <li>Guarded Updates: Only reacting to changes when prerequisites are met</li> <li>State Machines: Different behavior based on application state</li> <li>Resource Optimization: Avoiding unnecessary computations when conditions aren't met</li> <li>Event Filtering: Processing events only under specific circumstances</li> <li>Permission Checks: Only updating UI when user has appropriate permissions</li> </ul>"},{"location":"generation/markdown/conditional-observable/#fynx.observable.conditional--how-it-works","title":"How It Works","text":"<p>Conditional observables work by maintaining an internal cache of condition states. They only emit values when:</p> <ol> <li>All conditions become True (after previously being False)</li> <li>Source value changes while all conditions remain True</li> </ol> <p>This prevents unnecessary updates when conditions aren't met and provides precise control over when reactive effects occur.</p>"},{"location":"generation/markdown/conditional-observable/#fynx.observable.conditional--creating-conditional-observables","title":"Creating Conditional Observables","text":"<p>Conditional behavior is created using the <code>&amp;</code> operator:</p> <pre><code>from fynx.observable import Observable\n\n# Source data\ntemperature = Observable(\"temp\", 20)\nhumidity = Observable(\"humidity\", 60)\n\n# Conditions\nis_heating_on = Observable(\"heating\", False)\nis_dry = Observable(\"dry\", False)\n\n# Conditional observable - only emits when heating is on AND it's dry\nsmart_humidity = humidity &amp; is_heating_on &amp; is_dry\n\nsmart_humidity.subscribe(lambda h: print(f\"Adjusting humidity: {h}%\"))\n# Only prints when ALL conditions are True\n</code></pre>"},{"location":"generation/markdown/conditional-observable/#fynx.observable.conditional--key-concepts","title":"Key Concepts","text":"<ul> <li>Condition Chaining: Multiple conditions combine with logical AND</li> <li>Transition-Based: Only triggers on false\u2192true condition transitions</li> <li>Value Filtering: Source values only pass through when conditions are met</li> <li>Immutable Composition: Each <code>&amp;</code> creates a new conditional observable</li> </ul>"},{"location":"generation/markdown/conditional-observable/#fynx.observable.conditional--performance-benefits","title":"Performance Benefits","text":"<ul> <li>Lazy Evaluation: Conditions only re-evaluated when dependencies change</li> <li>Efficient Filtering: Prevents unnecessary reactive updates</li> <li>Memory Conscious: Minimal overhead for condition tracking</li> <li>Composable: Build complex conditions from simple boolean observables</li> </ul>"},{"location":"generation/markdown/conditional-observable/#fynx.observable.conditional--common-patterns","title":"Common Patterns","text":"<p>Feature Flags: <pre><code>data = Observable(\"data\", [])\nfeature_enabled = Observable(\"feature\", False)\nuser_premium = Observable(\"premium\", True)\n\npremium_data = data &amp; feature_enabled &amp; user_premium\n</code></pre></p> <p>Form Validation: <pre><code>email = Observable(\"email\", \"\")\nis_valid_email = Observable(\"valid\", False)\nuser_consented = Observable(\"consent\", False)\n\nsubmittable_data = email &amp; is_valid_email &amp; user_consented\n</code></pre></p> <p>Resource Availability: <pre><code>updates = Observable(\"updates\", [])\nnetwork_available = Observable(\"network\", True)\nbattery_ok = Observable(\"battery\", True)\n\nsync_updates = updates &amp; network_available &amp; battery_ok\n</code></pre></p>"},{"location":"generation/markdown/conditional-observable/#fynx.observable.conditional--see-also","title":"See Also","text":"<ul> <li><code>fynx.watch</code>: For conditional reactive functions (alternative approach)</li> <li><code>fynx.observable</code>: Core observable classes and operators</li> <li><code>fynx.computed</code>: For derived reactive values</li> </ul>"},{"location":"generation/markdown/conditional-observable/#fynx.observable.conditional.ConditionalObservable","title":"ConditionalObservable","text":"<pre><code>ConditionalObservable(source_observable, *condition_observables)\n</code></pre> <p>An observable that filters values from a source observable based on boolean conditions.</p> <p>ConditionalObservable creates a reactive stream that only emits values when ALL specified conditions are True. This enables precise control over when reactive updates occur, preventing unnecessary computations and side effects.</p> <p>The conditional observable maintains an internal cache of the current condition state and only notifies subscribers when conditions transition from unmet to met, or when the source value changes while conditions remain met.</p> <p>Key Features: - Condition Filtering: Only emits when all conditions are satisfied - State Transitions: Triggers on condition state changes - Composable: Can chain multiple conditions with additional <code>&amp;</code> operators - Memory Efficient: Internal caching prevents redundant evaluations</p> Example <pre><code>from fynx.observable import Observable\n\n# Source observable\ntemperature = Observable(\"temp\", 20)\n\n# Condition observables\nis_heating_enabled = Observable(\"heating\", False)\nis_cold = Observable(\"cold_check\", False)\n\n# Conditional observable - only emits when heating is enabled AND it's cold\nheating_trigger = temperature &amp; is_heating_enabled &amp; is_cold\n\n# Subscribe to conditional updates\ndef activate_heating(temp):\n    print(f\"Activating heating at {temp}\u00b0C\")\n\nheating_trigger.subscribe(activate_heating)\n\n# Only triggers when ALL conditions become true\ntemperature.set(15)        # No trigger (heating not enabled)\nis_heating_enabled.set(True)  # No trigger (not marked as cold yet)\nis_cold.set(True)          # Triggers: \"Activating heating at 15\u00b0C\"\ntemperature.set(10)        # Triggers: \"Activating heating at 10\u00b0C\"\nis_heating_enabled.set(False)  # Stops triggering\n</code></pre> Note <p>The conditional observable starts with <code>None</code> as its value if conditions are not initially met. It only takes on the source observable's value when all conditions become True.</p> See Also <p>Observable: Base observable class MergedObservable: For combining multiple observables fynx.watch: For conditional reactive functions</p> <p>Create a conditional observable that filters values based on boolean conditions.</p> <p>The conditional observable will only emit values from the source observable when ALL condition observables are True. If no conditions are provided, the conditional observable behaves identically to the source observable.</p> <p>Parameters:</p> Name Type Description Default <code>source_observable</code> <code>Observable[T]</code> <p>The observable whose values will be conditionally emitted.               This is the primary data source for the conditional stream.</p> required <code>*condition_observables</code> <code>Observable[bool]</code> <p>Variable number of boolean observables that act as                    conditions. ALL conditions must be True for the source                    value to be emitted. Can be empty for unconditional behavior.</p> <code>()</code> Example <pre><code>from fynx.observable import Observable\n\ndata = Observable(\"data\", \"hello\")\nis_ready = Observable(\"ready\", False)\nuser_enabled = Observable(\"enabled\", True)\n\n# Only emits when is_ready AND user_enabled are both True\nconditional_data = ConditionalObservable(data, is_ready, user_enabled)\n\nconditional_data.subscribe(lambda x: print(f\"Received: {x}\"))\n# Initially: no output (is_ready is False)\n\nis_ready.set(True)  # Now prints: \"Received: hello\"\ndata.set(\"world\")   # Prints: \"Received: world\"\n</code></pre>"},{"location":"generation/markdown/conditional-observable/#fynx.observable.conditional.ConditionalObservable.__and__","title":"__and__","text":"<pre><code>__and__(condition)\n</code></pre> <p>Chain an additional condition using the <code>&amp;</code> operator.</p> <p>This method enables fluent composition of multiple conditions. The resulting conditional observable will only emit values when ALL conditions (including the new one) are True.</p> <p>Parameters:</p> Name Type Description Default <code>condition</code> <code>Observable[bool]</code> <p>An additional boolean observable condition that must also be       True for values to be emitted. This condition is combined with       all existing conditions using logical AND.</p> required <p>Returns:</p> Type Description <code>ConditionalObservable[T]</code> <p>A new ConditionalObservable instance with the additional condition.</p> <code>ConditionalObservable[T]</code> <p>The original conditional observable remains unchanged.</p> Example <pre><code>from fynx.observable import Observable\n\ntemperature = Observable(\"temp\", 20)\nis_heating_on = Observable(\"heating\", False)\nis_user_present = Observable(\"present\", True)\n\n# Chain conditions fluently\nsmart_heating = temperature &amp; is_heating_on &amp; is_user_present\n\n# This is equivalent to:\n# smart_heating = ConditionalObservable(temperature, is_heating_on, is_user_present)\n\nsmart_heating.subscribe(lambda t: print(f\"Smart heating: {t}\u00b0C\"))\n\n# Only triggers when ALL conditions are met\nis_heating_on.set(True)  # Now triggers: \"Smart heating: 20\u00b0C\"\ntemperature.set(22)      # Triggers: \"Smart heating: 22\u00b0C\"\nis_user_present.set(False)  # Stops triggering\n</code></pre> Note <p>This method returns a new ConditionalObservable rather than modifying the existing one, enabling immutable composition of conditions.</p>"},{"location":"generation/markdown/core-api/","title":"Core API","text":"<p>This page contains the main FynX module exports - the public API that applications typically use.</p>"},{"location":"generation/markdown/core-api/#main-module","title":"Main Module","text":""},{"location":"generation/markdown/core-api/#fynx--fynx-python-reactive-state-management-library","title":"FynX - Python Reactive State Management Library","text":"<p>FynX is a lightweight, transparent reactive state management library for Python, inspired by MobX. It enables reactive programming patterns where state changes automatically propagate through your application, eliminating the need for manual state synchronization.</p>"},{"location":"generation/markdown/core-api/#fynx--core-concepts","title":"Core Concepts","text":"<p>Observables: Values that can be watched for changes. When an observable value changes, all dependent computations and reactions automatically update.</p> <p>Computed Values: Derived values that automatically recalculate when their dependencies change, with built-in memoization for performance.</p> <p>Reactions: Functions that run automatically when their observed dependencies change, enabling side effects like UI updates or API calls.</p> <p>Stores: Classes that group related observables together with convenient subscription and state management methods.</p>"},{"location":"generation/markdown/core-api/#fynx--key-features","title":"Key Features","text":"<ul> <li>Transparent Reactivity: No special syntax needed - just use regular Python objects</li> <li>Automatic Dependency Tracking: Observables automatically track what depends on them</li> <li>Lazy Evaluation: Computed values only recalculate when needed</li> <li>Type Safety: Full type hint support for better IDE experience and static analysis</li> <li>Memory Efficient: Automatic cleanup of unused reactive contexts</li> <li>Composable: Easy to combine and nest reactive components</li> </ul>"},{"location":"generation/markdown/core-api/#fynx--quick-example","title":"Quick Example","text":"<pre><code>from fynx import Store, observable, computed, reactive\n\n# Create a reactive store\nclass UserStore(Store):\n    name = observable(\"Alice\")\n    age = observable(30)\n\n    @computed\n    def greeting(self):\n        return f\"Hello, {self.name}! You are {self.age} years old.\"\n\n# React to changes\n@reactive(UserStore.name, UserStore.age)\ndef on_user_change(name, age):\n    print(f\"User updated: {name}, {age}\")\n\n# Changes trigger reactions automatically\nUserStore.name = \"Bob\"  # Prints: User updated: Bob, 30\nUserStore.age = 31      # Prints: User updated: Bob, 31\n</code></pre> <p>For more examples and detailed documentation, see the README.md file.</p>"},{"location":"generation/markdown/core-api/#fynx.ConditionalObservable","title":"ConditionalObservable","text":"<pre><code>ConditionalObservable(source_observable, *condition_observables)\n</code></pre> <p>An observable that filters values from a source observable based on boolean conditions.</p> <p>ConditionalObservable creates a reactive stream that only emits values when ALL specified conditions are True. This enables precise control over when reactive updates occur, preventing unnecessary computations and side effects.</p> <p>The conditional observable maintains an internal cache of the current condition state and only notifies subscribers when conditions transition from unmet to met, or when the source value changes while conditions remain met.</p> <p>Key Features: - Condition Filtering: Only emits when all conditions are satisfied - State Transitions: Triggers on condition state changes - Composable: Can chain multiple conditions with additional <code>&amp;</code> operators - Memory Efficient: Internal caching prevents redundant evaluations</p> Example <pre><code>from fynx.observable import Observable\n\n# Source observable\ntemperature = Observable(\"temp\", 20)\n\n# Condition observables\nis_heating_enabled = Observable(\"heating\", False)\nis_cold = Observable(\"cold_check\", False)\n\n# Conditional observable - only emits when heating is enabled AND it's cold\nheating_trigger = temperature &amp; is_heating_enabled &amp; is_cold\n\n# Subscribe to conditional updates\ndef activate_heating(temp):\n    print(f\"Activating heating at {temp}\u00b0C\")\n\nheating_trigger.subscribe(activate_heating)\n\n# Only triggers when ALL conditions become true\ntemperature.set(15)        # No trigger (heating not enabled)\nis_heating_enabled.set(True)  # No trigger (not marked as cold yet)\nis_cold.set(True)          # Triggers: \"Activating heating at 15\u00b0C\"\ntemperature.set(10)        # Triggers: \"Activating heating at 10\u00b0C\"\nis_heating_enabled.set(False)  # Stops triggering\n</code></pre> Note <p>The conditional observable starts with <code>None</code> as its value if conditions are not initially met. It only takes on the source observable's value when all conditions become True.</p> See Also <p>Observable: Base observable class MergedObservable: For combining multiple observables fynx.watch: For conditional reactive functions</p> <p>Create a conditional observable that filters values based on boolean conditions.</p> <p>The conditional observable will only emit values from the source observable when ALL condition observables are True. If no conditions are provided, the conditional observable behaves identically to the source observable.</p> <p>Parameters:</p> Name Type Description Default <code>source_observable</code> <code>Observable[T]</code> <p>The observable whose values will be conditionally emitted.               This is the primary data source for the conditional stream.</p> required <code>*condition_observables</code> <code>Observable[bool]</code> <p>Variable number of boolean observables that act as                    conditions. ALL conditions must be True for the source                    value to be emitted. Can be empty for unconditional behavior.</p> <code>()</code> Example <pre><code>from fynx.observable import Observable\n\ndata = Observable(\"data\", \"hello\")\nis_ready = Observable(\"ready\", False)\nuser_enabled = Observable(\"enabled\", True)\n\n# Only emits when is_ready AND user_enabled are both True\nconditional_data = ConditionalObservable(data, is_ready, user_enabled)\n\nconditional_data.subscribe(lambda x: print(f\"Received: {x}\"))\n# Initially: no output (is_ready is False)\n\nis_ready.set(True)  # Now prints: \"Received: hello\"\ndata.set(\"world\")   # Prints: \"Received: world\"\n</code></pre>"},{"location":"generation/markdown/core-api/#fynx.ConditionalObservable.__and__","title":"__and__","text":"<pre><code>__and__(condition)\n</code></pre> <p>Chain an additional condition using the <code>&amp;</code> operator.</p> <p>This method enables fluent composition of multiple conditions. The resulting conditional observable will only emit values when ALL conditions (including the new one) are True.</p> <p>Parameters:</p> Name Type Description Default <code>condition</code> <code>Observable[bool]</code> <p>An additional boolean observable condition that must also be       True for values to be emitted. This condition is combined with       all existing conditions using logical AND.</p> required <p>Returns:</p> Type Description <code>ConditionalObservable[T]</code> <p>A new ConditionalObservable instance with the additional condition.</p> <code>ConditionalObservable[T]</code> <p>The original conditional observable remains unchanged.</p> Example <pre><code>from fynx.observable import Observable\n\ntemperature = Observable(\"temp\", 20)\nis_heating_on = Observable(\"heating\", False)\nis_user_present = Observable(\"present\", True)\n\n# Chain conditions fluently\nsmart_heating = temperature &amp; is_heating_on &amp; is_user_present\n\n# This is equivalent to:\n# smart_heating = ConditionalObservable(temperature, is_heating_on, is_user_present)\n\nsmart_heating.subscribe(lambda t: print(f\"Smart heating: {t}\u00b0C\"))\n\n# Only triggers when ALL conditions are met\nis_heating_on.set(True)  # Now triggers: \"Smart heating: 20\u00b0C\"\ntemperature.set(22)      # Triggers: \"Smart heating: 22\u00b0C\"\nis_user_present.set(False)  # Stops triggering\n</code></pre> Note <p>This method returns a new ConditionalObservable rather than modifying the existing one, enabling immutable composition of conditions.</p>"},{"location":"generation/markdown/core-api/#fynx.MergedObservable","title":"MergedObservable","text":"<pre><code>MergedObservable(*observables)\n</code></pre> <p>An observable that combines multiple observables into a single reactive tuple.</p> <p>MergedObservable creates a composite observable whose value is a tuple containing the current values of all source observables. When any source observable changes, the merged observable updates its tuple value and notifies all subscribers.</p> <p>This enables treating multiple related reactive values as a single atomic unit, which is particularly useful for:</p> <ul> <li>Functions that need multiple related parameters</li> <li>Computed values that depend on several inputs</li> <li>Coordinated state updates across multiple variables</li> <li>Maintaining referential consistency between related values</li> </ul> Example <pre><code>from fynx import observable, computed\n\n# Individual observables\nx = observable(10)\ny = observable(20)\n\n# Merge them into a single reactive unit\npoint = x | y\nprint(point.value)  # (10, 20)\n\n# Computed values can work with the tuple\ndistance_from_origin = computed(\n    lambda px, py: (px**2 + py**2)**0.5,\n    point\n)\nprint(distance_from_origin.value)  # 22.360679774997898\n\n# Changes to either coordinate update everything\nx.set(15)\nprint(point.value)                  # (15, 20)\nprint(distance_from_origin.value)   # 25.0\n</code></pre> Note <p>The merged observable's value is always a tuple, even when merging just two observables. This provides a consistent interface for computed functions.</p> See Also <p>Observable: Base observable class computed: For creating derived values from merged observables</p> <p>Create a merged observable from multiple source observables.</p> <p>Parameters:</p> Name Type Description Default <code>*observables</code> <code>Observable</code> <p>Variable number of Observable instances to combine.          At least one observable must be provided.</p> <code>()</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no observables are provided</p>"},{"location":"generation/markdown/core-api/#fynx.MergedObservable.value","title":"value","text":"<pre><code>value\n</code></pre> <p>Get the current tuple value, using cache when possible.</p> <p>Returns the current values of all source observables as a tuple. Uses caching to avoid recomputing the tuple on every access.</p> <p>Returns:</p> Type Description <p>A tuple containing the current values of all source observables,</p> <p>in the order they were provided to the constructor.</p> Example <pre><code>x = Observable(\"x\", 10)\ny = Observable(\"y\", 20)\nmerged = x | y\n\nprint(merged.value)  # (10, 20)\nx.set(15)\nprint(merged.value)  # (15, 20) - cache invalidated and recomputed\n</code></pre>"},{"location":"generation/markdown/core-api/#fynx.MergedObservable.__enter__","title":"__enter__","text":"<pre><code>__enter__()\n</code></pre> <p>Context manager entry for reactive blocks.</p> <p>Enables experimental syntax for defining reactive blocks that execute whenever any of the merged observables change.</p> <p>Returns:</p> Type Description <p>A context object that can be called with a function to create reactive behavior.</p> Example <pre><code># Experimental context manager syntax\nwith merged_obs as ctx:\n    ctx(lambda x, y: print(f\"Values changed: {x}, {y}\"))\n</code></pre> Note <p>This is an experimental feature. The more common approach is to use subscribe() or the @reactive decorator.</p>"},{"location":"generation/markdown/core-api/#fynx.MergedObservable.__exit__","title":"__exit__","text":"<pre><code>__exit__(exc_type, exc_val, exc_tb)\n</code></pre> <p>Context manager exit.</p> <p>Currently does nothing, but allows the context manager to work properly.</p>"},{"location":"generation/markdown/core-api/#fynx.MergedObservable.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(index)\n</code></pre> <p>Allow indexing into the merged observable like a tuple.</p> <p>Provides tuple-like access to individual values in the merged observable.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Zero-based index of the value to retrieve</p> required <p>Returns:</p> Type Description <code>T</code> <p>The value at the specified index</p> <p>Raises:</p> Type Description <code>IndexError</code> <p>If the index is out of range or the observable has no value</p> <p>Examples:</p> <pre><code>point = x | y | z\nprint(point[0])  # x value\nprint(point[1])  # y value\nprint(point[-1]) # z value\n</code></pre>"},{"location":"generation/markdown/core-api/#fynx.MergedObservable.__iter__","title":"__iter__","text":"<pre><code>__iter__()\n</code></pre> <p>Allow iteration over the tuple value.</p> <p>Enables unpacking and iteration over merged observable values.</p> <p>Yields:</p> Type Description <p>Individual values from the merged tuple.</p> <p>Examples:</p> <pre><code>coords = x | y | z\n# Unpack values\nx_val, y_val, z_val = coords\n\n# Iterate over values\nfor value in coords:\n    print(value)\n</code></pre>"},{"location":"generation/markdown/core-api/#fynx.MergedObservable.__len__","title":"__len__","text":"<pre><code>__len__()\n</code></pre> <p>Return the number of combined observables.</p> <p>Returns:</p> Type Description <code>int</code> <p>The number of source observables that were merged.</p> Example <pre><code>single = Observable(\"a\", 1)\npair = single | Observable(\"b\", 2)\ntriple = pair | Observable(\"c\", 3)\n\nprint(len(single))   # TypeError (single observable)\nprint(len(pair))     # 2\nprint(len(triple))   # 3\n</code></pre>"},{"location":"generation/markdown/core-api/#fynx.MergedObservable.__or__","title":"__or__","text":"<pre><code>__or__(other)\n</code></pre> <p>Chain merging with another observable using the | operator.</p> <p>Enables fluent syntax for building up merged observables incrementally. Each | operation creates a new MergedObservable containing all previous observables plus the new one.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Observable</code> <p>Another Observable to merge with this merged observable</p> required <p>Returns:</p> Type Description <code>MergedObservable</code> <p>A new MergedObservable containing all source observables from this</p> <code>MergedObservable</code> <p>merged observable plus the additional observable.</p> <p>Examples:</p> <pre><code># Chain multiple merges\na = Observable(\"a\", 1)\nb = Observable(\"b\", 2)\nc = Observable(\"c\", 3)\n\n# Method 1: Merge all at once\nmerged1 = MergedObservable(a, b, c)\n\n# Method 2: Chain merges\nmerged2 = a | b | c  # Same result as merged1\n\nprint(merged2.value)  # (1, 2, 3)\n</code></pre>"},{"location":"generation/markdown/core-api/#fynx.MergedObservable.__setitem__","title":"__setitem__","text":"<pre><code>__setitem__(index, value)\n</code></pre> <p>Allow setting values by index, updating the corresponding source observable.</p> <p>Provides a convenient way to update individual source observables through the merged interface.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Zero-based index of the source observable to update</p> required <code>value</code> <code>T</code> <p>New value for the source observable at that index</p> required <p>Raises:</p> Type Description <code>IndexError</code> <p>If the index is out of range</p> <p>Examples:</p> <pre><code>point = x | y | z\npoint[0] = 10  # Updates x\npoint[1] = 20  # Updates y\nprint(point.value)  # (10, 20, z.value)\n</code></pre>"},{"location":"generation/markdown/core-api/#fynx.MergedObservable.set","title":"set","text":"<pre><code>set(value)\n</code></pre> <p>Override set to invalidate cache.</p> <p>This method is not typically used directly on merged observables, as they derive their value from source observables. However, if you need to manually set a merged observable's value, this method ensures the internal cache is properly invalidated.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <p>The new tuple value to set</p> required Note <p>Manually setting merged observable values is uncommon. Usually, you update the source observables instead.</p>"},{"location":"generation/markdown/core-api/#fynx.MergedObservable.subscribe","title":"subscribe","text":"<pre><code>subscribe(func)\n</code></pre> <p>Subscribe a function to react to changes in any of the merged observables.</p> <p>The subscribed function will be called immediately with the current values of all merged observables, and then again whenever any source observable changes. This provides a way to react to coordinated changes across multiple observables.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable</code> <p>A callable that will receive the current values of all merged   observables as separate arguments, in the order they were merged.   The function signature should match the number of merged observables.</p> required <p>Returns:</p> Type Description <code>MergedObservable[T]</code> <p>This merged observable instance for method chaining.</p> <p>Examples:</p> <pre><code>x = Observable(\"x\", 1)\ny = Observable(\"y\", 2)\ncoords = x | y\n\ndef on_coords_change(x_val, y_val):\n    print(f\"Coordinates: ({x_val}, {y_val})\")\n\ncoords.subscribe(on_coords_change)  # Prints: \"Coordinates: (1, 2)\"\n\nx.set(10)  # Prints: \"Coordinates: (10, 2)\"\ny.set(20)  # Prints: \"Coordinates: (10, 20)\"\n</code></pre> Note <p>The function is called immediately upon subscription with current values. For more advanced reactive patterns, consider using the @reactive decorator or @watch decorator instead.</p> See Also <p>unsubscribe: Remove a subscription reactive: Decorator-based reactive functions</p>"},{"location":"generation/markdown/core-api/#fynx.MergedObservable.unsubscribe","title":"unsubscribe","text":"<pre><code>unsubscribe(func)\n</code></pre> <p>Unsubscribe a function from this merged observable.</p> <p>Removes the subscription for the specified function, preventing it from being called when the merged observable changes. This properly cleans up the reactive context and removes all observers.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable</code> <p>The function that was previously subscribed to this merged observable.   Must be the same function object that was passed to subscribe().</p> required <p>Examples:</p> <pre><code>def handler(x, y):\n    print(f\"Changed: {x}, {y}\")\n\ncoords = x | y\ncoords.subscribe(handler)\n\n# Later, unsubscribe\ncoords.unsubscribe(handler)  # No longer called when coords change\n</code></pre> Note <p>This only removes subscriptions to this specific merged observable. If the same function is subscribed to other observables, those subscriptions remain active.</p> See Also <p>subscribe: Add a subscription</p>"},{"location":"generation/markdown/core-api/#fynx.Observable","title":"Observable","text":"<pre><code>Observable(key=None, initial_value=None)\n</code></pre> <p>A reactive value that automatically notifies dependents when it changes.</p> <p>Observable is the core primitive of FynX's reactivity system. It wraps a value and provides transparent reactive behavior - when the value changes, all dependent computations and reactions are automatically notified and updated.</p> <p>Key Features: - Transparent: Behaves like a regular value but with reactive capabilities - Dependency Tracking: Automatically tracks which reactive contexts depend on it - Change Notification: Notifies all observers when the value changes - Type Safety: Generic type parameter ensures type-safe operations - Lazy Evaluation: Computations only re-run when actually needed - Circular Dependency Detection: Prevents infinite loops at runtime</p> <p>Observable implements various magic methods (<code>__eq__</code>, <code>__str__</code>, etc.) to behave like its underlying value in most contexts, making it easy to use in existing code without modification.</p> <p>Attributes:</p> Name Type Description <code>key</code> <code>Optional[str]</code> <p>Unique identifier for debugging and serialization</p> <code>_value</code> <code>Optional[T]</code> <p>The current wrapped value</p> <code>_observers</code> <code>Set[Callable]</code> <p>Set of observer functions</p> Class Attributes <p>_current_context (Optional[ReactiveContext]): Current reactive execution context _context_stack (List[ReactiveContext]): Stack of nested reactive contexts</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Optional[str]</code> <p>A unique identifier for this observable (used for debugging).  If None, will be set to \"\" and updated in set_name. <code>None</code> <code>initial_value</code> <code>Optional[T]</code> <p>The initial value to store. Can be any type.</p> <code>None</code> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If a circular dependency is detected during value updates.</p> Example <pre><code>from fynx.observable import Observable\n\n# Create an observable\ncounter = Observable(\"counter\", 0)\n\n# Direct access (transparent behavior)\nprint(counter.value)  # 0\nprint(counter == 0)   # True\nprint(str(counter))   # \"0\"\n\n# Subscribe to changes\ndef on_change():\n    print(f\"Counter changed to: {counter.value}\")\n\ncounter.subscribe(on_change)\ncounter.set(5)  # Prints: \"Counter changed to: 5\"\n</code></pre> Note <p>While you can create Observable instances directly, it's often more convenient to use the <code>observable()</code> descriptor in Store classes for better organization and automatic serialization support.</p> See Also <p>Store: For organizing observables into reactive state containers computed: For creating derived values from observables reactive: For creating reactive functions that respond to changes</p> <p>Initialize an observable value.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Optional[str]</code> <p>A unique identifier for this observable (used for serialization).  If None, will be set to \"\" and updated in set_name. <code>None</code> <code>initial_value</code> <code>Optional[T]</code> <p>The initial value to store</p> <code>None</code>"},{"location":"generation/markdown/core-api/#fynx.Observable.value","title":"value","text":"<pre><code>value\n</code></pre> <p>Get the current value of this observable.</p> <p>Accessing the value property automatically registers this observable as a dependency if called within a reactive context (computation or reaction).</p> <p>Returns:</p> Type Description <code>Optional[T]</code> <p>The current value stored in this observable, or None if not set.</p> Note <p>This property is tracked by the reactive system. Use it instead of accessing _value directly to ensure proper dependency tracking.</p> Example <pre><code>obs = Observable(\"counter\", 5)\nprint(obs.value)  # 5\n\n# In a reactive context, this creates a dependency\n@reactive(obs)\ndef print_value(val):\n    print(f\"Value: {val}\")\n</code></pre>"},{"location":"generation/markdown/core-api/#fynx.Observable.__and__","title":"__and__","text":"<pre><code>__and__(condition)\n</code></pre> <p>Create a conditional observable using the &amp; operator for filtered reactivity.</p> <p>This creates a ConditionalObservable that only emits values from the source observable when the specified condition (and any chained conditions) are all True. This enables precise control over when reactive updates occur, preventing unnecessary computations and side effects.</p> <p>Parameters:</p> Name Type Description Default <code>condition</code> <code>Observable[bool]</code> <p>A boolean Observable that acts as a gate. The source observable's       values are only emitted when this condition is True.</p> required <p>Returns:</p> Type Description <code>ConditionalObservable[T]</code> <p>A ConditionalObservable that filters the source observable's updates</p> <code>ConditionalObservable[T]</code> <p>based on the condition. The conditional observable starts with None</p> <code>ConditionalObservable[T]</code> <p>if the condition is initially False.</p> <p>Examples:</p> <pre><code>from fynx.observable import Observable\n\n# Basic conditional filtering\ntemperature = Observable(\"temp\", 20)\nis_heating_on = Observable(\"heating\", False)\n\n# Only emit temperature when heating is on\nheating_temp = temperature &amp; is_heating_on\n\nheating_temp.subscribe(lambda t: print(f\"Maintaining {t}\u00b0C\"))\ntemperature.set(22)     # No output (heating off)\nis_heating_on.set(True) # Prints: \"Maintaining 22\u00b0C\"\ntemperature.set(25)     # Prints: \"Maintaining 25\u00b0C\"\n\n# Multiple conditions (chained)\nis_valid = Observable(\"valid\", True)\nsmart_heating = temperature &amp; is_heating_on &amp; is_valid\n\n# Resource optimization\nnetwork_available = Observable(\"network\", True)\nbattery_level = Observable(\"battery\", 80)\n\n# Only sync when network is available AND battery is not low\nsync_data = data_changes &amp; network_available &amp; (battery_level &gt;&gt; (lambda b: b &gt; 20))\n</code></pre> Note <p>Multiple conditions can be chained: <code>obs &amp; cond1 &amp; cond2 &amp; cond3</code>. All conditions must be True for values to be emitted.</p> See Also <p>ConditionalObservable: The class that implements conditional behavior invert: For negating boolean conditions watch: For conditional reactive functions with complex logic</p>"},{"location":"generation/markdown/core-api/#fynx.Observable.__bool__","title":"__bool__","text":"<pre><code>__bool__()\n</code></pre> <p>Boolean conversion returns whether the value is truthy.</p> <p>This allows observables to be used directly in boolean contexts (if statements, boolean operations) just like regular values.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the wrapped value is truthy, False otherwise.</p> Example <pre><code>obs = Observable(\"flag\", True)\nif obs:  # Works like if obs.value\n    print(\"Observable is truthy\")\n\nobs.set(0)  # False\nif not obs:  # Works like if not obs.value\n    print(\"Observable is falsy\")\n</code></pre>"},{"location":"generation/markdown/core-api/#fynx.Observable.__eq__","title":"__eq__","text":"<pre><code>__eq__(other)\n</code></pre> <p>Equality comparison with another value or observable.</p> <p>Compares the wrapped values for equality. If comparing with another Observable, compares their wrapped values.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>object</code> <p>Value or Observable to compare with</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the values are equal, False otherwise.</p> Example <pre><code>obs1 = Observable(\"a\", 5)\nobs2 = Observable(\"b\", 5)\nregular_val = 5\n\nobs1 == obs2      # True (both wrap 5)\nobs1 == regular_val  # True (observable equals regular value)\nobs1 == 10        # False (5 != 10)\n</code></pre>"},{"location":"generation/markdown/core-api/#fynx.Observable.__hash__","title":"__hash__","text":"<pre><code>__hash__()\n</code></pre> <p>Hash based on object identity, not value.</p> <p>Since values may be unhashable (like dicts, lists), observables hash based on their object identity rather than their value.</p> <p>Returns:</p> Type Description <code>int</code> <p>Hash of the observable's object identity.</p> Note <p>This means observables with the same value will not be considered equal for hashing purposes, only identical objects.</p> Example <pre><code>obs1 = Observable(\"a\", [1, 2, 3])\nobs2 = Observable(\"b\", [1, 2, 3])\n\n# These will have different hashes despite same value\nhash(obs1) != hash(obs2)  # True\n\n# But identical objects hash the same\nhash(obs1) == hash(obs1)  # True\n</code></pre>"},{"location":"generation/markdown/core-api/#fynx.Observable.__invert__","title":"__invert__","text":"<pre><code>__invert__()\n</code></pre> <p>Create a negated boolean observable using the ~ operator.</p> <p>This creates a computed observable that returns the logical negation of the current observable's boolean value. Useful for creating inverse conditions and boolean logic in reactive expressions.</p> <p>Returns:</p> Type Description <code>Observable[bool]</code> <p>A computed Observable[bool] with the negated boolean value.</p> <code>Observable[bool]</code> <p>Updates automatically when the source observable changes.</p> <p>Examples:</p> <pre><code>from fynx.observable import Observable\n\nis_loading = Observable(\"loading\", False)\n\n# Create negated observable\nis_not_loading = ~is_loading  # True when is_loading is False\n\n# Use in conditional logic\ncan_interact = ~is_loading\ncan_interact.subscribe(lambda can: print(f\"Can interact: {can}\"))\n\nis_loading.set(True)   # Prints: \"Can interact: False\"\nis_loading.set(False)  # Prints: \"Can interact: True\"\n\n# Chain with other conditions\nis_enabled = Observable(\"enabled\", True)\nshould_show_spinner = is_loading &amp; is_enabled\nshould_hide_content = is_loading &amp; ~is_enabled  # Loading but not enabled\n\n# Complex boolean logic\nis_valid = Observable(\"valid\", True)\nhas_errors = Observable(\"errors\", False)\n\ncan_submit = is_valid &amp; ~has_errors &amp; ~is_loading\n</code></pre> Note <p>This creates a computed observable, so the negation is evaluated lazily and cached until the source value changes.</p> See Also <p>and: For combining conditions with AND logic computed: For creating other computed transformations</p>"},{"location":"generation/markdown/core-api/#fynx.Observable.__or__","title":"__or__","text":"<pre><code>__or__(other)\n</code></pre> <p>Combine this observable with another using the | operator.</p> <p>This creates a merged observable that contains a tuple of both values and updates automatically when either observable changes.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Observable</code> <p>Another Observable to combine with</p> required <p>Returns:</p> Type Description <code>MergedObservable[T]</code> <p>A MergedObservable containing both values as a tuple</p> Example <pre><code>combined = obs1 | obs2  # Creates MergedObservable((obs1.value, obs2.value))\ncombined2 = combined | obs3  # Creates MergedObservable((obs1.value, obs2.value, obs3.value))\n</code></pre>"},{"location":"generation/markdown/core-api/#fynx.Observable.__repr__","title":"__repr__","text":"<pre><code>__repr__()\n</code></pre> <p>Developer representation showing the observable's key and current value.</p> <p>Returns:</p> Type Description <code>str</code> <p>A string representation useful for debugging and development.</p> Example <pre><code>obs = Observable(\"counter\", 42)\nprint(repr(obs))  # Observable('counter', 42)\n</code></pre>"},{"location":"generation/markdown/core-api/#fynx.Observable.__rshift__","title":"__rshift__","text":"<pre><code>__rshift__(func)\n</code></pre> <p>Apply a transformation function using the &gt;&gt; operator to create computed observables.</p> <p>This implements the functorial map operation over observables, allowing you to transform observable values through pure functions while preserving reactivity. The result is a new observable that automatically updates when the source changes.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable</code> <p>A pure function to apply to the observable's value(s).   For single observables, receives the current value.   For merged observables, receives unpacked tuple values as separate arguments.</p> required <p>Returns:</p> Type Description <code>Observable</code> <p>A new computed Observable containing the transformed values.</p> <p>Examples:</p> <pre><code>from fynx.observable import Observable\n\n# Single observable transformation\ncounter = Observable(\"counter\", 5)\ndoubled = counter &gt;&gt; (lambda x: x * 2)  # Observable with value 10\n\n# String formatting\nname = Observable(\"name\", \"Alice\")\ngreeting = name &gt;&gt; (lambda n: f\"Hello, {n}!\")\n\n# Merged observable transformation\nwidth = Observable(\"width\", 10)\nheight = Observable(\"height\", 20)\narea = (width | height) &gt;&gt; (lambda w, h: w * h)  # Observable with value 200\n\n# Complex chaining\nresult = counter &gt;&gt; (lambda x: x + 1) &gt;&gt; str &gt;&gt; (lambda s: f\"Count: {s}\")\n# Result: Observable with value \"Count: 6\"\n</code></pre> Note <p>The transformation function should be pure (no side effects) and relatively fast, as it may be called frequently when dependencies change.</p> See Also <p>computed: The underlying function that creates computed observables or: For merging observables before transformation</p>"},{"location":"generation/markdown/core-api/#fynx.Observable.__set_name__","title":"__set_name__","text":"<pre><code>__set_name__(owner, name)\n</code></pre> <p>Called when this Observable is assigned to a class attribute.</p> <p>This method implements the descriptor protocol to enable automatic conversion of Observable instances to appropriate descriptors based on the owning class type.</p> <p>For Store classes, the conversion is handled by StoreMeta metaclass. For other classes, converts to SubscriptableDescriptor for class-level observable behavior.</p> <p>Parameters:</p> Name Type Description Default <code>owner</code> <code>Type</code> <p>The class that owns this attribute</p> required <code>name</code> <code>str</code> <p>The name of the attribute being assigned</p> required Note <p>This method is called automatically by Python when an Observable instance is assigned to a class attribute. It modifies the class to use the appropriate descriptor for reactive behavior.</p> Example <pre><code>class MyClass:\n    obs = Observable(\"counter\", 0)  # __set_name__ called here\n\n# Gets converted to a descriptor automatically\ninstance = MyClass()\nprint(instance.obs)  # Uses descriptor\n</code></pre>"},{"location":"generation/markdown/core-api/#fynx.Observable.__str__","title":"__str__","text":"<pre><code>__str__()\n</code></pre> <p>String representation of the wrapped value.</p> <p>Returns the string representation of the current value, enabling observables to be used seamlessly in string contexts.</p> <p>Returns:</p> Type Description <code>str</code> <p>String representation of the wrapped value.</p> Example <pre><code>obs = Observable(\"name\", \"Alice\")\nprint(f\"Hello {obs}\")  # Prints: \"Hello Alice\"\nmessage = \"User: \" + obs  # Works like \"User: \" + obs.value\n</code></pre>"},{"location":"generation/markdown/core-api/#fynx.Observable.add_observer","title":"add_observer","text":"<pre><code>add_observer(observer)\n</code></pre> <p>Add an observer function that will be called when this observable changes.</p> <p>Parameters:</p> Name Type Description Default <code>observer</code> <code>Callable</code> <p>A callable that takes no arguments</p> required"},{"location":"generation/markdown/core-api/#fynx.Observable.remove_observer","title":"remove_observer","text":"<pre><code>remove_observer(observer)\n</code></pre> <p>Remove an observer function.</p> <p>Parameters:</p> Name Type Description Default <code>observer</code> <code>Callable</code> <p>The observer function to remove</p> required"},{"location":"generation/markdown/core-api/#fynx.Observable.set","title":"set","text":"<pre><code>set(value)\n</code></pre> <p>Set the value and notify all observers if the value changed.</p> <p>This method updates the observable's value and triggers change notifications to all registered observers. The update only occurs if the new value is different from the current value (using != comparison).</p> <p>Circular dependency detection is performed to prevent infinite loops where a computation tries to modify one of its own dependencies.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Optional[T]</code> <p>The new value to set. Can be any type compatible with the    observable's generic type parameter.</p> required <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If setting this value would create a circular dependency          (e.g., a computed value trying to modify its own input).</p> Example <pre><code>obs = Observable(\"counter\", 0)\nobs.set(5)  # Triggers observers if value changed\n\n# No change, no notification\nobs.set(5)  # Same value, observers not called\n</code></pre> Note <p>Equality is checked using <code>!=</code> operator, so custom objects should implement proper equality comparison if needed.</p>"},{"location":"generation/markdown/core-api/#fynx.Observable.subscribe","title":"subscribe","text":"<pre><code>subscribe(func)\n</code></pre> <p>Subscribe a function to react to changes in this observable.</p> <p>The subscribed function will be called immediately with the current value, and then again whenever the observable's value changes.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable</code> <p>A callable that accepts one argument (the new value).   The function will be called with the observable's current value   immediately upon subscription, and again whenever the value changes.</p> required <p>Returns:</p> Type Description <code>Observable[T]</code> <p>This observable instance for method chaining.</p> Example <pre><code>def on_change(new_value):\n    print(f\"Observable changed to: {new_value}\")\n\nobs = Observable(\"counter\", 0)\nobs.subscribe(on_change)  # Prints: \"Observable changed to: 0\"\n\nobs.set(5)  # Prints: \"Observable changed to: 5\"\n</code></pre> Note <p>The function is called immediately upon subscription with the current value. This ensures the subscriber gets the initial state.</p> See Also <p>unsubscribe: Remove a subscription reactive: Decorator-based subscription with automatic dependency tracking</p>"},{"location":"generation/markdown/core-api/#fynx.Observable.unsubscribe","title":"unsubscribe","text":"<pre><code>unsubscribe(func)\n</code></pre> <p>Unsubscribe a function from this observable.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable</code> <p>The function to unsubscribe from this observable</p> required"},{"location":"generation/markdown/core-api/#fynx.ReactiveContext","title":"ReactiveContext","text":"<pre><code>ReactiveContext(func, original_func=None, subscribed_observable=None)\n</code></pre> <p>Execution context for reactive functions with automatic dependency tracking.</p> <p>ReactiveContext manages the lifecycle of reactive functions (computations and reactions). It automatically tracks which observables are accessed during execution and sets up the necessary observers to re-run the function when any dependency changes.</p> <p>Key Responsibilities: - Track observable dependencies during function execution - Coordinate re-execution when dependencies change - Manage observer registration and cleanup - Handle merged observables and complex dependency relationships</p> <p>The context uses a stack-based approach to handle nested reactive functions, ensuring that dependencies are tracked correctly even in complex scenarios.</p> <p>Attributes:</p> Name Type Description <code>func</code> <code>Callable</code> <p>The reactive function to execute</p> <code>original_func</code> <code>Callable</code> <p>The original user function (for unsubscribe)</p> <code>subscribed_observable</code> <code>Observable</code> <p>The observable this context is subscribed to</p> <code>dependencies</code> <code>Set[Observable]</code> <p>Set of observables accessed during execution</p> <code>is_running</code> <code>bool</code> <p>Whether the context is currently executing</p> Note <p>This class is typically managed automatically by FynX's decorators and observable operations. Direct instantiation is usually not needed.</p> Example <pre><code># Usually created automatically by @reactive decorator\ncontext = ReactiveContext(my_function, my_function, some_observable)\ncontext.run()  # Executes function and tracks dependencies\n</code></pre>"},{"location":"generation/markdown/core-api/#fynx.ReactiveContext.add_dependency","title":"add_dependency","text":"<pre><code>add_dependency(observable)\n</code></pre> <p>Add an observable as a dependency of this context.</p>"},{"location":"generation/markdown/core-api/#fynx.ReactiveContext.dispose","title":"dispose","text":"<pre><code>dispose()\n</code></pre> <p>Stop the reactive computation and remove all observers.</p>"},{"location":"generation/markdown/core-api/#fynx.ReactiveContext.run","title":"run","text":"<pre><code>run()\n</code></pre> <p>Run the reactive function, tracking dependencies.</p>"},{"location":"generation/markdown/core-api/#fynx.Store","title":"Store","text":"<p>Base class for reactive state containers with observable attributes.</p> <p>Store provides a convenient way to group related observable values together and manage their lifecycle as a cohesive unit. Store subclasses can define observable attributes using the <code>observable()</code> descriptor, and Store provides methods for subscribing to changes, serializing state, and managing the reactive relationships.</p> <p>Key Features: - Automatic observable attribute detection and management - Convenient subscription methods for reacting to state changes - Serialization/deserialization support for persistence - Snapshot functionality for debugging and state inspection</p> Example <pre><code>from fynx import Store, observable\n\nclass CounterStore(Store):\n    count = observable(0)\n    name = observable(\"Counter\")\n\n# Subscribe to all changes\n@CounterStore.subscribe\ndef on_change(snapshot):\n    print(f\"Counter: {snapshot.count}, Name: {snapshot.name}\")\n\n# Changes trigger reactions\nCounterStore.count = 5  # Prints: Counter: 5, Name: Counter\nCounterStore.name = \"My Counter\"  # Prints: Counter: 5, Name: My Counter\n</code></pre> Note <p>Store uses a metaclass to intercept attribute assignment, allowing <code>Store.attr = value</code> syntax to work seamlessly with observables.</p>"},{"location":"generation/markdown/core-api/#fynx.Store.load_state","title":"load_state","text":"<pre><code>load_state(state_dict)\n</code></pre> <p>Load state from a dictionary into the store's observables.</p>"},{"location":"generation/markdown/core-api/#fynx.Store.subscribe","title":"subscribe","text":"<pre><code>subscribe(func)\n</code></pre> <p>Subscribe a function to react to all observable changes.</p>"},{"location":"generation/markdown/core-api/#fynx.Store.to_dict","title":"to_dict","text":"<pre><code>to_dict()\n</code></pre> <p>Serialize all observable values to a dictionary.</p>"},{"location":"generation/markdown/core-api/#fynx.Store.unsubscribe","title":"unsubscribe","text":"<pre><code>unsubscribe(func)\n</code></pre> <p>Unsubscribe a function from all observables.</p>"},{"location":"generation/markdown/core-api/#fynx.Subscriptable","title":"Subscriptable","text":"<pre><code>Subscriptable(initial_value=None, original_observable=None)\n</code></pre> <p>Descriptor that creates reactive class attributes with transparent observable behavior.</p> <p>SubscriptableDescriptor enables Store classes and other reactive containers to define attributes that behave like regular Python attributes while providing full reactive capabilities. When accessed, it returns an ObservableValue instance that combines direct value access with observable methods.</p> <p>This descriptor is the foundation for FynX's transparent reactive programming model, allowing you to write code that looks like regular attribute access while maintaining full reactive capabilities.</p> <p>Key Features: - Class-Level Observables: Creates observables at the class level for shared state - Transparent Access: Attributes behave like regular values but are reactive - Automatic Management: Handles observable lifecycle and descriptor protocol - Store Integration: Designed to work seamlessly with Store classes - Memory Efficient: Reuses observable instances across class access</p> How It Works <ol> <li>When assigned to a class attribute, stores initial value and owner class</li> <li>On first access, creates a class-level Observable instance</li> <li>Returns an ObservableValue wrapper for transparent reactive access</li> <li>Subsequent accesses reuse the same observable instance</li> </ol> Example <pre><code>from fynx import Store, observable\n\nclass UserStore(Store):\n    # This creates a SubscriptableDescriptor\n    name = observable(\"Alice\")\n    age = observable(30)\n\n# Access returns ObservableValue instances\nuser_name = UserStore.name    # ObservableValue wrapping Observable\nuser_age = UserStore.age      # ObservableValue wrapping Observable\n\n# Behaves like regular attributes\nprint(user_name)              # \"Alice\"\nUserStore.name = \"Bob\"        # Updates the observable\nprint(user_name)              # \"Bob\"\n\n# But also provides reactive methods\nUserStore.name.subscribe(lambda n: print(f\"Name changed to: {n}\"))\n</code></pre> Note <p>This descriptor is typically used indirectly through the <code>observable()</code> function in Store classes. Direct instantiation is usually not needed.</p> See Also <p>ObservableValue: The wrapper returned by this descriptor observable: Convenience function that creates SubscriptableDescriptor instances Store: Uses this descriptor for reactive class attributes</p>"},{"location":"generation/markdown/core-api/#fynx.Subscriptable.__get__","title":"__get__","text":"<pre><code>__get__(instance, owner)\n</code></pre> <p>Get the observable value for this attribute.</p>"},{"location":"generation/markdown/core-api/#fynx.Subscriptable.__set__","title":"__set__","text":"<pre><code>__set__(instance, value)\n</code></pre> <p>Set the value on the observable.</p>"},{"location":"generation/markdown/core-api/#fynx.Subscriptable.__set_name__","title":"__set_name__","text":"<pre><code>__set_name__(owner, name)\n</code></pre> <p>Called when the descriptor is assigned to a class attribute.</p>"},{"location":"generation/markdown/merged-observable/","title":"MergedObservable","text":"<p>Observables that combine multiple values using the merge operator (<code>|</code>).</p>"},{"location":"generation/markdown/merged-observable/#fynx.observable.merged--fynx-mergedobservable-combined-reactive-values","title":"FynX MergedObservable - Combined Reactive Values","text":"<p>This module provides the MergedObservable class, which combines multiple individual observables into a single reactive unit. This enables treating related observables as a cohesive group that updates atomically when any component changes.</p> <p>Merged observables are useful for: - Coordinated Updates: When multiple values need to change together - Computed Relationships: When derived values depend on multiple inputs - Tuple Operations: When you need to pass multiple reactive values as a unit - State Composition: Building complex state from simpler reactive components</p> <p>The merge operation is created using the <code>|</code> operator between observables:</p> <pre><code>from fynx import observable\n\nwidth = observable(10)\nheight = observable(20)\ndimensions = width | height  # Creates MergedObservable\nprint(dimensions.value)  # (10, 20)\n\nwidth.set(15)\nprint(dimensions.value)  # (15, 20)\n</code></pre>"},{"location":"generation/markdown/merged-observable/#fynx.observable.merged.MergedObservable","title":"MergedObservable","text":"<pre><code>MergedObservable(*observables)\n</code></pre> <p>An observable that combines multiple observables into a single reactive tuple.</p> <p>MergedObservable creates a composite observable whose value is a tuple containing the current values of all source observables. When any source observable changes, the merged observable updates its tuple value and notifies all subscribers.</p> <p>This enables treating multiple related reactive values as a single atomic unit, which is particularly useful for:</p> <ul> <li>Functions that need multiple related parameters</li> <li>Computed values that depend on several inputs</li> <li>Coordinated state updates across multiple variables</li> <li>Maintaining referential consistency between related values</li> </ul> Example <pre><code>from fynx import observable, computed\n\n# Individual observables\nx = observable(10)\ny = observable(20)\n\n# Merge them into a single reactive unit\npoint = x | y\nprint(point.value)  # (10, 20)\n\n# Computed values can work with the tuple\ndistance_from_origin = computed(\n    lambda px, py: (px**2 + py**2)**0.5,\n    point\n)\nprint(distance_from_origin.value)  # 22.360679774997898\n\n# Changes to either coordinate update everything\nx.set(15)\nprint(point.value)                  # (15, 20)\nprint(distance_from_origin.value)   # 25.0\n</code></pre> Note <p>The merged observable's value is always a tuple, even when merging just two observables. This provides a consistent interface for computed functions.</p> See Also <p>Observable: Base observable class computed: For creating derived values from merged observables</p> <p>Create a merged observable from multiple source observables.</p> <p>Parameters:</p> Name Type Description Default <code>*observables</code> <code>Observable</code> <p>Variable number of Observable instances to combine.          At least one observable must be provided.</p> <code>()</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no observables are provided</p>"},{"location":"generation/markdown/merged-observable/#fynx.observable.merged.MergedObservable.value","title":"value","text":"<pre><code>value\n</code></pre> <p>Get the current tuple value, using cache when possible.</p> <p>Returns the current values of all source observables as a tuple. Uses caching to avoid recomputing the tuple on every access.</p> <p>Returns:</p> Type Description <p>A tuple containing the current values of all source observables,</p> <p>in the order they were provided to the constructor.</p> Example <pre><code>x = Observable(\"x\", 10)\ny = Observable(\"y\", 20)\nmerged = x | y\n\nprint(merged.value)  # (10, 20)\nx.set(15)\nprint(merged.value)  # (15, 20) - cache invalidated and recomputed\n</code></pre>"},{"location":"generation/markdown/merged-observable/#fynx.observable.merged.MergedObservable.__enter__","title":"__enter__","text":"<pre><code>__enter__()\n</code></pre> <p>Context manager entry for reactive blocks.</p> <p>Enables experimental syntax for defining reactive blocks that execute whenever any of the merged observables change.</p> <p>Returns:</p> Type Description <p>A context object that can be called with a function to create reactive behavior.</p> Example <pre><code># Experimental context manager syntax\nwith merged_obs as ctx:\n    ctx(lambda x, y: print(f\"Values changed: {x}, {y}\"))\n</code></pre> Note <p>This is an experimental feature. The more common approach is to use subscribe() or the @reactive decorator.</p>"},{"location":"generation/markdown/merged-observable/#fynx.observable.merged.MergedObservable.__exit__","title":"__exit__","text":"<pre><code>__exit__(exc_type, exc_val, exc_tb)\n</code></pre> <p>Context manager exit.</p> <p>Currently does nothing, but allows the context manager to work properly.</p>"},{"location":"generation/markdown/merged-observable/#fynx.observable.merged.MergedObservable.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(index)\n</code></pre> <p>Allow indexing into the merged observable like a tuple.</p> <p>Provides tuple-like access to individual values in the merged observable.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Zero-based index of the value to retrieve</p> required <p>Returns:</p> Type Description <code>T</code> <p>The value at the specified index</p> <p>Raises:</p> Type Description <code>IndexError</code> <p>If the index is out of range or the observable has no value</p> <p>Examples:</p> <pre><code>point = x | y | z\nprint(point[0])  # x value\nprint(point[1])  # y value\nprint(point[-1]) # z value\n</code></pre>"},{"location":"generation/markdown/merged-observable/#fynx.observable.merged.MergedObservable.__iter__","title":"__iter__","text":"<pre><code>__iter__()\n</code></pre> <p>Allow iteration over the tuple value.</p> <p>Enables unpacking and iteration over merged observable values.</p> <p>Yields:</p> Type Description <p>Individual values from the merged tuple.</p> <p>Examples:</p> <pre><code>coords = x | y | z\n# Unpack values\nx_val, y_val, z_val = coords\n\n# Iterate over values\nfor value in coords:\n    print(value)\n</code></pre>"},{"location":"generation/markdown/merged-observable/#fynx.observable.merged.MergedObservable.__len__","title":"__len__","text":"<pre><code>__len__()\n</code></pre> <p>Return the number of combined observables.</p> <p>Returns:</p> Type Description <code>int</code> <p>The number of source observables that were merged.</p> Example <pre><code>single = Observable(\"a\", 1)\npair = single | Observable(\"b\", 2)\ntriple = pair | Observable(\"c\", 3)\n\nprint(len(single))   # TypeError (single observable)\nprint(len(pair))     # 2\nprint(len(triple))   # 3\n</code></pre>"},{"location":"generation/markdown/merged-observable/#fynx.observable.merged.MergedObservable.__or__","title":"__or__","text":"<pre><code>__or__(other)\n</code></pre> <p>Chain merging with another observable using the | operator.</p> <p>Enables fluent syntax for building up merged observables incrementally. Each | operation creates a new MergedObservable containing all previous observables plus the new one.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Observable</code> <p>Another Observable to merge with this merged observable</p> required <p>Returns:</p> Type Description <code>MergedObservable</code> <p>A new MergedObservable containing all source observables from this</p> <code>MergedObservable</code> <p>merged observable plus the additional observable.</p> <p>Examples:</p> <pre><code># Chain multiple merges\na = Observable(\"a\", 1)\nb = Observable(\"b\", 2)\nc = Observable(\"c\", 3)\n\n# Method 1: Merge all at once\nmerged1 = MergedObservable(a, b, c)\n\n# Method 2: Chain merges\nmerged2 = a | b | c  # Same result as merged1\n\nprint(merged2.value)  # (1, 2, 3)\n</code></pre>"},{"location":"generation/markdown/merged-observable/#fynx.observable.merged.MergedObservable.__setitem__","title":"__setitem__","text":"<pre><code>__setitem__(index, value)\n</code></pre> <p>Allow setting values by index, updating the corresponding source observable.</p> <p>Provides a convenient way to update individual source observables through the merged interface.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Zero-based index of the source observable to update</p> required <code>value</code> <code>T</code> <p>New value for the source observable at that index</p> required <p>Raises:</p> Type Description <code>IndexError</code> <p>If the index is out of range</p> <p>Examples:</p> <pre><code>point = x | y | z\npoint[0] = 10  # Updates x\npoint[1] = 20  # Updates y\nprint(point.value)  # (10, 20, z.value)\n</code></pre>"},{"location":"generation/markdown/merged-observable/#fynx.observable.merged.MergedObservable.set","title":"set","text":"<pre><code>set(value)\n</code></pre> <p>Override set to invalidate cache.</p> <p>This method is not typically used directly on merged observables, as they derive their value from source observables. However, if you need to manually set a merged observable's value, this method ensures the internal cache is properly invalidated.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <p>The new tuple value to set</p> required Note <p>Manually setting merged observable values is uncommon. Usually, you update the source observables instead.</p>"},{"location":"generation/markdown/merged-observable/#fynx.observable.merged.MergedObservable.subscribe","title":"subscribe","text":"<pre><code>subscribe(func)\n</code></pre> <p>Subscribe a function to react to changes in any of the merged observables.</p> <p>The subscribed function will be called immediately with the current values of all merged observables, and then again whenever any source observable changes. This provides a way to react to coordinated changes across multiple observables.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable</code> <p>A callable that will receive the current values of all merged   observables as separate arguments, in the order they were merged.   The function signature should match the number of merged observables.</p> required <p>Returns:</p> Type Description <code>MergedObservable[T]</code> <p>This merged observable instance for method chaining.</p> <p>Examples:</p> <pre><code>x = Observable(\"x\", 1)\ny = Observable(\"y\", 2)\ncoords = x | y\n\ndef on_coords_change(x_val, y_val):\n    print(f\"Coordinates: ({x_val}, {y_val})\")\n\ncoords.subscribe(on_coords_change)  # Prints: \"Coordinates: (1, 2)\"\n\nx.set(10)  # Prints: \"Coordinates: (10, 2)\"\ny.set(20)  # Prints: \"Coordinates: (10, 20)\"\n</code></pre> Note <p>The function is called immediately upon subscription with current values. For more advanced reactive patterns, consider using the @reactive decorator or @watch decorator instead.</p> See Also <p>unsubscribe: Remove a subscription reactive: Decorator-based reactive functions</p>"},{"location":"generation/markdown/merged-observable/#fynx.observable.merged.MergedObservable.unsubscribe","title":"unsubscribe","text":"<pre><code>unsubscribe(func)\n</code></pre> <p>Unsubscribe a function from this merged observable.</p> <p>Removes the subscription for the specified function, preventing it from being called when the merged observable changes. This properly cleans up the reactive context and removes all observers.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable</code> <p>The function that was previously subscribed to this merged observable.   Must be the same function object that was passed to subscribe().</p> required <p>Examples:</p> <pre><code>def handler(x, y):\n    print(f\"Changed: {x}, {y}\")\n\ncoords = x | y\ncoords.subscribe(handler)\n\n# Later, unsubscribe\ncoords.unsubscribe(handler)  # No longer called when coords change\n</code></pre> Note <p>This only removes subscriptions to this specific merged observable. If the same function is subscribed to other observables, those subscriptions remain active.</p> See Also <p>subscribe: Add a subscription</p>"},{"location":"generation/markdown/observable-descriptors/","title":"Observable Descriptors","text":"<p>Classes for creating observable attributes in Store classes and other contexts.</p>"},{"location":"generation/markdown/observable-descriptors/#fynx.observable.descriptors--fynx-observable-descriptors-reactive-attribute-descriptors","title":"FynX Observable Descriptors - Reactive Attribute Descriptors","text":"<p>This module provides descriptor classes that enable transparent reactive programming in class attributes. These descriptors bridge the gap between regular Python attribute access and reactive capabilities, allowing Store classes to provide both familiar attribute syntax and full reactive behavior.</p>"},{"location":"generation/markdown/observable-descriptors/#fynx.observable.descriptors--transparent-reactivity","title":"Transparent Reactivity","text":"<p>FynX's descriptors enable \"transparent reactivity\" - the ability to write code that looks like regular attribute access while maintaining automatic dependency tracking and change propagation. This means you can use observables in existing code without major syntax changes.</p> <p>Instead of: <pre><code># Traditional reactive approach\nstore.counter.subscribe(lambda v: print(v))\nstore.counter.set(5)\n\n# Manual dependency tracking\ndef update_total():\n    total = store.price.value * store.quantity.value\n</code></pre></p> <p>You can write: <pre><code># Transparent reactive approach\nprint(store.counter)  # Direct access\nstore.counter = 5     # Automatic updates\n\n# Automatic dependency tracking\ntotal = store.price * store.quantity  # Reactive computation\n</code></pre></p>"},{"location":"generation/markdown/observable-descriptors/#fynx.observable.descriptors--how-it-works","title":"How It Works","text":"<p>The descriptor system works through two key components:</p> <ol> <li> <p>SubscriptableDescriptor: Attached to class attributes, creates and manages    the underlying Observable instances at the class level.</p> </li> <li> <p>ObservableValue: Returned when accessing descriptor attributes, provides    transparent value access while maintaining reactive capabilities.</p> </li> </ol> <p>When you access <code>store.counter</code>, the descriptor returns an ObservableValue that wraps the actual Observable, allowing natural value operations while preserving reactive behavior.</p>"},{"location":"generation/markdown/observable-descriptors/#fynx.observable.descriptors--key-benefits","title":"Key Benefits","text":"<ul> <li>Familiar Syntax: Use regular attribute access (<code>obj.attr = value</code>)</li> <li>Reactive Capabilities: Full access to subscription and operators</li> <li>Type Safety: Maintains type information through generics</li> <li>Performance: Efficient caching and lazy evaluation</li> <li>Compatibility: Works with existing Python idioms (iteration, comparison, etc.)</li> </ul>"},{"location":"generation/markdown/observable-descriptors/#fynx.observable.descriptors--common-patterns","title":"Common Patterns","text":"<p>Store Attributes: <pre><code>class UserStore(Store):\n    name = observable(\"Alice\")\n    age = observable(30)\n\n# Access like regular attributes\nprint(UserStore.name)      # \"Alice\"\nUserStore.age = 31         # Triggers reactive updates\n\n# But also provides reactive methods\nUserStore.name.subscribe(lambda n: print(f\"Name: {n}\"))\n</code></pre></p> <p>Transparent Integration: <pre><code># Works with existing Python constructs\nif store.is_enabled:\n    print(\"Enabled\")\n\nfor item in store.items:\n    print(item)\n\n# String formatting\nmessage = f\"User: {store.name}, Age: {store.age}\"\n</code></pre></p> <p>Reactive Operators: <pre><code># All operators work transparently\nfull_name = store.first_name | store.last_name &gt;&gt; (lambda f, l: f\"{f} {l}\")\nis_adult = store.age &gt;&gt; (lambda a: a &gt;= 18)\nvalid_user = store.name &amp; is_adult\n</code></pre></p>"},{"location":"generation/markdown/observable-descriptors/#fynx.observable.descriptors--implementation-details","title":"Implementation Details","text":"<p>Descriptor Protocol: Uses <code>__get__</code>, <code>__set__</code>, and <code>__set_name__</code> to integrate with Python's attribute system.</p> <p>Class-Level Storage: Observables are stored at the class level to ensure shared state across instances.</p> <p>Lazy Initialization: ObservableValue instances are created on-demand and cached for performance.</p> <p>Type Preservation: Generic types ensure compile-time type safety.</p>"},{"location":"generation/markdown/observable-descriptors/#fynx.observable.descriptors--performance-considerations","title":"Performance Considerations","text":"<ul> <li>Memory Efficient: Reuses Observable instances across attribute access</li> <li>Lazy Creation: ObservableValue wrappers created only when needed</li> <li>Minimal Overhead: Thin wrapper around actual Observable instances</li> <li>Caching: Internal caching prevents redundant operations</li> </ul>"},{"location":"generation/markdown/observable-descriptors/#fynx.observable.descriptors--best-practices","title":"Best Practices","text":"<ul> <li>Use Store Classes: Leverage descriptors through Store classes for better organization</li> <li>Consistent Access: Use either direct access or reactive methods, not both inconsistently</li> <li>Type Hints: Provide type annotations for better IDE support</li> <li>Documentation: Document store attributes and their purposes</li> </ul>"},{"location":"generation/markdown/observable-descriptors/#fynx.observable.descriptors--limitations","title":"Limitations","text":"<ul> <li>Descriptor behavior requires class-level attribute assignment</li> <li>Not suitable for instance-specific reactive attributes</li> <li>Some advanced Python features may not work as expected with wrapped values</li> </ul>"},{"location":"generation/markdown/observable-descriptors/#fynx.observable.descriptors--see-also","title":"See Also","text":"<ul> <li><code>fynx.store</code>: Store classes that use these descriptors</li> <li><code>fynx.observable</code>: Core observable classes</li> <li><code>fynx.computed</code>: Creating derived reactive values</li> </ul>"},{"location":"generation/markdown/observable-descriptors/#fynx.observable.descriptors.ObservableValue","title":"ObservableValue","text":"<pre><code>ObservableValue(observable)\n</code></pre> <p>A transparent wrapper that combines direct value access with observable capabilities.</p> <p>ObservableValue acts as a bridge between regular Python value access and reactive programming. It behaves like the underlying value in most contexts (equality, string conversion, iteration, etc.) while also providing access to observable methods like subscription and operator overloading.</p> <p>This class enables Store classes and other descriptor-based reactive systems to provide both familiar value access (<code>store.attr = value</code>) and reactive capabilities (<code>store.attr.subscribe(callback)</code>) through a single attribute.</p> <p>Key Features: - Transparent Value Access: Behaves like the underlying value for most operations - Observable Methods: Provides subscription and reactive operator access - Automatic Synchronization: Keeps the displayed value in sync with the observable - Operator Support: Enables <code>|</code>, <code>&gt;&gt;</code>, and other reactive operators - Type Safety: Generic type parameter ensures type-safe operations</p> Example <pre><code>from fynx import Store, observable\n\nclass CounterStore(Store):\n    count = observable(0)\n\n# ObservableValue provides both value access and reactive methods\ncounter = CounterStore.count\n\n# Direct value access (like a regular attribute)\nprint(counter)              # 0\nprint(counter == 0)         # True\nprint(len(counter))         # TypeError (unless value is a collection)\n\n# Observable methods\ncounter.set(5)              # Update the value\ncounter.subscribe(lambda x: print(f\"Count: {x}\"))\n\n# Reactive operators\ndoubled = counter &gt;&gt; (lambda x: x * 2)\n</code></pre> Note <p>ObservableValue instances are typically created automatically by SubscriptableDescriptor when accessing observable attributes on Store classes. You usually won't instantiate this class directly.</p> See Also <p>SubscriptableDescriptor: Creates ObservableValue instances for class attributes Observable: The underlying reactive value class Store: Uses ObservableValue for transparent reactive attributes</p>"},{"location":"generation/markdown/observable-descriptors/#fynx.observable.descriptors.ObservableValue.observable","title":"observable","text":"<pre><code>observable\n</code></pre> <p>Get the underlying observable instance.</p>"},{"location":"generation/markdown/observable-descriptors/#fynx.observable.descriptors.ObservableValue.__or__","title":"__or__","text":"<pre><code>__or__(other)\n</code></pre> <p>Support merging observables with | operator.</p>"},{"location":"generation/markdown/observable-descriptors/#fynx.observable.descriptors.ObservableValue.__rshift__","title":"__rshift__","text":"<pre><code>__rshift__(func)\n</code></pre> <p>Support computed observables with &gt;&gt; operator.</p>"},{"location":"generation/markdown/observable-descriptors/#fynx.observable.descriptors.SubscriptableDescriptor","title":"SubscriptableDescriptor","text":"<pre><code>SubscriptableDescriptor(initial_value=None, original_observable=None)\n</code></pre> <p>Descriptor that creates reactive class attributes with transparent observable behavior.</p> <p>SubscriptableDescriptor enables Store classes and other reactive containers to define attributes that behave like regular Python attributes while providing full reactive capabilities. When accessed, it returns an ObservableValue instance that combines direct value access with observable methods.</p> <p>This descriptor is the foundation for FynX's transparent reactive programming model, allowing you to write code that looks like regular attribute access while maintaining full reactive capabilities.</p> <p>Key Features: - Class-Level Observables: Creates observables at the class level for shared state - Transparent Access: Attributes behave like regular values but are reactive - Automatic Management: Handles observable lifecycle and descriptor protocol - Store Integration: Designed to work seamlessly with Store classes - Memory Efficient: Reuses observable instances across class access</p> How It Works <ol> <li>When assigned to a class attribute, stores initial value and owner class</li> <li>On first access, creates a class-level Observable instance</li> <li>Returns an ObservableValue wrapper for transparent reactive access</li> <li>Subsequent accesses reuse the same observable instance</li> </ol> Example <pre><code>from fynx import Store, observable\n\nclass UserStore(Store):\n    # This creates a SubscriptableDescriptor\n    name = observable(\"Alice\")\n    age = observable(30)\n\n# Access returns ObservableValue instances\nuser_name = UserStore.name    # ObservableValue wrapping Observable\nuser_age = UserStore.age      # ObservableValue wrapping Observable\n\n# Behaves like regular attributes\nprint(user_name)              # \"Alice\"\nUserStore.name = \"Bob\"        # Updates the observable\nprint(user_name)              # \"Bob\"\n\n# But also provides reactive methods\nUserStore.name.subscribe(lambda n: print(f\"Name changed to: {n}\"))\n</code></pre> Note <p>This descriptor is typically used indirectly through the <code>observable()</code> function in Store classes. Direct instantiation is usually not needed.</p> See Also <p>ObservableValue: The wrapper returned by this descriptor observable: Convenience function that creates SubscriptableDescriptor instances Store: Uses this descriptor for reactive class attributes</p>"},{"location":"generation/markdown/observable-descriptors/#fynx.observable.descriptors.SubscriptableDescriptor.__get__","title":"__get__","text":"<pre><code>__get__(instance, owner)\n</code></pre> <p>Get the observable value for this attribute.</p>"},{"location":"generation/markdown/observable-descriptors/#fynx.observable.descriptors.SubscriptableDescriptor.__set__","title":"__set__","text":"<pre><code>__set__(instance, value)\n</code></pre> <p>Set the value on the observable.</p>"},{"location":"generation/markdown/observable-descriptors/#fynx.observable.descriptors.SubscriptableDescriptor.__set_name__","title":"__set_name__","text":"<pre><code>__set_name__(owner, name)\n</code></pre> <p>Called when the descriptor is assigned to a class attribute.</p>"},{"location":"generation/markdown/observable-operators/","title":"Observable Operators","text":"<p>Special operators for composing and transforming observables.</p>"},{"location":"generation/markdown/observable-operators/#fynx.observable.operators--fynx-operators-observable-operator-implementations","title":"FynX Operators - Observable Operator Implementations","text":"<p>This module provides the core operator implementations that enable FynX's fluent reactive programming syntax. These operators allow observables to be composed using intuitive Python operators, creating complex reactive behaviors from simple building blocks.</p>"},{"location":"generation/markdown/observable-operators/#fynx.observable.operators--why-operators","title":"Why Operators?","text":"<p>FynX uses Python's operator overloading to provide a natural, readable syntax for reactive programming. Instead of verbose method calls, you can express reactive relationships using familiar operators:</p> <ul> <li><code>observable &gt;&gt; function</code> - Transform values reactively</li> <li><code>observable &amp; condition</code> - Filter values conditionally</li> <li><code>obs1 | obs2 | obs3</code> - Combine observables</li> </ul> <p>This approach makes reactive code more declarative and easier to understand.</p>"},{"location":"generation/markdown/observable-operators/#fynx.observable.operators--operator-overview","title":"Operator Overview","text":"<p>Transform (<code>&gt;&gt;</code>): Apply functions to create derived values <pre><code>doubled = counter &gt;&gt; (lambda x: x * 2)\n</code></pre></p> <p>Filter (<code>&amp;</code>): Only emit values when conditions are met <pre><code>valid_data = data &amp; is_valid\n</code></pre></p> <p>Combine (<code>|</code>): Merge multiple observables into tuples <pre><code>coordinates = x | y | z\n</code></pre></p> <p>These operators work together to create complex reactive pipelines: <pre><code>result = (x | y) &gt;&gt; (lambda a, b: a + b) &amp; (total &gt;&gt; (lambda t: t &gt; 10))\n</code></pre></p>"},{"location":"generation/markdown/observable-operators/#fynx.observable.operators--implementation-details","title":"Implementation Details","text":"<p>The operators are implemented as standalone functions rather than methods to avoid circular import issues and enable lazy loading. They are called automatically when you use the corresponding operators on Observable instances.</p> <p>The functions handle different observable types (regular, merged, conditional) appropriately, ensuring consistent behavior across the reactive system.</p>"},{"location":"generation/markdown/observable-operators/#fynx.observable.operators--performance-characteristics","title":"Performance Characteristics","text":"<ul> <li>Lazy Evaluation: Operators create computed/conditional observables that   only evaluate when needed</li> <li>Efficient Composition: Multiple operators can be chained without   creating intermediate objects</li> <li>Memory Conscious: Operators reuse existing infrastructure rather than   creating new classes</li> </ul>"},{"location":"generation/markdown/observable-operators/#fynx.observable.operators--common-patterns","title":"Common Patterns","text":"<p>Data Processing Pipeline: <pre><code>raw_data = observable([])\nprocessed = (raw_data\n    &gt;&gt; (lambda d: [x for x in d if x &gt; 0])  # Filter positive values\n    &gt;&gt; (lambda d: sorted(d))                # Sort results\n    &gt;&gt; (lambda d: sum(d) / len(d) if d else 0))  # Calculate average\n</code></pre></p> <p>Conditional UI Updates: <pre><code>user_input = observable(\"\")\nis_valid = user_input &gt;&gt; (lambda s: len(s) &gt;= 3)\nshow_error = user_input &amp; ~is_valid  # Show error when input is invalid but not empty\n</code></pre></p> <p>Reactive Calculations: <pre><code>price = observable(10.0)\nquantity = observable(1)\ntax_rate = observable(0.08)\n\nsubtotal = (price | quantity) &gt;&gt; (lambda p, q: p * q)\ntax = subtotal &gt;&gt; (lambda s: s * tax_rate.value)\ntotal = (subtotal | tax) &gt;&gt; (lambda s, t: s + t)\n</code></pre></p>"},{"location":"generation/markdown/observable-operators/#fynx.observable.operators--error-handling","title":"Error Handling","text":"<p>Operators handle errors gracefully: - Transformation function errors are propagated but don't break the reactive system - Invalid operator usage provides clear error messages - Circular dependencies are detected and prevented</p>"},{"location":"generation/markdown/observable-operators/#fynx.observable.operators--best-practices","title":"Best Practices","text":"<ul> <li>Keep Functions Pure: Transformation functions should not have side effects</li> <li>Use Meaningful Lambdas: Complex operations deserve named functions</li> <li>Chain Thoughtfully: Break complex chains into intermediate variables for clarity</li> <li>Handle Edge Cases: Consider what happens with None, empty collections, etc.</li> </ul>"},{"location":"generation/markdown/observable-operators/#fynx.observable.operators--migration-from-method-calls","title":"Migration from Method Calls","text":"<p>If you're familiar with other reactive libraries, here's how FynX operators compare:</p> <pre><code># Other libraries (method-based)\nresult = obs.map(lambda x: x * 2).filter(lambda x: x &gt; 10)\n\n# FynX (operator-based)\nresult = obs &gt;&gt; (lambda x: x * 2) &amp; (obs &gt;&gt; (lambda x: x &gt; 10))\n</code></pre> <p>The operator syntax is more concise and readable for simple transformations.</p>"},{"location":"generation/markdown/observable-operators/#fynx.observable.operators--see-also","title":"See Also","text":"<ul> <li><code>fynx.observable</code>: Core observable classes that use these operators</li> <li><code>fynx.computed</code>: Computed observables created by the <code>&gt;&gt;</code> operator</li> <li><code>fynx.watch</code>: Conditional reactive functions (alternative to <code>&amp;</code>)</li> </ul>"},{"location":"generation/markdown/observable-operators/#fynx.observable.operators.and_operator","title":"and_operator","text":"<pre><code>and_operator(obs, condition)\n</code></pre> <p>Implement the <code>&amp;</code> operator for creating conditional observables.</p> <p>This operator creates conditional observables that only emit values when boolean conditions are satisfied. The resulting observable filters the reactive stream, preventing unnecessary updates and computations when conditions aren't met.</p> <p>Parameters:</p> Name Type Description Default <code>obs</code> <code>Observable[T]</code> <p>The source observable whose values will be conditionally emitted.</p> required <code>condition</code> <code>Observable[bool]</code> <p>A boolean observable that acts as a gate. Values from <code>obs</code>       are only emitted when this condition is True.</p> required <p>Returns:</p> Type Description <code>Observable[T]</code> <p>A new ConditionalObservable that only emits values when the condition is met.</p> <code>Observable[T]</code> <p>The observable starts with None if the condition is initially False.</p> <p>Examples:</p> <pre><code>from fynx.observable import Observable\n\n# Basic conditional filtering\ndata = Observable(\"data\", \"hello\")\nis_ready = Observable(\"ready\", False)\n\nfiltered = data &amp; is_ready  # Only emits when is_ready is True\n\nfiltered.subscribe(lambda x: print(f\"Received: {x}\"))\ndata.set(\"world\")      # No output (is_ready is False)\nis_ready.set(True)     # Prints: \"Received: world\"\n\n# Multiple conditions (chained)\nuser_present = Observable(\"present\", True)\nsmart_data = data &amp; is_ready &amp; user_present  # All must be True\n\n# Practical example: temperature monitoring\ntemperature = Observable(\"temp\", 20)\nalarm_enabled = Observable(\"alarm\", True)\nis_critical = Observable(\"critical\", False)\n\nalarm_trigger = temperature &amp; alarm_enabled &amp; is_critical\nalarm_trigger.subscribe(lambda t: print(f\"\ud83d\udea8 Alarm: {t}\u00b0C\"))\n</code></pre> Note <p>Multiple conditions can be chained: <code>obs &amp; cond1 &amp; cond2 &amp; cond3</code>. All conditions must be True for values to be emitted.</p> See Also <p>ConditionalObservable: The class that implements conditional behavior Observable.and: The magic method that calls this operator</p>"},{"location":"generation/markdown/observable-operators/#fynx.observable.operators.rshift_operator","title":"rshift_operator","text":"<pre><code>rshift_operator(obs, func)\n</code></pre> <p>Implement the <code>&gt;&gt;</code> operator for creating computed observables.</p> <p>This operator enables the functorial map operation over observables, transforming observable values through pure functions while preserving reactivity. The resulting computed observable automatically updates whenever the source observable changes.</p> <p>For merged observables (created with <code>|</code>), the function receives multiple arguments corresponding to the tuple values. For single observables, it receives one argument.</p> <p>Parameters:</p> Name Type Description Default <code>obs</code> <code>Observable[T]</code> <p>The source observable(s) to transform. Can be a single Observable or  a MergedObservable (from <code>|</code> operator).</p> required <code>func</code> <code>Callable[..., U]</code> <p>A pure function that transforms the observable value(s). For merged   observables, receives unpacked tuple values as separate arguments.</p> required <p>Returns:</p> Type Description <code>Observable[U]</code> <p>A new computed observable containing the transformed values. Updates automatically</p> <code>Observable[U]</code> <p>when source observables change.</p> <p>Examples:</p> <pre><code>from fynx.observable import Observable\n\n# Single observable transformation\ncounter = Observable(\"counter\", 5)\ndoubled = counter &gt;&gt; (lambda x: x * 2)  # ComputedObservable with value 10\n\n# Merged observable transformation\nwidth = Observable(\"width\", 10)\nheight = Observable(\"height\", 20)\narea = (width | height) &gt;&gt; (lambda w, h: w * h)  # ComputedObservable with value 200\n\n# Function chaining\nresult = counter &gt;&gt; (lambda x: x + 1) &gt;&gt; str &gt;&gt; (lambda s: f\"Count: {s}\")\n# Result: \"Count: 6\"\n</code></pre> Note <p>The transformation function should be pure (no side effects) and relatively fast, as it may be called frequently when dependencies change.</p> See Also <p>computed: The underlying function that creates computed observables MergedObservable: For combining multiple observables with <code>|</code></p>"},{"location":"generation/markdown/observable/","title":"Observable","text":"<p>The core observable class that provides reactive values.</p> <p>A reactive value that automatically notifies dependents when it changes.</p> <p>Observable is the core primitive of FynX's reactivity system. It wraps a value and provides transparent reactive behavior - when the value changes, all dependent computations and reactions are automatically notified and updated.</p> <p>Key Features: - Transparent: Behaves like a regular value but with reactive capabilities - Dependency Tracking: Automatically tracks which reactive contexts depend on it - Change Notification: Notifies all observers when the value changes - Type Safety: Generic type parameter ensures type-safe operations - Lazy Evaluation: Computations only re-run when actually needed - Circular Dependency Detection: Prevents infinite loops at runtime</p> <p>Observable implements various magic methods (<code>__eq__</code>, <code>__str__</code>, etc.) to behave like its underlying value in most contexts, making it easy to use in existing code without modification.</p> <p>Attributes:</p> Name Type Description <code>key</code> <code>Optional[str]</code> <p>Unique identifier for debugging and serialization</p> <code>_value</code> <code>Optional[T]</code> <p>The current wrapped value</p> <code>_observers</code> <code>Set[Callable]</code> <p>Set of observer functions</p> Class Attributes <p>_current_context (Optional[ReactiveContext]): Current reactive execution context _context_stack (List[ReactiveContext]): Stack of nested reactive contexts</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Optional[str]</code> <p>A unique identifier for this observable (used for debugging).  If None, will be set to \"\" and updated in set_name. <code>None</code> <code>initial_value</code> <code>Optional[T]</code> <p>The initial value to store. Can be any type.</p> <code>None</code> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If a circular dependency is detected during value updates.</p> Example <pre><code>from fynx.observable import Observable\n\n# Create an observable\ncounter = Observable(\"counter\", 0)\n\n# Direct access (transparent behavior)\nprint(counter.value)  # 0\nprint(counter == 0)   # True\nprint(str(counter))   # \"0\"\n\n# Subscribe to changes\ndef on_change():\n    print(f\"Counter changed to: {counter.value}\")\n\ncounter.subscribe(on_change)\ncounter.set(5)  # Prints: \"Counter changed to: 5\"\n</code></pre> Note <p>While you can create Observable instances directly, it's often more convenient to use the <code>observable()</code> descriptor in Store classes for better organization and automatic serialization support.</p> See Also <p>Store: For organizing observables into reactive state containers computed: For creating derived values from observables reactive: For creating reactive functions that respond to changes</p> <p>Initialize an observable value.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Optional[str]</code> <p>A unique identifier for this observable (used for serialization).  If None, will be set to \"\" and updated in set_name. <code>None</code> <code>initial_value</code> <code>Optional[T]</code> <p>The initial value to store</p> <code>None</code>"},{"location":"generation/markdown/observable/#fynx.observable.base.Observable.value","title":"value","text":"<pre><code>value\n</code></pre> <p>Get the current value of this observable.</p> <p>Accessing the value property automatically registers this observable as a dependency if called within a reactive context (computation or reaction).</p> <p>Returns:</p> Type Description <code>Optional[T]</code> <p>The current value stored in this observable, or None if not set.</p> Note <p>This property is tracked by the reactive system. Use it instead of accessing _value directly to ensure proper dependency tracking.</p> Example <pre><code>obs = Observable(\"counter\", 5)\nprint(obs.value)  # 5\n\n# In a reactive context, this creates a dependency\n@reactive(obs)\ndef print_value(val):\n    print(f\"Value: {val}\")\n</code></pre>"},{"location":"generation/markdown/observable/#fynx.observable.base.Observable.__and__","title":"__and__","text":"<pre><code>__and__(condition)\n</code></pre> <p>Create a conditional observable using the &amp; operator for filtered reactivity.</p> <p>This creates a ConditionalObservable that only emits values from the source observable when the specified condition (and any chained conditions) are all True. This enables precise control over when reactive updates occur, preventing unnecessary computations and side effects.</p> <p>Parameters:</p> Name Type Description Default <code>condition</code> <code>Observable[bool]</code> <p>A boolean Observable that acts as a gate. The source observable's       values are only emitted when this condition is True.</p> required <p>Returns:</p> Type Description <code>ConditionalObservable[T]</code> <p>A ConditionalObservable that filters the source observable's updates</p> <code>ConditionalObservable[T]</code> <p>based on the condition. The conditional observable starts with None</p> <code>ConditionalObservable[T]</code> <p>if the condition is initially False.</p> <p>Examples:</p> <pre><code>from fynx.observable import Observable\n\n# Basic conditional filtering\ntemperature = Observable(\"temp\", 20)\nis_heating_on = Observable(\"heating\", False)\n\n# Only emit temperature when heating is on\nheating_temp = temperature &amp; is_heating_on\n\nheating_temp.subscribe(lambda t: print(f\"Maintaining {t}\u00b0C\"))\ntemperature.set(22)     # No output (heating off)\nis_heating_on.set(True) # Prints: \"Maintaining 22\u00b0C\"\ntemperature.set(25)     # Prints: \"Maintaining 25\u00b0C\"\n\n# Multiple conditions (chained)\nis_valid = Observable(\"valid\", True)\nsmart_heating = temperature &amp; is_heating_on &amp; is_valid\n\n# Resource optimization\nnetwork_available = Observable(\"network\", True)\nbattery_level = Observable(\"battery\", 80)\n\n# Only sync when network is available AND battery is not low\nsync_data = data_changes &amp; network_available &amp; (battery_level &gt;&gt; (lambda b: b &gt; 20))\n</code></pre> Note <p>Multiple conditions can be chained: <code>obs &amp; cond1 &amp; cond2 &amp; cond3</code>. All conditions must be True for values to be emitted.</p> See Also <p>ConditionalObservable: The class that implements conditional behavior invert: For negating boolean conditions watch: For conditional reactive functions with complex logic</p>"},{"location":"generation/markdown/observable/#fynx.observable.base.Observable.__bool__","title":"__bool__","text":"<pre><code>__bool__()\n</code></pre> <p>Boolean conversion returns whether the value is truthy.</p> <p>This allows observables to be used directly in boolean contexts (if statements, boolean operations) just like regular values.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the wrapped value is truthy, False otherwise.</p> Example <pre><code>obs = Observable(\"flag\", True)\nif obs:  # Works like if obs.value\n    print(\"Observable is truthy\")\n\nobs.set(0)  # False\nif not obs:  # Works like if not obs.value\n    print(\"Observable is falsy\")\n</code></pre>"},{"location":"generation/markdown/observable/#fynx.observable.base.Observable.__eq__","title":"__eq__","text":"<pre><code>__eq__(other)\n</code></pre> <p>Equality comparison with another value or observable.</p> <p>Compares the wrapped values for equality. If comparing with another Observable, compares their wrapped values.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>object</code> <p>Value or Observable to compare with</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the values are equal, False otherwise.</p> Example <pre><code>obs1 = Observable(\"a\", 5)\nobs2 = Observable(\"b\", 5)\nregular_val = 5\n\nobs1 == obs2      # True (both wrap 5)\nobs1 == regular_val  # True (observable equals regular value)\nobs1 == 10        # False (5 != 10)\n</code></pre>"},{"location":"generation/markdown/observable/#fynx.observable.base.Observable.__hash__","title":"__hash__","text":"<pre><code>__hash__()\n</code></pre> <p>Hash based on object identity, not value.</p> <p>Since values may be unhashable (like dicts, lists), observables hash based on their object identity rather than their value.</p> <p>Returns:</p> Type Description <code>int</code> <p>Hash of the observable's object identity.</p> Note <p>This means observables with the same value will not be considered equal for hashing purposes, only identical objects.</p> Example <pre><code>obs1 = Observable(\"a\", [1, 2, 3])\nobs2 = Observable(\"b\", [1, 2, 3])\n\n# These will have different hashes despite same value\nhash(obs1) != hash(obs2)  # True\n\n# But identical objects hash the same\nhash(obs1) == hash(obs1)  # True\n</code></pre>"},{"location":"generation/markdown/observable/#fynx.observable.base.Observable.__invert__","title":"__invert__","text":"<pre><code>__invert__()\n</code></pre> <p>Create a negated boolean observable using the ~ operator.</p> <p>This creates a computed observable that returns the logical negation of the current observable's boolean value. Useful for creating inverse conditions and boolean logic in reactive expressions.</p> <p>Returns:</p> Type Description <code>Observable[bool]</code> <p>A computed Observable[bool] with the negated boolean value.</p> <code>Observable[bool]</code> <p>Updates automatically when the source observable changes.</p> <p>Examples:</p> <pre><code>from fynx.observable import Observable\n\nis_loading = Observable(\"loading\", False)\n\n# Create negated observable\nis_not_loading = ~is_loading  # True when is_loading is False\n\n# Use in conditional logic\ncan_interact = ~is_loading\ncan_interact.subscribe(lambda can: print(f\"Can interact: {can}\"))\n\nis_loading.set(True)   # Prints: \"Can interact: False\"\nis_loading.set(False)  # Prints: \"Can interact: True\"\n\n# Chain with other conditions\nis_enabled = Observable(\"enabled\", True)\nshould_show_spinner = is_loading &amp; is_enabled\nshould_hide_content = is_loading &amp; ~is_enabled  # Loading but not enabled\n\n# Complex boolean logic\nis_valid = Observable(\"valid\", True)\nhas_errors = Observable(\"errors\", False)\n\ncan_submit = is_valid &amp; ~has_errors &amp; ~is_loading\n</code></pre> Note <p>This creates a computed observable, so the negation is evaluated lazily and cached until the source value changes.</p> See Also <p>and: For combining conditions with AND logic computed: For creating other computed transformations</p>"},{"location":"generation/markdown/observable/#fynx.observable.base.Observable.__or__","title":"__or__","text":"<pre><code>__or__(other)\n</code></pre> <p>Combine this observable with another using the | operator.</p> <p>This creates a merged observable that contains a tuple of both values and updates automatically when either observable changes.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Observable</code> <p>Another Observable to combine with</p> required <p>Returns:</p> Type Description <code>MergedObservable[T]</code> <p>A MergedObservable containing both values as a tuple</p> Example <pre><code>combined = obs1 | obs2  # Creates MergedObservable((obs1.value, obs2.value))\ncombined2 = combined | obs3  # Creates MergedObservable((obs1.value, obs2.value, obs3.value))\n</code></pre>"},{"location":"generation/markdown/observable/#fynx.observable.base.Observable.__repr__","title":"__repr__","text":"<pre><code>__repr__()\n</code></pre> <p>Developer representation showing the observable's key and current value.</p> <p>Returns:</p> Type Description <code>str</code> <p>A string representation useful for debugging and development.</p> Example <pre><code>obs = Observable(\"counter\", 42)\nprint(repr(obs))  # Observable('counter', 42)\n</code></pre>"},{"location":"generation/markdown/observable/#fynx.observable.base.Observable.__rshift__","title":"__rshift__","text":"<pre><code>__rshift__(func)\n</code></pre> <p>Apply a transformation function using the &gt;&gt; operator to create computed observables.</p> <p>This implements the functorial map operation over observables, allowing you to transform observable values through pure functions while preserving reactivity. The result is a new observable that automatically updates when the source changes.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable</code> <p>A pure function to apply to the observable's value(s).   For single observables, receives the current value.   For merged observables, receives unpacked tuple values as separate arguments.</p> required <p>Returns:</p> Type Description <code>Observable</code> <p>A new computed Observable containing the transformed values.</p> <p>Examples:</p> <pre><code>from fynx.observable import Observable\n\n# Single observable transformation\ncounter = Observable(\"counter\", 5)\ndoubled = counter &gt;&gt; (lambda x: x * 2)  # Observable with value 10\n\n# String formatting\nname = Observable(\"name\", \"Alice\")\ngreeting = name &gt;&gt; (lambda n: f\"Hello, {n}!\")\n\n# Merged observable transformation\nwidth = Observable(\"width\", 10)\nheight = Observable(\"height\", 20)\narea = (width | height) &gt;&gt; (lambda w, h: w * h)  # Observable with value 200\n\n# Complex chaining\nresult = counter &gt;&gt; (lambda x: x + 1) &gt;&gt; str &gt;&gt; (lambda s: f\"Count: {s}\")\n# Result: Observable with value \"Count: 6\"\n</code></pre> Note <p>The transformation function should be pure (no side effects) and relatively fast, as it may be called frequently when dependencies change.</p> See Also <p>computed: The underlying function that creates computed observables or: For merging observables before transformation</p>"},{"location":"generation/markdown/observable/#fynx.observable.base.Observable.__set_name__","title":"__set_name__","text":"<pre><code>__set_name__(owner, name)\n</code></pre> <p>Called when this Observable is assigned to a class attribute.</p> <p>This method implements the descriptor protocol to enable automatic conversion of Observable instances to appropriate descriptors based on the owning class type.</p> <p>For Store classes, the conversion is handled by StoreMeta metaclass. For other classes, converts to SubscriptableDescriptor for class-level observable behavior.</p> <p>Parameters:</p> Name Type Description Default <code>owner</code> <code>Type</code> <p>The class that owns this attribute</p> required <code>name</code> <code>str</code> <p>The name of the attribute being assigned</p> required Note <p>This method is called automatically by Python when an Observable instance is assigned to a class attribute. It modifies the class to use the appropriate descriptor for reactive behavior.</p> Example <pre><code>class MyClass:\n    obs = Observable(\"counter\", 0)  # __set_name__ called here\n\n# Gets converted to a descriptor automatically\ninstance = MyClass()\nprint(instance.obs)  # Uses descriptor\n</code></pre>"},{"location":"generation/markdown/observable/#fynx.observable.base.Observable.__str__","title":"__str__","text":"<pre><code>__str__()\n</code></pre> <p>String representation of the wrapped value.</p> <p>Returns the string representation of the current value, enabling observables to be used seamlessly in string contexts.</p> <p>Returns:</p> Type Description <code>str</code> <p>String representation of the wrapped value.</p> Example <pre><code>obs = Observable(\"name\", \"Alice\")\nprint(f\"Hello {obs}\")  # Prints: \"Hello Alice\"\nmessage = \"User: \" + obs  # Works like \"User: \" + obs.value\n</code></pre>"},{"location":"generation/markdown/observable/#fynx.observable.base.Observable.add_observer","title":"add_observer","text":"<pre><code>add_observer(observer)\n</code></pre> <p>Add an observer function that will be called when this observable changes.</p> <p>Parameters:</p> Name Type Description Default <code>observer</code> <code>Callable</code> <p>A callable that takes no arguments</p> required"},{"location":"generation/markdown/observable/#fynx.observable.base.Observable.remove_observer","title":"remove_observer","text":"<pre><code>remove_observer(observer)\n</code></pre> <p>Remove an observer function.</p> <p>Parameters:</p> Name Type Description Default <code>observer</code> <code>Callable</code> <p>The observer function to remove</p> required"},{"location":"generation/markdown/observable/#fynx.observable.base.Observable.set","title":"set","text":"<pre><code>set(value)\n</code></pre> <p>Set the value and notify all observers if the value changed.</p> <p>This method updates the observable's value and triggers change notifications to all registered observers. The update only occurs if the new value is different from the current value (using != comparison).</p> <p>Circular dependency detection is performed to prevent infinite loops where a computation tries to modify one of its own dependencies.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Optional[T]</code> <p>The new value to set. Can be any type compatible with the    observable's generic type parameter.</p> required <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If setting this value would create a circular dependency          (e.g., a computed value trying to modify its own input).</p> Example <pre><code>obs = Observable(\"counter\", 0)\nobs.set(5)  # Triggers observers if value changed\n\n# No change, no notification\nobs.set(5)  # Same value, observers not called\n</code></pre> Note <p>Equality is checked using <code>!=</code> operator, so custom objects should implement proper equality comparison if needed.</p>"},{"location":"generation/markdown/observable/#fynx.observable.base.Observable.subscribe","title":"subscribe","text":"<pre><code>subscribe(func)\n</code></pre> <p>Subscribe a function to react to changes in this observable.</p> <p>The subscribed function will be called immediately with the current value, and then again whenever the observable's value changes.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable</code> <p>A callable that accepts one argument (the new value).   The function will be called with the observable's current value   immediately upon subscription, and again whenever the value changes.</p> required <p>Returns:</p> Type Description <code>Observable[T]</code> <p>This observable instance for method chaining.</p> Example <pre><code>def on_change(new_value):\n    print(f\"Observable changed to: {new_value}\")\n\nobs = Observable(\"counter\", 0)\nobs.subscribe(on_change)  # Prints: \"Observable changed to: 0\"\n\nobs.set(5)  # Prints: \"Observable changed to: 5\"\n</code></pre> Note <p>The function is called immediately upon subscription with the current value. This ensures the subscriber gets the initial state.</p> See Also <p>unsubscribe: Remove a subscription reactive: Decorator-based subscription with automatic dependency tracking</p>"},{"location":"generation/markdown/observable/#fynx.observable.base.Observable.unsubscribe","title":"unsubscribe","text":"<pre><code>unsubscribe(func)\n</code></pre> <p>Unsubscribe a function from this observable.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable</code> <p>The function to unsubscribe from this observable</p> required"},{"location":"generation/markdown/reactive-decorator/","title":"@reactive Decorator","text":"<p>Decorator for creating reactive functions that run when observables change.</p>"},{"location":"generation/markdown/reactive-decorator/#fynx.reactive--fynx-reactive-reactive-decorators-and-utilities","title":"FynX Reactive - Reactive Decorators and Utilities","text":"<p>This module provides decorators and utilities for creating reactive relationships between observables and functions. Reactive decorators enable automatic execution of functions when their observable dependencies change, perfect for side effects like UI updates, API calls, logging, and other imperative operations.</p>"},{"location":"generation/markdown/reactive-decorator/#fynx.reactive--what-are-reactive-functions","title":"What are Reactive Functions?","text":"<p>Reactive functions are functions that automatically re-run whenever the observables they depend on change. Unlike computed values (which are declarative and return derived data), reactive functions are imperative and perform side effects.</p> <p>Reactive functions are ideal for: - UI Updates: Automatically updating displays when data changes - API Calls: Triggering network requests when relevant data changes - Logging: Recording changes for debugging or analytics - Side Effects: Any imperative operation that should respond to data changes - Synchronization: Keeping external systems in sync with reactive state</p>"},{"location":"generation/markdown/reactive-decorator/#fynx.reactive--key-characteristics","title":"Key Characteristics","text":"<ul> <li>Automatic Execution: Functions run whenever dependencies change</li> <li>Imperative: Designed for side effects, not data transformation</li> <li>Dependency Tracking: Framework automatically tracks accessed observables</li> <li>Unsubscription: Easy cleanup when reactive functions are no longer needed</li> <li>Multiple Targets: Can react to multiple observables or entire stores</li> </ul>"},{"location":"generation/markdown/reactive-decorator/#fynx.reactive--basic-usage","title":"Basic Usage","text":"<pre><code>```python\nfrom fynx import Store, observable, reactive\n</code></pre> <p>class CounterStore(Store):     count = observable(0)     name = observable(\"Counter\")</p> <p>@reactive(CounterStore.count, CounterStore.name) def log_counter_changes(count, name):     print(f\"Counter '{name}' changed to: {count}\")</p>"},{"location":"generation/markdown/reactive-decorator/#fynx.reactive--changes-trigger-the-reactive-function-automatically","title":"Changes trigger the reactive function automatically","text":"<p>CounterStore.count = 5   # Prints: \"Counter 'Counter' changed to: 5\" CounterStore.name = \"My Counter\"  # Prints: \"Counter 'My Counter' changed to: 5\" CounterStore.count = 10  # Prints: \"Counter 'My Counter' changed to: 10\" <pre><code>Advanced Patterns\n-----------------\n\n### Store-Level Reactions\n\nReact to any change in an entire store:\n\n```python\n    class UserStore(Store):\n        name = observable(\"Alice\")\n        age = observable(30)\n    email = observable(\"alice@example.com\")\n\n@reactive(UserStore)  # Reacts to any change in UserStore\ndef on_any_user_change():\n    snapshot = UserStore.to_dict()\n    print(f\"User data changed: {snapshot}\")\n\nUserStore.name = \"Bob\"   # Triggers: User data changed: {'name': 'Bob', 'age': 30, 'email': 'alice@example.com'}\nUserStore.age = 31       # Triggers again with updated data\n</code></pre></p>"},{"location":"generation/markdown/reactive-decorator/#fynx.reactive--mixed-observable-types","title":"Mixed Observable Types","text":"<p>Combine store-level and individual observable reactions:</p> <pre><code># React to store changes and a specific external observable\nis_online = observable(True)\n\n@reactive(UserStore, is_online)\ndef on_user_or_online_change():\n    user_data = UserStore.to_dict()\n    online_status = \"online\" if is_online.value else \"offline\"\n    print(f\"User {user_data['name']} is {online_status}\")\n\nUserStore.name = \"Charlie\"  # Triggers with current online status\nis_online.set(False)       # Triggers with current user data\n</code></pre>"},{"location":"generation/markdown/reactive-decorator/#fynx.reactive--cleanup-and-unsubscription","title":"Cleanup and Unsubscription","text":"<p>Reactive functions can be unsubscribed when no longer needed:</p> <pre><code># The reactive decorator returns the original function\n# so you can unsubscribe later if needed\nunsubscribe_func = reactive(CounterStore.count)(log_changes)\n# Later...\n# CounterStore.count.unsubscribe(log_changes)  # Unsubscribe specific function\n</code></pre>"},{"location":"generation/markdown/reactive-decorator/#fynx.reactive--real-world-examples","title":"Real-World Examples","text":""},{"location":"generation/markdown/reactive-decorator/#fynx.reactive--ui-update-simulation","title":"UI Update Simulation","text":"<pre><code>class ViewModel(Store):\n    search_query = observable(\"\")\n    results = observable([])\n    is_loading = observable(False)\n\n@reactive(ViewModel.search_query)\ndef update_search_results(query):\n    if query:\n        ViewModel.is_loading = True\n        # Simulate API call\n        ViewModel.results = [f\"Result for '{query}'\"]\n        ViewModel.is_loading = False\n    else:\n        ViewModel.results = []\n\n@reactive(ViewModel.results, ViewModel.is_loading)\ndef update_ui(results, loading):\n    if loading:\n        print(\"\ud83d\udd04 Loading...\")\n    else:\n        print(f\"\ud83d\udccb Found {len(results)} results: {results}\")\n\nViewModel.search_query = \"python\"  # Triggers both functions\n</code></pre>"},{"location":"generation/markdown/reactive-decorator/#fynx.reactive--form-validation","title":"Form Validation","text":"<pre><code>class FormStore(Store):\n    email = observable(\"\")\n    password = observable(\"\")\n    is_submitting = observable(False)\n\n@reactive(FormStore.email)\ndef validate_email(email):\n    is_valid = \"@\" in email and len(email) &gt; 5\n    print(f\"Email valid: {is_valid}\")\n\n@reactive(FormStore.password)\ndef validate_password(password):\n    is_strong = len(password) &gt;= 8\n    print(f\"Password strong: {is_strong}\")\n\nFormStore.email = \"user@\"       # Email valid: False\nFormStore.email = \"user@example.com\"  # Email valid: True\nFormStore.password = \"123\"      # Password strong: False\nFormStore.password = \"secure123\" # Password strong: True\n</code></pre>"},{"location":"generation/markdown/reactive-decorator/#fynx.reactive--analytics-tracking","title":"Analytics Tracking","text":"<pre><code>class AnalyticsStore(Store):\n    page_views = observable(0)\n    unique_visitors = observable(0)\n    current_page = observable(\"home\")\n\n@reactive(AnalyticsStore.page_views)\ndef track_page_views(views):\n    print(f\"\ud83d\udcca Analytics: {views} page views\")\n\n@reactive(AnalyticsStore.current_page)\ndef track_page_changes(page):\n    print(f\"\ud83d\udccd User navigated to: {page}\")\n\nAnalyticsStore.page_views = 150\nAnalyticsStore.current_page = \"products\"\nAnalyticsStore.page_views = 151  # Both functions trigger\n</code></pre>"},{"location":"generation/markdown/reactive-decorator/#fynx.reactive--performance-considerations","title":"Performance Considerations","text":"<p>Reactive functions include several performance optimizations:</p> <p>Efficient Tracking: Only tracks observables actually accessed during function execution</p> <p>Batch Updates: Multiple observable changes in quick succession trigger the function only once</p> <p>Memory Management: Automatic cleanup when reactive contexts are no longer needed</p> <p>Selective Execution: Functions only run when their specific dependencies change</p>"},{"location":"generation/markdown/reactive-decorator/#fynx.reactive--best-practices","title":"Best Practices","text":""},{"location":"generation/markdown/reactive-decorator/#fynx.reactive--keep-functions-focused","title":"Keep Functions Focused","text":"<p>Each reactive function should have a single, clear responsibility:</p> <pre><code># Good: Focused responsibilities\n@reactive(user_data)\ndef update_profile_ui(user_data):\n    # Only handles UI updates\n    pass\n\n@reactive(user_data)\ndef sync_to_server(user_data):\n    # Only handles server sync\n    pass\n\n# Avoid: Mixed responsibilities\n@reactive(user_data)\ndef handle_user_change(user_data):\n    # Updates UI, syncs to server, logs analytics...\n    pass\n</code></pre>"},{"location":"generation/markdown/reactive-decorator/#fynx.reactive--handle-errors-gracefully","title":"Handle Errors Gracefully","text":"<p>Reactive functions should handle exceptions to prevent breaking the reactive system:</p> <pre><code>@reactive(data)\ndef process_data_safely(data):\n    try:\n        # Process data...\n        result = expensive_operation(data)\n        update_ui(result)\n    except Exception as e:\n        print(f\"Error processing data: {e}\")\n        show_error_message()\n</code></pre>"},{"location":"generation/markdown/reactive-decorator/#fynx.reactive--use-appropriate-granularity","title":"Use Appropriate Granularity","text":"<p>Choose the right level of reactivity for your use case:</p> <pre><code># Fine-grained: React to specific changes\n@reactive(store.specific_field)\ndef handle_specific_change(value):\n    pass\n\n# Coarse-grained: React to any store change\n@reactive(store)\ndef handle_any_change():\n    pass\n</code></pre>"},{"location":"generation/markdown/reactive-decorator/#fynx.reactive--common-patterns","title":"Common Patterns","text":"<p>Event Logging: <pre><code>@reactive(store)\ndef log_all_changes():\n    print(f\"State changed at {datetime.now()}: {store.to_dict()}\")\n</code></pre></p> <p>Cache Invalidation: <pre><code>cache = {}\n@reactive(data_version)\ndef invalidate_cache(version):\n    cache.clear()\n    print(f\"Cache invalidated for version {version}\")\n</code></pre></p> <p>External System Sync: <pre><code>@reactive(local_data)\ndef sync_to_external_system(data):\n    external_api.update(data)\n    print(\"Synced to external system\")\n</code></pre></p>"},{"location":"generation/markdown/reactive-decorator/#fynx.reactive--limitations","title":"Limitations","text":"<ul> <li>Reactive functions cannot return values (use computed for that)</li> <li>Dependencies must be accessed synchronously during execution</li> <li>Functions execute for every dependency change (no debouncing built-in)</li> <li>Cannot create circular dependencies with observables</li> </ul>"},{"location":"generation/markdown/reactive-decorator/#fynx.reactive--troubleshooting","title":"Troubleshooting","text":"<p>Function not triggering: Ensure all accessed observables are passed as arguments to @reactive</p> <pre><code># Wrong: external_obs not declared as dependency\nexternal_obs = observable(10)\n@reactive(some_obs)\ndef wrong_func():\n    value = external_obs.value  # Not tracked!\n\n# Right: Declare all dependencies\n@reactive(some_obs, external_obs)\ndef right_func(some_val, external_val):\n    pass\n</code></pre> <p>Too many executions: Consider using @watch for conditional execution instead</p> <p>Performance issues: Break large reactive functions into smaller, focused ones</p>"},{"location":"generation/markdown/reactive-decorator/#fynx.reactive--comparison-with-other-approaches","title":"Comparison with Other Approaches","text":"<p>vs Manual Subscriptions: <pre><code># Manual (error-prone)\ndef setup():\n    obs.subscribe(callback)\n    obs2.subscribe(callback)\n    # Must manually unsubscribe later...\n\n# Reactive (declarative)\n@reactive(obs, obs2)\ndef callback():\n    pass  # Automatically managed\n</code></pre></p> <p>vs Computed Values: - Use @reactive for side effects (UI updates, API calls) - Use @computed for derived data (calculations, transformations)</p> <p>vs Watch Decorators: - Use @reactive for unconditional reactions to changes - Use @watch for conditional execution (only when conditions met)</p>"},{"location":"generation/markdown/reactive-decorator/#fynx.reactive--see-also","title":"See Also","text":"<ul> <li><code>fynx.watch</code>: Conditional reactive functions</li> <li><code>fynx.computed</code>: Derived reactive values</li> <li><code>fynx.store</code>: Reactive state containers</li> <li><code>fynx.observable</code>: Core observable classes</li> </ul>"},{"location":"generation/markdown/reactive-decorator/#fynx.reactive.ReactiveHandler","title":"ReactiveHandler","text":"<pre><code>ReactiveHandler(*targets)\n</code></pre> <p>Manages reactive function subscriptions and handles different target types.</p> <p>ReactiveHandler is the core implementation behind the <code>@reactive</code> decorator. It intelligently handles different types of targets (Store classes, individual observables) and creates the appropriate subscription mechanism.</p> <p>The handler supports: - Store class subscriptions (reacts to any change in the store) - Individual observable subscriptions (reacts to specific observables) - Mixed subscriptions (combination of stores and observables)</p> <p>This class is typically used indirectly through the <code>@reactive</code> decorator rather than instantiated directly.</p> Example <pre><code># These all use ReactiveHandler internally:\n@reactive(store_instance)      # Store subscription\n@reactive(obs1, obs2)          # Multiple observables\n@reactive(store_class.attr)    # Single observable\n</code></pre> <p>Initialize the reactive handler with target observables/stores.</p> <p>Parameters:</p> Name Type Description Default <code>*targets</code> <p>Variable number of observables, stores, or store attributes      to monitor for changes.</p> <code>()</code>"},{"location":"generation/markdown/reactive-decorator/#fynx.reactive.ReactiveHandler.__call__","title":"__call__","text":"<pre><code>__call__(func)\n</code></pre> <p>Decorator implementation that makes the function reactive.</p> <p>This method is called when the ReactiveHandler is used as a decorator. It sets up the reactive context for the decorated function and returns the original function (decorators typically return the same function).</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable</code> <p>The function to make reactive</p> required <p>Returns:</p> Type Description <code>Callable</code> <p>The original function, now configured to react to target changes</p> Example <pre><code>@reactive(store.count, store.name)\ndef update_display(count, name):\n    print(f\"Count: {count}, Name: {name}\")\n\n# This is equivalent to:\n# reactive_handler = ReactiveHandler(store.count, store.name)\n# update_display = reactive_handler(update_display)\n</code></pre>"},{"location":"generation/markdown/reactive-decorator/#fynx.reactive.reactive","title":"reactive","text":"<pre><code>reactive(*targets)\n</code></pre> <p>Create a reactive handler that works as a decorator.</p> <p>This is a convenience wrapper around subscribe() that works as a decorator.</p> As decorator <p>@reactive(store) - reacts to all observables in store @reactive(observable) - reacts to single observable @reactive(obs1, obs2, ...) - reacts to multiple observables</p> <p>Parameters:</p> Name Type Description Default <code>*targets</code> <p>Store class, Observable instance(s), or multiple Observable instances</p> <code>()</code> <p>Returns:</p> Type Description <p>ReactiveHandler that can be used as decorator</p>"},{"location":"generation/markdown/store/","title":"Store Class &amp; @observable Decorator","text":"<p>Container class for grouping observables and the decorator for making class attributes reactive.</p>"},{"location":"generation/markdown/store/#fynx.store--fynx-store-reactive-state-management-components","title":"FynX Store - Reactive State Management Components","text":"<p>This module provides the core components for reactive state management in FynX, enabling you to create organized, reactive state containers that group related observables together with convenient subscription and state management methods.</p>"},{"location":"generation/markdown/store/#fynx.store--why-use-stores","title":"Why Use Stores?","text":"<p>Stores help you organize your application's reactive state into logical units. Instead of having observables scattered throughout your codebase, Stores group related data together and provide convenient methods for subscribing to changes, serializing state, and managing the reactive lifecycle.</p> <p>Stores are particularly useful for: - Application State: Global app state like user preferences, theme settings - Feature State: State for specific features like shopping cart, user profile - Component State: Local state that needs to be shared across multiple components - Business Logic: Computed values and derived state based on raw data</p>"},{"location":"generation/markdown/store/#fynx.store--core-components","title":"Core Components","text":"<p>Store: A base class for creating reactive state containers. Store classes can define observable attributes using the <code>observable()</code> descriptor, and automatically provide methods for subscribing to changes and managing state.</p> <p>observable: A descriptor function that creates observable attributes on Store classes. Use this to define reactive properties in your Store subclasses.</p> <p>StoreSnapshot: An immutable snapshot of store state at a specific point in time, useful for debugging, logging, and ensuring consistent state access.</p> <p>StoreMeta: A metaclass that automatically converts observable attributes to descriptors and provides type hint compatibility for mypy.</p>"},{"location":"generation/markdown/store/#fynx.store--key-features","title":"Key Features","text":"<ul> <li>Automatic Observable Management: Store metaclass handles observable creation</li> <li>Convenient Subscriptions: Subscribe to all changes or individual observables</li> <li>State Serialization: Save and restore store state with <code>to_dict()</code> and <code>load_state()</code></li> <li>Type Safety: Full type hint support for better IDE experience</li> <li>Memory Efficient: Automatic cleanup and efficient change detection</li> <li>Composable: Easy to combine and nest multiple stores</li> </ul>"},{"location":"generation/markdown/store/#fynx.store--basic-usage","title":"Basic Usage","text":"<pre><code>from fynx import Store, observable\n\nclass CounterStore(Store):\n    count = observable(0)\n    name = observable(\"My Counter\")\n\n# Access values like regular attributes\nprint(CounterStore.count)  # 0\nCounterStore.count = 5     # Updates the observable\n\n# Subscribe to all changes in the store\n@CounterStore.subscribe\ndef on_store_change(snapshot):\n    print(f\"Store changed: count={snapshot.count}, name={snapshot.name}\")\n\nCounterStore.count = 10  # Triggers: \"Store changed: count=10, name=My Counter\"\n</code></pre>"},{"location":"generation/markdown/store/#fynx.store--advanced-patterns","title":"Advanced Patterns","text":""},{"location":"generation/markdown/store/#fynx.store--computed-properties-in-stores","title":"Computed Properties in Stores","text":"<pre><code>from fynx import Store, observable, computed\n\nclass UserStore(Store):\n    first_name = observable(\"John\")\n    last_name = observable(\"Doe\")\n    age = observable(30)\n\n    @computed\n    def full_name(self):\n        return f\"{self.first_name} {self.last_name}\"\n\n    @computed\n    def is_adult(self):\n        return self.age &gt;= 18\n\nprint(UserStore.full_name)  # \"John Doe\"\nUserStore.first_name = \"Jane\"\nprint(UserStore.full_name)  # \"Jane Doe\" (automatically updated)\n</code></pre>"},{"location":"generation/markdown/store/#fynx.store--state-persistence","title":"State Persistence","text":"<pre><code># Save store state\nstate = CounterStore.to_dict()\n# state = {\"count\": 10, \"name\": \"My Counter\"}\n\n# Restore state later\nCounterStore.load_state(state)\nprint(CounterStore.count)  # 10\n</code></pre>"},{"location":"generation/markdown/store/#fynx.store--store-composition","title":"Store Composition","text":"<pre><code>class AppStore(Store):\n    theme = observable(\"light\")\n    language = observable(\"en\")\n\nclass UserStore(Store):\n    name = observable(\"Alice\")\n    preferences = observable({})\n\n# Use both stores independently\nAppStore.theme = \"dark\"\nUserStore.name = \"Bob\"\n</code></pre>"},{"location":"generation/markdown/store/#fynx.store--store-lifecycle","title":"Store Lifecycle","text":"<p>Stores automatically manage the lifecycle of their observables:</p> <ol> <li> <p>Creation: When you define a Store subclass, the metaclass automatically    converts <code>observable()</code> calls into reactive descriptors.</p> </li> <li> <p>Access: When you access store attributes, you get transparent reactive values    that behave like regular Python attributes.</p> </li> <li> <p>Updates: When you assign to store attributes, the underlying observables are    updated and all dependent computations and reactions are notified.</p> </li> <li> <p>Cleanup: Reactive contexts are automatically cleaned up when no longer needed.</p> </li> </ol>"},{"location":"generation/markdown/store/#fynx.store--performance-considerations","title":"Performance Considerations","text":"<ul> <li>Efficient Updates: Only notifies subscribers when values actually change</li> <li>Lazy Evaluation: Computed properties only recalculate when accessed</li> <li>Memory Management: Automatic cleanup of unused reactive contexts</li> <li>Batch Updates: Multiple changes in quick succession are efficiently handled</li> </ul>"},{"location":"generation/markdown/store/#fynx.store--best-practices","title":"Best Practices","text":"<ul> <li>Group Related State: Keep related observables together in the same store</li> <li>Use Descriptive Names: Name your stores and observables clearly</li> <li>Avoid Large Stores: Split very large stores into smaller, focused ones</li> <li>Use Computed for Derived State: Don't store derived values manually</li> <li>Handle Errors: Reactive functions should handle exceptions gracefully</li> <li>Document Store Purpose: Use docstrings to explain what each store manages</li> </ul>"},{"location":"generation/markdown/store/#fynx.store--common-patterns","title":"Common Patterns","text":"<p>Singleton Stores: Use class-level access for global state:</p> <pre><code>class GlobalStore(Store):\n    is_loading = observable(False)\n    current_user = observable(None)\n\n# Access globally\nGlobalStore.is_loading = True\n</code></pre> <p>Instance Stores: Create store instances for per-component state:</p> <pre><code>class TodoStore(Store):\n    items = observable([])\n    filter = observable(\"all\")\n\nstore = TodoStore()  # Instance with its own state\n</code></pre> <p>Store Communication: Stores can reference each other:</p> <pre><code>class AuthStore(Store):\n    is_logged_in = observable(False)\n    user_id = observable(None)\n\nclass DataStore(Store):\n    @computed\n    def can_fetch_data(self):\n        return AuthStore.is_logged_in\n</code></pre>"},{"location":"generation/markdown/store/#fynx.store--migration-from-plain-observables","title":"Migration from Plain Observables","text":"<p>If you're using plain observables and want to migrate to Stores:</p> <pre><code># Before: Plain observables\nuser_name = observable(\"Alice\")\nuser_age = observable(30)\n\n# After: Store-based\nclass UserStore(Store):\n    name = observable(\"Alice\")\n    age = observable(30)\n\n# Access remains similar\nUserStore.name = \"Bob\"  # Instead of user_name.set(\"Bob\")\n</code></pre>"},{"location":"generation/markdown/store/#fynx.store--error-handling","title":"Error Handling","text":"<p>Stores handle errors gracefully:</p> <ul> <li>Observable updates that fail don't break the reactive system</li> <li>Computed property errors are logged but don't prevent other updates</li> <li>Store serialization handles missing or invalid data</li> </ul>"},{"location":"generation/markdown/store/#fynx.store--debugging","title":"Debugging","text":"<p>Use StoreSnapshot for debugging:</p> <pre><code># Capture current state\nsnapshot = StoreSnapshot(CounterStore, CounterStore._get_observable_attrs())\nprint(snapshot)  # Shows all observable values\n\n# Compare states\nold_snapshot = snapshot\n# ... do some operations ...\nnew_snapshot = StoreSnapshot(CounterStore, CounterStore._get_observable_attrs())\n# Compare old_snapshot and new_snapshot\n</code></pre>"},{"location":"generation/markdown/store/#fynx.store--see-also","title":"See Also","text":"<ul> <li><code>fynx.observable</code>: Core observable classes and operators</li> <li><code>fynx.computed</code>: Creating computed properties</li> <li><code>fynx.reactive</code>: Reactive decorators for side effects</li> <li><code>fynx.watch</code>: Conditional reactive functions</li> </ul>"},{"location":"generation/markdown/store/#fynx.store.Store","title":"Store","text":"<p>Base class for reactive state containers with observable attributes.</p> <p>Store provides a convenient way to group related observable values together and manage their lifecycle as a cohesive unit. Store subclasses can define observable attributes using the <code>observable()</code> descriptor, and Store provides methods for subscribing to changes, serializing state, and managing the reactive relationships.</p> <p>Key Features: - Automatic observable attribute detection and management - Convenient subscription methods for reacting to state changes - Serialization/deserialization support for persistence - Snapshot functionality for debugging and state inspection</p> Example <pre><code>from fynx import Store, observable\n\nclass CounterStore(Store):\n    count = observable(0)\n    name = observable(\"Counter\")\n\n# Subscribe to all changes\n@CounterStore.subscribe\ndef on_change(snapshot):\n    print(f\"Counter: {snapshot.count}, Name: {snapshot.name}\")\n\n# Changes trigger reactions\nCounterStore.count = 5  # Prints: Counter: 5, Name: Counter\nCounterStore.name = \"My Counter\"  # Prints: Counter: 5, Name: My Counter\n</code></pre> Note <p>Store uses a metaclass to intercept attribute assignment, allowing <code>Store.attr = value</code> syntax to work seamlessly with observables.</p>"},{"location":"generation/markdown/store/#fynx.store.Store.load_state","title":"load_state","text":"<pre><code>load_state(state_dict)\n</code></pre> <p>Load state from a dictionary into the store's observables.</p>"},{"location":"generation/markdown/store/#fynx.store.Store.subscribe","title":"subscribe","text":"<pre><code>subscribe(func)\n</code></pre> <p>Subscribe a function to react to all observable changes.</p>"},{"location":"generation/markdown/store/#fynx.store.Store.to_dict","title":"to_dict","text":"<pre><code>to_dict()\n</code></pre> <p>Serialize all observable values to a dictionary.</p>"},{"location":"generation/markdown/store/#fynx.store.Store.unsubscribe","title":"unsubscribe","text":"<pre><code>unsubscribe(func)\n</code></pre> <p>Unsubscribe a function from all observables.</p>"},{"location":"generation/markdown/store/#fynx.store.StoreMeta","title":"StoreMeta","text":"<p>Metaclass for Store to automatically convert observable attributes to descriptors and adjust type hints for mypy compatibility.</p>"},{"location":"generation/markdown/store/#fynx.store.StoreMeta.__setattr__","title":"__setattr__","text":"<pre><code>__setattr__(name, value)\n</code></pre> <p>Intercept class attribute assignment for observables.</p>"},{"location":"generation/markdown/store/#fynx.store.StoreSnapshot","title":"StoreSnapshot","text":"<pre><code>StoreSnapshot(store_class, observable_attrs)\n</code></pre> <p>Immutable snapshot of store observable values at a specific point in time.</p>"},{"location":"generation/markdown/store/#fynx.store.StoreSnapshot.__getattr__","title":"__getattr__","text":"<pre><code>__getattr__(name)\n</code></pre> <p>Access snapshot values or fall back to class attributes.</p>"},{"location":"generation/markdown/store/#fynx.store.observable","title":"observable","text":"<pre><code>observable(initial_value=None)\n</code></pre> <p>Create an observable with an initial value, used as a descriptor in Store classes.</p>"},{"location":"generation/markdown/watch-decorator/","title":"@watch Decorator","text":"<p>Decorator for creating conditional reactive functions based on observable conditions.</p>"},{"location":"generation/markdown/watch-decorator/#fynx.watch--fynx-watch-conditional-reactive-utilities","title":"FynX Watch - Conditional Reactive Utilities","text":"<p>This module provides the <code>watch</code> decorator for creating conditional reactive computations that only execute when specific conditions are met. Unlike <code>@reactive</code> decorators that run on every change, <code>@watch</code> decorators only trigger when ALL specified conditions transition from unmet to met.</p>"},{"location":"generation/markdown/watch-decorator/#fynx.watch--when-to-use-watch-vs-reactive","title":"When to Use Watch vs Reactive","text":"<p>Use <code>@watch</code> when you need: - Functions that should only run when specific prerequisites are satisfied - State machines that react differently based on application state - Event filtering to avoid unnecessary operations when conditions aren't right - Resource optimization by avoiding computations when not needed</p> <p>Use <code>@reactive</code> when you need: - Functions that should run on every change to their dependencies - Unconditional side effects like logging or UI updates - Immediate responses to any state change</p>"},{"location":"generation/markdown/watch-decorator/#fynx.watch--key-characteristics","title":"Key Characteristics","text":"<ul> <li>Conditional Execution: Only runs when ALL conditions become true after being false</li> <li>Transition Detection: Triggers on false-&gt;true transitions, not ongoing true states</li> <li>Automatic Discovery: Framework finds observables accessed in condition functions</li> <li>Multiple Conditions: Supports AND logic across multiple conditions</li> <li>Error Resilience: Gracefully handles condition evaluation failures</li> </ul>"},{"location":"generation/markdown/watch-decorator/#fynx.watch--basic-usage","title":"Basic Usage","text":"<pre><code>from fynx import observable, watch\n\n# Setup state\nuser_online = observable(False)\nhas_messages = observable(0)\nnotification_enabled = observable(True)\n\n@watch(\n    lambda: user_online.value,           # User must be online\n    lambda: has_messages.value &gt; 0,      # Must have messages\n    lambda: notification_enabled.value   # Notifications must be enabled\n)\ndef send_notification():\n    print(f\"\ud83d\udcec Sending {has_messages.value} messages to user!\")\n\n# Only triggers when ALL conditions become true\nuser_online.set(True)        # Not yet (no messages)\nhas_messages.set(3)          # Not yet (notifications disabled)\nnotification_enabled.set(True)  # Now triggers: \"\ud83d\udcec Sending 3 messages to user!\"\n\nhas_messages.set(5)          # Triggers again: \"\ud83d\udcec Sending 5 messages to user!\"\nuser_online.set(False)       # Stop triggering\nhas_messages.set(10)         # No trigger (user offline)\n</code></pre>"},{"location":"generation/markdown/watch-decorator/#fynx.watch--advanced-patterns","title":"Advanced Patterns","text":""},{"location":"generation/markdown/watch-decorator/#fynx.watch--complex-conditions","title":"Complex Conditions","text":"<p>Conditions can be arbitrarily complex expressions:</p> <pre><code>temperature = observable(20)\nhumidity = observable(50)\nac_enabled = observable(True)\n\n@watch(\n    lambda: temperature.value &gt; 25,              # Hot enough\n    lambda: humidity.value &lt; 60,                 # Not too humid\n    lambda: ac_enabled.value,                    # AC is enabled\n    lambda: temperature.value &lt; 30 or humidity.value &lt; 40  # Either very hot OR very dry\n)\ndef activate_cooling():\n    print(\"\ud83c\udf21\ufe0f Activating air conditioning!\")\n</code></pre>"},{"location":"generation/markdown/watch-decorator/#fynx.watch--state-machines","title":"State Machines","text":"<p>Use watch decorators to implement state machine transitions:</p> <pre><code>app_state = observable(\"loading\")\nuser_authenticated = observable(False)\ndata_loaded = observable(False)\n\n@watch(lambda: app_state.value == \"loading\")\ndef show_loading_screen():\n    print(\"\u23f3 Showing loading screen...\")\n\n@watch(\n    lambda: user_authenticated.value,\n    lambda: data_loaded.value,\n    lambda: app_state.value == \"ready\"\n)\ndef show_main_app():\n    print(\"\u2705 Showing main application!\")\n\n# State transitions\napp_state.set(\"authenticating\")\nuser_authenticated.set(True)\napp_state.set(\"loading_data\")\ndata_loaded.set(True)\napp_state.set(\"ready\")  # Now triggers show_main_app()\n</code></pre>"},{"location":"generation/markdown/watch-decorator/#fynx.watch--resource-management","title":"Resource Management","text":"<p>Prevent unnecessary operations when resources aren't available:</p> <pre><code>network_available = observable(True)\nbattery_level = observable(100)\ndata_fresh = observable(False)\n\n@watch(\n    lambda: network_available.value,\n    lambda: battery_level.value &gt; 20,    # Don't sync on low battery\n    lambda: not data_fresh.value         # Only sync when data is stale\n)\ndef sync_data():\n    print(\"\ud83d\udd04 Syncing data...\")\n    # Perform expensive network operation\n    data_fresh.set(True)\n\nnetwork_available.set(False)\nbattery_level.set(15)\ndata_fresh.set(False)  # No sync (battery too low)\n\nbattery_level.set(80)\nnetwork_available.set(True)  # Triggers sync\n</code></pre>"},{"location":"generation/markdown/watch-decorator/#fynx.watch--real-world-examples","title":"Real-World Examples","text":""},{"location":"generation/markdown/watch-decorator/#fynx.watch--user-authentication-flow","title":"User Authentication Flow","text":"<pre><code>login_attempted = observable(False)\ncredentials_valid = observable(False)\ntwo_factor_complete = observable(False)\n\n@watch(\n    lambda: login_attempted.value,\n    lambda: credentials_valid.value,\n    lambda: two_factor_complete.value\n)\ndef grant_access():\n    print(\"\ud83d\udd10 Access granted!\")\n    # Redirect to dashboard, set session, etc.\n\n# Login flow\nlogin_attempted.set(True)\ncredentials_valid.set(True)\ntwo_factor_complete.set(True)  # Access granted\n</code></pre>"},{"location":"generation/markdown/watch-decorator/#fynx.watch--shopping-cart-checkout","title":"Shopping Cart Checkout","text":"<pre><code>cart_items = observable([])\npayment_method = observable(None)\nterms_accepted = observable(False)\n\n@watch(\n    lambda: len(cart_items.value) &gt; 0,\n    lambda: payment_method.value is not None,\n    lambda: terms_accepted.value\n)\ndef enable_checkout():\n    print(\"\ud83d\udcb3 Checkout button enabled!\")\n\ncart_items.set([{\"name\": \"Widget\", \"price\": 10}])\npayment_method.set(\"credit_card\")\nterms_accepted.set(True)  # Checkout now enabled\n</code></pre>"},{"location":"generation/markdown/watch-decorator/#fynx.watch--background-task-management","title":"Background Task Management","text":"<pre><code>task_queue = observable([])\nis_online = observable(True)\nbattery_saving = observable(False)\n\n@watch(\n    lambda: len(task_queue.value) &gt; 0,\n    lambda: is_online.value,\n    lambda: not battery_saving.value  # Don't run background tasks in battery saving mode\n)\ndef process_background_tasks():\n    print(f\"\ud83d\udd04 Processing {len(task_queue.value)} background tasks...\")\n\ntask_queue.set([\"sync\", \"backup\", \"cleanup\"])\nbattery_saving.set(True)     # No processing (battery saving)\nbattery_saving.set(False)    # Now triggers processing\n</code></pre>"},{"location":"generation/markdown/watch-decorator/#fynx.watch--performance-considerations","title":"Performance Considerations","text":"<p>Efficient Evaluation: Conditions are only re-evaluated when their dependencies change</p> <p>Dependency Tracking: Only tracks observables actually accessed in conditions</p> <p>Transition Optimization: Only triggers on condition state changes, not every update</p> <p>Memory Management: Automatic cleanup when watch decorators are no longer needed</p>"},{"location":"generation/markdown/watch-decorator/#fynx.watch--best-practices","title":"Best Practices","text":""},{"location":"generation/markdown/watch-decorator/#fynx.watch--keep-conditions-simple","title":"Keep Conditions Simple","text":"<p>Break complex conditions into simpler, more focused ones:</p> <pre><code># Good: Simple, focused conditions\n@watch(lambda: user.is_authenticated)\ndef load_user_data():\n    pass\n\n@watch(lambda: user.has_premium_plan)\ndef enable_premium_features():\n    pass\n\n# Avoid: Complex condition logic\n@watch(lambda: user.is_authenticated and user.has_premium_plan and not user.is_banned)\ndef handle_premium_user():\n    pass\n</code></pre>"},{"location":"generation/markdown/watch-decorator/#fynx.watch--use-descriptive-condition-names","title":"Use Descriptive Condition Names","text":"<p>Make conditions self-documenting:</p> <pre><code>def user_is_eligible():\n    return user.age &gt;= 18 and user.country in ALLOWED_COUNTRIES\n\ndef payment_is_complete():\n    return payment.status == \"completed\" and payment.amount &gt; 0\n\n@watch(user_is_eligible, payment_is_complete)\ndef process_purchase():\n    pass\n</code></pre>"},{"location":"generation/markdown/watch-decorator/#fynx.watch--handle-errors-gracefully","title":"Handle Errors Gracefully","text":"<p>Conditions that fail during evaluation are treated as False:</p> <pre><code>@watch(\n    lambda: user.preferences is not None,  # Safe null check\n    lambda: user.preferences.get(\"notifications\", False)  # Safe dict access\n)\ndef send_notification():\n    pass\n</code></pre>"},{"location":"generation/markdown/watch-decorator/#fynx.watch--common-patterns","title":"Common Patterns","text":"<p>Feature Flags: <pre><code>feature_enabled = observable(False)\nuser_has_access = observable(False)\n\n@watch(lambda: feature_enabled.value and user_has_access.value)\ndef enable_new_feature():\n    print(\"\u2728 New feature enabled!\")\n</code></pre></p> <p>Data Validation: <pre><code>email = observable(\"\")\npassword = observable(\"\")\n\n@watch(\n    lambda: \"@\" in email.value and \".\" in email.value.split(\"@\")[1],\n    lambda: len(password.value) &gt;= 8\n)\ndef enable_submit_button():\n    print(\"\u2705 Submit button enabled\")\n</code></pre></p> <p>Resource Availability: <pre><code>network_online = observable(True)\ndisk_space = observable(100)\n\n@watch(\n    lambda: network_online.value,\n    lambda: disk_space.value &gt; 10  # GB\n)\ndef start_download():\n    print(\"\ud83d\udce5 Starting download...\")\n</code></pre></p>"},{"location":"generation/markdown/watch-decorator/#fynx.watch--limitations","title":"Limitations","text":"<ul> <li>Conditions must be synchronous (no async/await)</li> <li>Only triggers on false-&gt;true transitions (not during sustained true states)</li> <li>Cannot create circular dependencies with watched observables</li> <li>Condition evaluation failures are treated as False</li> </ul>"},{"location":"generation/markdown/watch-decorator/#fynx.watch--troubleshooting","title":"Troubleshooting","text":"<p>Watch function not triggering: Ensure all observables accessed in conditions are properly tracked</p> <pre><code># Wrong: External observable not tracked\nexternal_flag = observable(True)\n@watch(lambda: some_obs.value &gt; 0)\ndef wrong_func():\n    if external_flag.value:  # Not tracked!\n        pass\n\n# Right: Include all dependencies in conditions\n@watch(\n    lambda: some_obs.value &gt; 0,\n    lambda: external_flag.value\n)\ndef right_func():\n    pass\n</code></pre> <p>Unexpected triggering: Remember watch only triggers on transitions, not sustained states</p> <p>Performance issues: Simplify complex conditions or break them into multiple watches</p>"},{"location":"generation/markdown/watch-decorator/#fynx.watch--comparison-with-reactive","title":"Comparison with Reactive","text":"Feature @reactive @watch Execution Every change Condition transitions only Use case Side effects Conditional logic Granularity Fine-grained Coarse-grained Performance Higher overhead Lower overhead Complexity Simple More complex"},{"location":"generation/markdown/watch-decorator/#fynx.watch--see-also","title":"See Also","text":"<ul> <li><code>fynx.reactive</code>: Unconditional reactive functions</li> <li><code>fynx.computed</code>: Derived reactive values</li> <li><code>fynx.store</code>: Reactive state containers</li> <li><code>fynx.observable</code>: Core observable classes</li> </ul>"},{"location":"generation/markdown/watch-decorator/#fynx.watch.watch","title":"watch","text":"<pre><code>watch(*conditions)\n</code></pre> <p>Decorator for conditional reactive functions that run only when conditions are met.</p> <p>The <code>watch</code> decorator creates a reactive function that only executes when ALL specified conditions become true, after previously being false. This enables guarded reactions that wait for specific state combinations before triggering.</p> <p>The decorator automatically discovers which observables are accessed within the condition functions and sets up the appropriate subscriptions. When any of these observables change, the conditions are re-evaluated, and the decorated function runs only if this represents a transition from \"not all conditions met\" to \"all conditions met\".</p> <p>Parameters:</p> Name Type Description Default <code>*conditions</code> <p>Variable number of condition functions. Each condition should be         a callable that returns a boolean value. Condition functions can         access observable values via <code>.value</code> attribute. All conditions         must return <code>True</code> for the decorated function to execute.</p> <code>()</code> <p>Returns:</p> Type Description <code>Callable</code> <p>A decorator function that can be applied to reactive functions.</p> <p>Examples: ```python from fynx import observable, watch</p> <pre><code># Basic conditional reaction\nuser_logged_in = observable(False)\ndata_loaded = observable(False)\n\n@watch(\n    lambda: user_logged_in.value,\n    lambda: data_loaded.value\n)\ndef show_dashboard():\n    print(\"Welcome to your dashboard!\")\n\n# Only shows when both conditions are true\nuser_logged_in.set(True)  # Not yet (data not loaded)\ndata_loaded.set(True)     # Now shows dashboard!\n\n# State-based reactions\napp_state = observable(\"loading\")\nerror_count = observable(0)\n\n@watch(\n    lambda: app_state.value == \"error\",\n    lambda: error_count.value &gt;= 3\n)\ndef show_error_recovery():\n    print(\"Too many errors - showing recovery options\")\n\n# Advanced conditions with computations\ntemperature = observable(20)\nhumidity = observable(50)\n\n@watch(\n    lambda: temperature.value &gt; 30,\n    lambda: humidity.value &lt; 30\n)\ndef activate_cooling():\n    print(\"Hot and dry - activating cooling system!\")\n\n# Conditions can be complex expressions\n@watch(lambda: temperature.value &lt; 0 or temperature.value &gt; 40)\ndef extreme_temperature_alert():\n    print(\"Extreme temperature detected!\")\n```\n</code></pre> Note <ul> <li>Condition functions should be pure and relatively fast</li> <li>The decorated function only runs on the transition from conditions not being   met to conditions being met (not on every change while conditions remain true)</li> <li>If condition evaluation fails during discovery or runtime, it's treated as False</li> <li>Observables accessed in conditions are automatically tracked as dependencies</li> </ul> See Also <p>reactive: For unconditional reactive functions computed: For derived reactive values</p>"},{"location":"specs/v1.0-roadmap/","title":"Fynx Observable System - Product Specification for 1.0","text":"<p>Below is the roadmap for FynX. This represents what we believe is necessary for v1.0.0, but it is not set in stone \u2014 we welcome feedback and anticipate that the roadmap may evolve as we learn more and incorporate new ideas.</p>"},{"location":"specs/v1.0-roadmap/#1-overview","title":"1. Overview","text":"<p>A reactive observable system providing type-safe, composable primitives for finite state management and infinite stream processing with Pythonic operator semantics. Features deterministic concurrency handling through serialized propagation.</p>"},{"location":"specs/v1.0-roadmap/#2-concurrency-model-threading-behavior","title":"2. Concurrency Model &amp; Threading Behavior","text":""},{"location":"specs/v1.0-roadmap/#21-serialized-propagation-architecture","title":"2.1 Serialized Propagation Architecture","text":"<p>Description: All observables use an internal emission queue to ensure deterministic, race-free propagation regardless of emission source (sync thread, async coroutine, or background thread).</p> <p>Core Mechanism:</p> <ol> <li>Each observable (or the global system) maintains an internal emission queue</li> <li>Any emission (via <code>obs &lt;&lt; value</code>, assignment <code>obs = value</code>, or merged sources) enqueues the value</li> <li>A single propagation worker consumes the queue sequentially</li> <li>The worker recalculates derived observables, applies filters, and notifies subscribers in queue order</li> <li>Worker can be a dedicated thread or the current thread in single-threaded contexts</li> </ol> <p>Acceptance Criteria:</p> <ul> <li>[ ] All emissions are enqueued, never propagated directly on caller thread</li> <li>[ ] Propagation worker processes emissions sequentially in enqueue order</li> <li>[ ] Concurrent pushes from multiple threads/coroutines are serialized automatically</li> <li>[ ] No race conditions possible: subscribers never observe partial updates</li> <li>[ ] Merge order (<code>a @ b @ c</code>) determines transformation argument order deterministically</li> <li>[ ] Left-to-right evaluation: <code>(a @ b) @ c</code> processes <code>a</code>, then <code>b</code>, then <code>c</code> emissions in queue order</li> </ul>"},{"location":"specs/v1.0-roadmap/#22-thread-safe-enqueueing","title":"2.2 Thread-Safe Enqueueing","text":"<p>Open Questions: * What is the non-sugar api for this?</p> <p>Acceptance Criteria:</p> <ul> <li>[ ] Push operations (<code>&lt;&lt;</code>, assignment) are thread-safe</li> <li>[ ] Uses thread-safe queue implementation (<code>queue.Queue</code> or equivalent with locks)</li> <li>[ ] Multiple threads can emit concurrently without coordination</li> <li>[ ] Enqueue operation returns immediately (non-blocking for caller)</li> <li>[ ] Propagation happens asynchronously on worker thread/context</li> </ul> <p>Example:</p> <pre><code>stream = InfiniteObservable()\n\n# Thread 1\nstream &lt;&lt; 1\n\n# Thread 2 (concurrent)\nstream &lt;&lt; 2\n\n# Both enqueued safely; propagated sequentially in arrival order\n</code></pre>"},{"location":"specs/v1.0-roadmap/#23-asyncawait-integration","title":"2.3 Async/Await Integration","text":"<p>Acceptance Criteria:</p> <ul> <li>[ ] Supports <code>asyncio</code> integration via <code>asyncio.Queue</code> for propagation</li> <li>[ ] Sync context emissions use <code>loop.call_soon_threadsafe()</code> to enqueue</li> <li>[ ] Async context emissions can directly await queue operations</li> <li>[ ] Propagation coroutine processes emissions sequentially</li> <li>[ ] Users can emit from sync or async contexts transparently</li> <li>[ ] Subscribers can be sync or async callbacks (system handles both)</li> </ul> <p>Example:</p> <pre><code># Sync emission (from any thread)\nstream &lt;&lt; value  # Internally uses call_soon_threadsafe if async loop active\n\n# Async emission\nasync def process():\n    stream &lt;&lt; await fetch_data()\n\n# Async subscriber\nasync def async_handler(value):\n    await save_to_db(value)\n\nstream.subscribe(async_handler)  # System detects async and handles appropriately\n</code></pre>"},{"location":"specs/v1.0-roadmap/#24-propagation-guarantees","title":"2.4 Propagation Guarantees","text":"<p>Acceptance Criteria:</p> <ul> <li>[ ] Deterministic ordering: Emissions processed in exact enqueue order</li> <li>[ ] Atomic propagation: Each emission propagates completely before next emission starts</li> <li>[ ] No race conditions: Derived observables never see partial/inconsistent state</li> <li>[ ] Subscriber safety: All subscribers receive same value in same propagation cycle</li> <li>[ ] Single propagation per emission: Each emission triggers exactly one propagation pass</li> <li>[ ] Merge consistency: Left-to-right merge order preserved across all propagations</li> </ul> <p>Example:</p> <pre><code>a = observable(1)\nb = observable(2)\nmerged = a @ b\nresult = merged &gt;&gt; (lambda x, y: x + y)  # x from a, y from b (deterministic)\n\n# Thread 1\na = 10\n\n# Thread 2 (concurrent)\nb = 20\n\n# Result sees either (10, 2) or (1, 20) or (10, 20)\n# Never partial like (10, &lt;uninitialized&gt;)\n# Order determined by queue arrival, but always consistent\n</code></pre>"},{"location":"specs/v1.0-roadmap/#25-performance-considerations","title":"2.5 Performance Considerations","text":"<p>Latency:</p> <ul> <li>[ ] Slight overhead vs direct synchronous propagation (typically microseconds)</li> <li>[ ] Negligible for most applications</li> <li>[ ] Configurable queue processing batch size for high-throughput scenarios</li> </ul> <p>Backpressure:</p> <ul> <li>[ ] Optional max queue size to prevent unbounded memory growth</li> <li>[ ] Configurable overflow strategies: block, drop oldest, drop newest, raise error</li> <li>[ ] Monitoring API for queue depth inspection</li> </ul> <p>Example:</p> <pre><code># Configure backpressure (optional)\nstream = InfiniteObservable(max_queue_size=1000, overflow='drop_oldest')\n\n# Monitor queue health\nif stream.queue_depth() &gt; 900:\n    warnings.warn(\"Observable queue near capacity\")\n</code></pre>"},{"location":"specs/v1.0-roadmap/#26-user-experience","title":"2.6 User Experience","text":"<p>Acceptance Criteria:</p> <ul> <li>[ ] No API changes required for threading/async support</li> <li>[ ] System automatically detects execution context (sync/async, thread)</li> <li>[ ] Users never need to manage locks, mutexes, or async context explicitly</li> <li>[ ] Standard operators (<code>&lt;&lt;</code>, <code>=</code>, <code>&gt;&gt;</code>, <code>@</code>) work identically regardless of threading</li> <li>[ ] Subscribers always see sequential, deterministic updates</li> <li>[ ] Optional configuration for advanced use cases (queue size, worker threads)</li> </ul> <p>Example:</p> <pre><code># Works identically in all contexts\nstream &lt;&lt; value  # Sync thread\nstream &lt;&lt; value  # Async coroutine\nstream &lt;&lt; value  # Background thread\n\n# User never sees:\n# - Race conditions\n# - Partial updates\n# - Lock/mutex management\n# - async/await complexity (unless desired)\n</code></pre>"},{"location":"specs/v1.0-roadmap/#3-core-observable-types","title":"3. Core Observable Types","text":""},{"location":"specs/v1.0-roadmap/#31-genericobservable-base-type","title":"3.1 GenericObservable (Base Type)","text":"<p>Description: Abstract supertype for all observable types. Provides common interface and enables polymorphic operations across all observable subtypes.</p> <p>Acceptance Criteria:</p> <ul> <li>[ ] All observable types inherit from <code>GenericObservable</code></li> <li>[ ] All operators (<code>&gt;&gt;</code>, <code>@</code>, <code>.where()</code>, <code>.subscribe()</code>) work on <code>GenericObservable</code> instances regardless of concrete subtype</li> <li>[ ] Type system is transparent to users - operations return appropriate concrete types without requiring type-specific logic</li> <li>[ ] Generic observables can be composed with any other generic observable using standard operators</li> <li>[ ] Runtime type determination follows documented promotion rules (e.g., Finite + Infinite \u2192 Infinite)</li> <li>[ ] All emissions go through serialized propagation queue (see Section 2)</li> </ul>"},{"location":"specs/v1.0-roadmap/#32-finiteobservable","title":"3.2 FiniteObservable <p>Description: Single-valued reactive cell holding current value from discrete domain with serialized propagation.</p> <p>Acceptance Criteria:</p> <ul> <li>[ ] Holds exactly one value of type <code>T</code> at any moment</li> <li>[ ] Assignment enqueues value for propagation (not direct synchronous)</li> <li>[ ] Can be created via <code>observable(initial_value)</code> factory function</li> <li>[ ] Supports <code>obs = new_value</code> assignment syntax (thread-safe)</li> <li>[ ] Reading <code>.value</code> returns current value without triggering propagation</li> <li>[ ] Used as Store class property decorator: <code>property_name = observable(default)</code></li> <li>[ ] All dependent observables recalculate atomically during propagation worker pass</li> <li>[ ] Thread-safe: can be assigned from any thread</li> </ul> <p>Example:</p> <pre><code>counter = observable(5)\ndoubled = counter &gt;&gt; (lambda x: x * 2)\ncounter = 10  # Enqueued; doubled becomes 20 after propagation\n</code></pre>","text":""},{"location":"specs/v1.0-roadmap/#33-infiniteobservable","title":"3.3 InfiniteObservable <p>Description: Unbounded stream of values emitted asynchronously over time with serialized propagation.</p> <p>Acceptance Criteria:</p> <ul> <li>[ ] Maintains sequence of emissions with no defined \u201cfinal\u201d value</li> <li>[ ] Created via <code>InfiniteObservable()</code> constructor</li> <li>[ ] Supports <code>&lt;&lt;</code> push operator: <code>stream &lt;&lt; value</code> (thread-safe)</li> <li>[ ] Supports merging another stream: <code>stream &lt;&lt; other_stream</code></li> <li>[ ] Each emission enqueued and triggers downstream propagation independently</li> <li>[ ] Concurrent emissions are serialized: multiple threads can push simultaneously</li> <li>[ ] Emissions processed in queue arrival order</li> <li>[ ] Can emit zero or more values over lifetime</li> <li>[ ] Can merge with transformed streams: <code>stream &lt;&lt; upload.map(fn)</code></li> <li>[ ] Push operations are non-blocking (return immediately after enqueueing)</li> </ul> <p>Memory Management:</p> <ul> <li>[ ] Subscriptions maintain reference to observable</li> <li>[ ] Unsubscribing releases subscription reference but not observable</li> <li>[ ] Long-lived infinite observables should be explicitly disposed when no longer needed</li> <li>[ ] Consider weak references for subscriber management to prevent memory leaks</li> </ul> <p>Concurrent Emission Example:</p> <pre><code>stream = InfiniteObservable()\n\n# Thread 1\nfor i in range(100):\n    stream &lt;&lt; i\n\n# Thread 2 (concurrent)\nfor i in range(100, 200):\n    stream &lt;&lt; i\n\n# Thread 3 (concurrent)\nfor i in range(200, 300):\n    stream &lt;&lt; i\n\n# All 300 emissions safely enqueued and propagated sequentially\n# Subscribers see values in queue arrival order (deterministic per run)\n</code></pre>","text":""},{"location":"specs/v1.0-roadmap/#34-conditionalobservable","title":"3.4 ConditionalObservable <p>Description: Wrapper that filters emissions from source observable based on predicate with propagation queue integration.</p> <p>Acceptance Criteria:</p> <p>Core Filtering:</p> <ul> <li>[ ] Created via <code>.where(predicate)</code> method on any observable</li> <li>[ ] Predicate signature: <code>T \u2192 Bool</code></li> <li>[ ] Only propagates emissions where <code>predicate(value) == True</code></li> <li>[ ] Predicate evaluation happens in propagation worker context</li> <li>[ ] Preserves source type: <code>FiniteObservable.where()</code> \u2192 <code>FiniteObservable</code></li> <li>[ ] Preserves source type: <code>InfiniteObservable.where()</code> \u2192 <code>InfiniteObservable</code></li> <li>[ ] Thread-safe: source emissions can come from any thread</li> </ul> <p>Finite Source Semantics:</p> <ul> <li>[ ] Evaluates condition during propagation worker pass</li> <li>[ ] Suppresses downstream propagation when condition is <code>False</code></li> <li>[ ] No retroactive evaluation of past assignments</li> </ul> <p>Infinite Source Semantics:</p> <ul> <li>[ ] Acts as stream filter during propagation</li> <li>[ ] Does not affect previously emitted values</li> <li>[ ] Each emission independently evaluated against predicate in worker context</li> </ul> <p>Dynamic Conditions:</p> <ul> <li>[ ] Accepts observable predicates: <code>.where(condition_observable)</code></li> <li>[ ] Gates emissions based on current value of condition observable at propagation time</li> <li>[ ] For finite sources: checks condition during propagation worker pass</li> <li>[ ] For infinite sources: checks condition during propagation of each emission</li> </ul> <p>Composition:</p> <ul> <li>[ ] Chained <code>.where()</code> calls compose with AND logic</li> <li>[ ] <code>source.where(P1).where(P2)</code> equivalent to <code>source.where(lambda x: P1(x) and P2(x))</code></li> <li>[ ] Derived observables inherit conditional propagation</li> </ul> <p>Example:</p> <pre><code>stream = InfiniteObservable()\nevens = stream.where(lambda x: x % 2 == 0)\n\n# Thread-safe concurrent pushes\nstream &lt;&lt; 1  # suppressed during propagation\nstream &lt;&lt; 2  # evens emits 2 during propagation\nstream &lt;&lt; 3  # suppressed\nstream &lt;&lt; 4  # evens emits 4\n\ncondition = observable(True)\ngated = stream.where(condition)  # Checks condition at propagation time\n</code></pre>","text":""},{"location":"specs/v1.0-roadmap/#35-mergedobservable","title":"3.5 MergedObservable <p>Description: Unified emission stream combining multiple source observables with deterministic propagation order.</p> <p>Acceptance Criteria:</p> <p>Core Merging:</p> <ul> <li>[ ] Created via <code>@</code> operator: <code>obs1 @ obs2 @ obs3</code></li> <li>[ ] Accepts 2+ source observables of same type <code>T</code></li> <li>[ ] Emits union of all source emissions: <code>\u22c3\u1d62 emissions(s\u1d62)</code></li> <li>[ ] Merge order is deterministic and left-to-right: <code>(a @ b) @ c</code> always processes <code>a</code>, then <code>b</code>, then <code>c</code></li> <li>[ ] Interleaves emissions in queue arrival order (within propagation worker)</li> <li>[ ] Concurrent emissions from different sources serialized by propagation queue</li> </ul> <p>Type Determination:</p> <ul> <li>[ ] All finite sources \u2192 <code>FiniteObservable&lt;T&gt;</code></li> <li>[ ] All infinite sources \u2192 <code>InfiniteObservable&lt;T&gt;</code></li> <li>[ ] Mixed finite + infinite \u2192 <code>InfiniteObservable&lt;T&gt;</code> (most dynamic type wins)</li> </ul> <p>Finite Source Behavior:</p> <ul> <li>[ ] Each source assignment enqueued for propagation</li> <li>[ ] Merged result emits during propagation pass</li> <li>[ ] Sequential assignments preserve per-source ordering in queue</li> </ul> <p>Infinite Source Behavior:</p> <ul> <li>[ ] Each emission enqueued independently</li> <li>[ ] Emissions interleaved in queue arrival order</li> <li>[ ] Thread-safe: sources can emit from different threads concurrently</li> </ul> <p>Mixed Source Behavior:</p> <ul> <li>[ ] Finite sources contribute current value snapshot during propagation</li> <li>[ ] Infinite sources contribute ongoing emissions via queue</li> <li>[ ] Result exhibits both discrete and continuous characteristics</li> </ul> <p>Edge Cases:</p> <ul> <li>[ ] Empty merge <code>MergedObservable()</code> with no sources raises <code>ValueError</code></li> <li>[ ] Single source merge <code>MergedObservable(s)</code> returns identity (equivalent to <code>s</code>)</li> </ul> <p>Algebraic Properties:</p> <ul> <li>[ ] Identity: <code>MergedObservable(s) \u2261 s</code></li> <li>[ ] Associativity: <code>(a @ b) @ c \u2261 a @ (b @ c)</code></li> <li>[ ] Type closure: Result is always an observable</li> <li>[ ] Deterministic ordering: merge order determines transformation argument order (guaranteed by propagation queue)</li> </ul> <p>Concurrent Emission Example:</p> <pre><code>stream1 = InfiniteObservable()\nstream2 = InfiniteObservable()\nmerged = stream1 @ stream2\n\n# Thread 1\nstream1 &lt;&lt; \"A1\"\nstream1 &lt;&lt; \"A2\"\n\n# Thread 2 (concurrent)\nstream2 &lt;&lt; \"B1\"\nstream2 &lt;&lt; \"B2\"\n\n# Propagation worker sees queue like: [A1, B1, A2, B2] (example order)\n# Subscribers see deterministic sequence based on queue arrival\n# Transform receives arguments in merge order (stream1 first, stream2 second)\n\nresult = merged &gt;&gt; (lambda v1, v2: f\"{v1}+{v2}\")\n# v1 always from stream1, v2 always from stream2 (deterministic merge order)\n</code></pre>","text":""},{"location":"specs/v1.0-roadmap/#4-operators","title":"4. Operators","text":""},{"location":"specs/v1.0-roadmap/#41-transform-operator","title":"4.1 Transform Operator (<code>&gt;&gt;</code>) <p>Description: Creates derived observable by applying transformation function during propagation. Never mutates source observable.</p> <p>Acceptance Criteria:</p> <ul> <li>[ ] Signature: <code>Observable&lt;T&gt; &gt;&gt; (T \u2192 U) \u2192 Observable&lt;U&gt;</code></li> <li>[ ] Works on <code>GenericObservable</code> regardless of concrete type</li> <li>[ ] Always creates new observable; source remains unchanged</li> <li>[ ] Derived observable recalculates during propagation worker pass</li> <li>[ ] Supports chaining: <code>obs &gt;&gt; f &gt;&gt; g &gt;&gt; h</code></li> <li>[ ] Lazy evaluation: computes only during propagation pass</li> <li>[ ] Type preservation: Finite \u2192 Finite, Infinite \u2192 Infinite</li> <li>[ ] Multi-argument functions receive values in merge order (deterministic, left-to-right, guaranteed by propagation queue)</li> <li>[ ] Chained transformations compose left-to-right</li> <li>[ ] Transformation function called once per emission/update during propagation</li> <li>[ ] Thread-safe: source emissions can originate from any thread</li> </ul> <p>Example:</p> <pre><code>result = counter &gt;&gt; (lambda x: x * 2) &gt;&gt; (lambda x: x + 10)\n# counter unchanged; result is new observable\n# Transformation happens in propagation worker\n\ntotal = (count @ price) &gt;&gt; (lambda c, p: c * p)\n# c=count, p=price (merge order, deterministic even with concurrent updates)\n</code></pre>","text":""},{"location":"specs/v1.0-roadmap/#42-merge-operator","title":"4.2 Merge Operator (<code>@</code>) <p>Description: Combines multiple observables into unified stream with deterministic propagation order.</p> <p>Acceptance Criteria:</p> <ul> <li>[ ] Signature: <code>Observable&lt;T&gt; @ Observable&lt;T&gt; \u2192 MergedObservable&lt;T&gt;</code></li> <li>[ ] Works on <code>GenericObservable</code> instances</li> <li>[ ] Accepts 2+ operands: <code>a @ b @ c</code></li> <li>[ ] Associative: <code>(a @ b) @ c \u2261 a @ (b @ c)</code></li> <li>[ ] Deterministic left-to-right merge order preserved for downstream transformations (guaranteed by propagation queue)</li> <li>[ ] Result type follows type determination rules (section 3.5)</li> <li>[ ] Can be chained with <code>&gt;&gt;</code>: <code>(a @ b) &gt;&gt; transform_fn</code></li> <li>[ ] Raises <code>ValueError</code> if called with zero operands</li> <li>[ ] Thread-safe: operands can emit from different threads concurrently</li> </ul> <p>Example:</p> <pre><code>combined = obs1 @ obs2 @ obs3\nresult = combined &gt;&gt; (lambda v1, v2, v3: v1 + v2 + v3)\n# v1=obs1, v2=obs2, v3=obs3 (deterministic merge order)\n# Works correctly even if obs1, obs2, obs3 updated from different threads\n</code></pre>","text":""},{"location":"specs/v1.0-roadmap/#43-filter-method-where","title":"4.3 Filter Method (<code>.where()</code>) <p>Description: Creates conditional observable filtering emissions during propagation.</p> <p>Acceptance Criteria:</p> <ul> <li>[ ] Signature: <code>Observable&lt;T&gt;.where(T \u2192 Bool) \u2192 ConditionalObservable&lt;T&gt;</code></li> <li>[ ] Signature (dynamic): <code>Observable&lt;T&gt;.where(Observable&lt;Bool&gt;) \u2192 ConditionalObservable&lt;T&gt;</code></li> <li>[ ] Works on <code>GenericObservable</code></li> <li>[ ] Returns <code>ConditionalObservable</code> preserving source type (Finite/Infinite)</li> <li>[ ] Chainable: <code>obs.where(p1).where(p2)</code> applies AND logic</li> <li>[ ] Can be combined with other operators: <code>obs.where(pred) &gt;&gt; transform</code></li> <li>[ ] Predicate evaluation happens in propagation worker context</li> <li>[ ] Thread-safe: source can emit from any thread</li> </ul> <p>Example:</p> <pre><code>positives = counter.where(lambda x: x &gt; 0)\nevens = stream.where(lambda x: x % 2 == 0)\nfiltered = obs.where(p1).where(p2) &gt;&gt; transform\n# All predicates evaluated during propagation worker pass\n</code></pre>","text":""},{"location":"specs/v1.0-roadmap/#44-push-operator","title":"4.4 Push Operator (<code>&lt;&lt;</code>) <p>Description: Thread-safe emission into infinite observable stream via propagation queue.</p> <p>Acceptance Criteria:</p> <ul> <li>[ ] Signature: <code>InfiniteObservable&lt;T&gt; &lt;&lt; T \u2192 None</code></li> <li>[ ] Signature (merge): <code>InfiniteObservable&lt;T&gt; &lt;&lt; Observable&lt;T&gt; \u2192 None</code></li> <li>[ ] Only valid for <code>InfiniteObservable</code> instances</li> <li>[ ] Pushes single value: <code>stream &lt;&lt; value</code> (enqueues for propagation)</li> <li>[ ] Merges another observable: <code>stream &lt;&lt; other_observable</code></li> <li>[ ] Thread-safe: can be called from any thread concurrently</li> <li>[ ] Non-blocking: returns immediately after enqueueing</li> <li>[ ] Triggers downstream propagation during worker pass</li> <li>[ ] Returns <code>None</code> (side-effect only)</li> </ul> <p>Example:</p> <pre><code>stream &lt;&lt; 42  # Thread-safe, enqueued\nstream &lt;&lt; (upload &gt;&gt; process)  # Merge enqueued\n\n# Concurrent pushes (safe)\nthreading.Thread(target=lambda: stream &lt;&lt; 1).start()\nthreading.Thread(target=lambda: stream &lt;&lt; 2).start()\n# Both enqueued; propagated sequentially by worker\n</code></pre>","text":""},{"location":"specs/v1.0-roadmap/#45-subscribe-method-subscribe","title":"4.5 Subscribe Method (<code>.subscribe()</code>) <p>Description: Registers callback to react to observable changes during propagation.</p> <p>Acceptance Criteria:</p> <ul> <li>[ ] Signature: <code>Observable&lt;T&gt;.subscribe(T \u2192 None) \u2192 Subscription</code></li> <li>[ ] Works on <code>GenericObservable</code></li> <li>[ ] Callback invoked during propagation worker pass for each emission/update</li> <li>[ ] Returns subscription object for unsubscription</li> <li>[ ] Subscription has <code>.unsubscribe()</code> method</li> <li>[ ] Multiple subscribers supported per observable</li> <li>[ ] Callbacks receive current/emitted value as argument</li> <li>[ ] Callbacks execute in propagation worker context (thread-safe by design)</li> <li>[ ] All subscribers see same value in same propagation cycle (no races)</li> </ul> <p>Memory Management:</p> <ul> <li>[ ] Subscription maintains reference to observable and callback</li> <li>[ ] Calling <code>.unsubscribe()</code> releases callback reference</li> <li>[ ] Observable maintains weak references to subscriptions where possible</li> <li>[ ] Unsubscribing does not dispose the observable itself</li> <li>[ ] Subscribers should explicitly unsubscribe when done to prevent memory leaks</li> </ul> <p>Example:</p> <pre><code>subscription = obs.subscribe(lambda x: print(f\"Value: {x}\"))\n# Callback invoked in propagation worker context (safe)\n\nsubscription.unsubscribe()  # Release callback reference\n</code></pre>","text":""},{"location":"specs/v1.0-roadmap/#5-booleancomparison-operators","title":"5. Boolean/Comparison Operators","text":""},{"location":"specs/v1.0-roadmap/#51-boolean-logic-operators","title":"5.1 Boolean Logic Operators <p>Description: Native boolean operations on observables producing reactive boolean results with propagation queue semantics.</p> <p>Acceptance Criteria:</p> <ul> <li>[ ] <code>&amp;</code> operator: <code>obs1 &amp; obs2</code> returns observable evaluating AND during propagation</li> <li>[ ] <code>|</code> operator: <code>obs1 | obs2</code> returns observable evaluating OR during propagation (distinct from merge <code>@</code>)</li> <li>[ ] <code>~</code> operator: <code>~obs</code> returns observable negating value during propagation</li> <li>[ ] Operators work element-wise on current values at propagation time</li> <li>[ ] For finite sources: produces <code>FiniteObservable&lt;bool&gt;</code></li> <li>[ ] For infinite sources: produces stream of boolean evaluations per emission</li> <li>[ ] Results are fully reactive: update during propagation when any operand changes</li> <li>[ ] Works on <code>GenericObservable</code> instances</li> <li>[ ] Thread-safe: operands can be updated from different threads</li> </ul> <p>Mixed Type Behavior:</p> <ul> <li>[ ] <code>FiniteObservable&lt;bool&gt; &amp; InfiniteObservable&lt;bool&gt;</code> \u2192 <code>InfiniteObservable&lt;bool&gt;</code></li> <li>[ ] Finite operand provides current value snapshot; infinite operand drives emission timing</li> <li>[ ] Result emits on each infinite stream emission, using latest finite value at propagation time</li> </ul> <p>Example:</p> <pre><code>ready = uploaded &amp; valid &amp; (~processing)\nany_active = stream1 | stream2  # Boolean OR, not merge\n# All evaluations happen in propagation worker (thread-safe)\n</code></pre>","text":""},{"location":"specs/v1.0-roadmap/#52-comparison-operators","title":"5.2 Comparison Operators <p>Description: Comparison operators for observables returning reactive boolean observables with propagation semantics.</p> <p>Acceptance Criteria:</p> <ul> <li>[ ] Supports: <code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code></li> <li>[ ] Signature: <code>Observable&lt;T&gt; {op} T \u2192 Observable&lt;bool&gt;</code></li> <li>[ ] Signature: <code>Observable&lt;T&gt; {op} Observable&lt;T&gt; \u2192 Observable&lt;bool&gt;</code></li> <li>[ ] Returns reactive boolean observable</li> <li>[ ] Evaluates comparison during propagation worker pass</li> <li>[ ] Works with <code>@watch</code> decorator and standalone</li> <li>[ ] Works on <code>GenericObservable</code></li> <li>[ ] Thread-safe: operands can be updated from different threads</li> </ul> <p>Mixed Type Behavior:</p> <ul> <li>[ ] <code>FiniteObservable&lt;T&gt; &gt;= InfiniteObservable&lt;T&gt;</code> \u2192 <code>InfiniteObservable&lt;bool&gt;</code></li> <li>[ ] <code>InfiniteObservable&lt;T&gt; &gt;= FiniteObservable&lt;T&gt;</code> \u2192 <code>InfiniteObservable&lt;bool&gt;</code></li> <li>[ ] Finite operand provides current value snapshot at propagation time</li> <li>[ ] Infinite operand drives emission timing</li> <li>[ ] Each emission from infinite side triggers comparison with latest finite value during propagation</li> <li>[ ] <code>FiniteObservable&lt;T&gt; &gt;= FiniteObservable&lt;T&gt;</code> \u2192 <code>FiniteObservable&lt;bool&gt;</code> (updates when either changes)</li> <li>[ ] <code>InfiniteObservable&lt;T&gt; &gt;= InfiniteObservable&lt;T&gt;</code> \u2192 <code>InfiniteObservable&lt;bool&gt;</code> (emits when either emits)</li> </ul> <p>Example:</p> <pre><code>is_adult = age &gt;= 18\nis_equal = obs1 == obs2\nmatches = name == \"Alice\"\n\n# Mixed types\nexceeded = infinite_sensor &gt;= finite_threshold  # InfiniteObservable&lt;bool&gt;\n# Comparison happens in propagation worker using latest finite_threshold value\n</code></pre>","text":""},{"location":"specs/v1.0-roadmap/#6-decorator-watch","title":"6. Decorator: <code>@watch</code>","text":"<p>Description: Executes function when all condition observables evaluate to <code>True</code> during propagation. Triggers on every emission/update that satisfies all conditions.</p> <p>Acceptance Criteria:</p> <ul> <li>[ ] Signature: <code>@watch(condition1, condition2, ...) def fn(): ...</code></li> <li>[ ] Accepts multiple condition observables/lambdas</li> <li>[ ] Conditions are lambda expressions returning observables: <code>lambda: age &gt;= 18</code></li> <li>[ ] Lambdas evaluated reactively during propagation: re-evaluates whenever any observable referenced inside changes</li> <li>[ ] Executes function when ALL conditions are <code>True</code> during propagation worker pass</li> <li>[ ] Triggers once per emission/update that satisfies all conditions (no debouncing by default)</li> <li>[ ] Re-evaluates reactively during propagation when any condition observable changes</li> <li>[ ] Supports boolean/comparison operators in conditions</li> <li>[ ] Does not require observables to be used exclusively in <code>@watch</code> context</li> <li>[ ] Each condition lambda may reference multiple observables; any change triggers re-evaluation during propagation</li> <li>[ ] Thread-safe: conditions evaluated in propagation worker context, safe from races</li> </ul> <p>Execution Semantics:</p> <ul> <li>[ ] Function executes in propagation worker context when conditions become <code>True</code></li> <li>[ ] No automatic debouncing or coalescing (user can implement if needed)</li> <li>[ ] If multiple observables change concurrently, executes once during propagation with latest values</li> </ul> <p>Example:</p> <pre><code>@watch(lambda: User.age &gt;= 18, lambda: User.email.endswith('.com'))\ndef process_eligible_user():\n    print(\"Eligible user detected!\")\n# Triggers during propagation when conditions become True\n# Safe even if User.age and User.email updated from different threads\n\n@watch(lambda: (sensor_reading &gt; threshold) &amp; sensor_active)\ndef alert():\n    print(\"Alert!\")\n# Triggers during propagation on each emission where condition is True\n# Evaluation happens in propagation worker (thread-safe)\n</code></pre>"},{"location":"specs/v1.0-roadmap/#7-operator-summary-table","title":"7. Operator Summary Table","text":"Operator Signature Description Example <code>&gt;&gt;</code> <code>Observable&lt;T&gt; &gt;&gt; (T \u2192 U) \u2192 Observable&lt;U&gt;</code> Transform values (creates new observable) <code>doubled = x &gt;&gt; (lambda v: v * 2)</code> <code>@</code> <code>Observable&lt;T&gt; @ Observable&lt;T&gt; \u2192 MergedObservable&lt;T&gt;</code> Merge observables (deterministic order) <code>combined = a @ b</code> <code>.where()</code> <code>Observable&lt;T&gt;.where(T \u2192 Bool) \u2192 ConditionalObservable&lt;T&gt;</code> Filter emissions during propagation <code>pos = x.where(lambda v: v &gt; 0)</code> <code>&lt;&lt;</code> <code>InfiniteObservable&lt;T&gt; &lt;&lt; T \u2192 None</code> Thread-safe push to stream (enqueued) <code>stream &lt;&lt; value</code> <code>.subscribe()</code> <code>Observable&lt;T&gt;.subscribe(T \u2192 None) \u2192 Subscription</code> React to changes during propagation <code>obs.subscribe(print)</code> <code>&amp;</code> <code>Observable&lt;bool&gt; &amp; Observable&lt;bool&gt; \u2192 Observable&lt;bool&gt;</code> Boolean AND (evaluated during propagation) <code>ready = a &amp; b</code> <code>|</code> <code>Observable&lt;bool&gt; | Observable&lt;bool&gt; \u2192 Observable&lt;bool&gt;</code> Boolean OR (evaluated during propagation) <code>any_active = a | b</code> <code>~</code> <code>~Observable&lt;bool&gt; \u2192 Observable&lt;bool&gt;</code> Boolean NOT (evaluated during propagation) <code>inactive = ~active</code> <code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code> <code>Observable&lt;T&gt; {op} T \u2192 Observable&lt;bool&gt;</code> Comparison (evaluated during propagation) <code>adult = age &gt;= 18</code>"},{"location":"specs/v1.0-roadmap/#8-design-principles","title":"8. Design Principles","text":"<p>Acceptance Criteria:</p> <ul> <li>[ ] Type preservation: Operations preserve or predictably promote types per documented rules</li> <li>[ ] Composability: All operators support nesting and chaining</li> <li>[ ] Transparency: Internal taxonomy hidden from users; all operations work on <code>GenericObservable</code></li> <li>[ ] Immutability: Transformations always create new observables; sources never mutated</li> <li>[ ] Determinism: Merge order is left-to-right and consistent; propagation queue ensures sequential processing</li> <li>[ ] Algebraic rigor: Identity, associativity, and type closure properties maintained</li> <li>[ ] Pythonic elegance: Uses familiar Python operators and method chaining</li> <li>[ ] Accessibility: No category theory knowledge required; intuitive semantics</li> <li>[ ] Memory safety: Clear subscription lifecycle; explicit cleanup prevents leaks</li> <li>[ ] Concurrency safety: Serialized propagation queue eliminates race conditions; thread-safe by design</li> <li>[ ] Performance: Minimal latency overhead; configurable backpressure handling</li> </ul>"},{"location":"specs/v1.0-roadmap/#9-full-integration-example","title":"9. Full Integration Example","text":"<p>Acceptance Criteria:</p> <ul> <li>[ ] Following example works end-to-end with all specified features including threading:</li> </ul> <pre><code>class CartStore(Store):\n    item_count = observable(1)\n    price_per_item = observable(10.0)\n    discount_active = observable(False)\n\n# Merge observables (@ operator, deterministic order, thread-safe)\ncart_state = CartStore.item_count @ CartStore.price_per_item\n\n# Calculate subtotal (immutable transform, propagated via queue)\nsubtotal = cart_state &gt;&gt; (lambda count, price: count * price)\n\n# Apply discount conditionally (evaluated during propagation)\nfinal_price = (subtotal @ CartStore.discount_active) &gt;&gt; \\\n    (lambda total, discount: total * 0.9 if discount else total)\n\n# Subscribe to updates (callback runs in propagation worker context)\nsubscription = final_price.subscribe(lambda price: print(f\"Total: ${price:.2f}\"))\n\n# Changes propagate automatically via queue (thread-safe)\nCartStore.item_count = 3           # Enqueued \u2192 Total: $30.00\nCartStore.discount_active = True   # Enqueued \u2192 Total: $27.00\n\n# Thread-safe concurrent updates\nimport threading\nthreading.Thread(target=lambda: CartStore.item_count = 5).start()\nthreading.Thread(target=lambda: CartStore.price_per_item = 15.0).start()\n# Both enqueued; propagated sequentially; final_price sees consistent state\n\n# Cleanup\nsubscription.unsubscribe()\n\n# Boolean operators (| for OR, @ for merge)\npreview_ready = uploaded_file &amp; is_valid &amp; (~is_processing)\nany_error = validation_error | network_error  # Boolean OR\n\n# Mixed type comparisons with concurrent emissions\nsensor_stream = InfiniteObservable()\nthreshold = observable(100)\nalert_stream = sensor_stream &gt;= threshold  # InfiniteObservable&lt;bool&gt;\n\n# Thread-safe concurrent sensor updates\ndef sensor_thread():\n    for reading in sensor_readings:\n        sensor_stream &lt;&lt; reading  # Thread-safe push\n\nthreading.Thread(target=sensor_thread).start()\n\n# Watch decorator (reactive, per-emission trigger, thread-safe)\n@watch(lambda: User.age &gt;= 18, lambda: User.email.endswith('.com'))\ndef process_eligible_user():\n    print(\"Eligible user detected!\")\n# Conditions evaluated in propagation worker (safe from races)\n</code></pre>"},{"location":"specs/v1.0-roadmap/#10-edge-cases-error-handling","title":"10. Edge Cases &amp; Error Handling","text":"<p>Acceptance Criteria:</p> <p>Empty Merge:</p> <ul> <li>[ ] <code>MergedObservable()</code> with no sources raises <code>ValueError</code> with message: \u201cCannot create merge with zero sources\u201d</li> <li>[ ] <code>a @ b @ ...</code> with at least one operand succeeds</li> </ul> <p>Mixed Type Merges:</p> <ul> <li>[ ] <code>FiniteObservable @ InfiniteObservable</code> produces <code>InfiniteObservable</code> (documented in 3.5)</li> <li>[ ] Finite values emit immediately via queue, infinite values emit over time via queue</li> <li>[ ] ConditionalObservable wrapping MergedObservable preserves result type rules</li> </ul> <p>Type Mismatches:</p> <ul> <li>[ ] Merging incompatible types (e.g., <code>Observable&lt;int&gt; @ Observable&lt;str&gt;</code>) raises <code>TypeError</code></li> <li>[ ] Comparison operators require comparable types or raise <code>TypeError</code></li> </ul> <p>Null/None Handling:</p> <ul> <li>[ ] Observables can hold <code>None</code> as valid value</li> <li>[ ] Predicates/transforms receive <code>None</code></li> </ul>"}]}