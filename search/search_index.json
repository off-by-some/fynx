{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"\ud83d\udea7 Documentation Under Construction <p>Hey! You got here early! FynX is still incredibly new, so we're still ironing out the documentation here. Thanks for your patience and early interest!</p>"},{"location":"#fynx","title":"FynX","text":"<p>FynX (\"Finks\") = Functional Yielding Observable Networks</p>"},{"location":"#overview","title":"Overview","text":"<p>FynX is a lightweight reactive state management library for Python that brings the elegance of reactive programming to your applications. Inspired by MobX, FynX eliminates the complexity of manual state synchronization by automatically propagating changes through your application's data flow. When one piece of state changes, everything that depends on it updates automatically\u2014no boilerplate, no explicit update calls, just transparent reactivity.</p>"},{"location":"#installation","title":"Installation","text":"<p>Install FynX from PyPI using pip:</p> <pre><code>pip install fynx\n</code></pre> <p>FynX has no required dependencies and works with Python 3.9 and above.</p>"},{"location":"#why-use-fynx","title":"Why Use FynX?","text":"<p>Transparent Reactivity: FynX requires no special syntax. Use standard Python assignment, method calls, and attribute access\u2014reactivity works automatically without wrapper objects or proxy patterns.</p> <p>Automatic Dependency Tracking: FynX observables track their dependents automatically during execution. You never manually register or unregister dependencies; the framework infers them from how your code actually runs.</p> <p>Lazy Evaluation with Memoization: Computed values only recalculate when their dependencies change, and only when accessed. This combines the convenience of automatic updates with the performance of intelligent caching.</p> <p>Composable Architecture: Observables, computed values, and reactions compose naturally. You can nest stores, chain computed values, and combine reactions to build complex reactive systems from simple, reusable pieces.</p> <p>Expressive Operators: FynX provides intuitive operators (<code>+</code>, <code>&gt;&gt;</code>, <code>&amp;</code>, <code>~</code>, <code>|</code>) that let you compose reactive logic clearly and concisely, making your data flow explicit and easy to understand.</p>"},{"location":"#understanding-reactive-programming","title":"Understanding Reactive Programming","text":"<p>Traditional imperative programming requires you to manually orchestrate updates: when data changes, you must explicitly call update methods, refresh UI components, or invalidate caches. This creates brittle, error-prone code where it's easy to forget an update or create inconsistent states.</p> <p>Reactive programming inverts this model. Instead of imperatively triggering updates, you declare relationships between data. When a value changes, the framework automatically propagates that change to everything that depends on it. Think of it like a spreadsheet: when you change a cell, all formulas referencing that cell recalculate automatically. FynX brings this same automatic dependency tracking and update propagation to Python.</p> <p>What makes FynX special is its transparency. You don't need to learn special syntax or wrap everything in framework-specific abstractions. Just use normal Python objects and assignment\u2014FynX handles the reactivity behind the scenes through automatic dependency tracking.</p>"},{"location":"#quick-start-example","title":"Quick Start Example","text":"<p>Here's a complete example showing how FynX's concepts work together:</p> <pre><code>from fynx import Store, observable, reactive, watch\n\n# Create a reactive store grouping related state\nclass UserStore(Store):\n    name = observable(\"Alice\")\n    age = observable(30)\n    is_online = observable(False)\n\n    # Computed property that automatically updates when dependencies change\n    greeting = (name + age) &gt;&gt; (\n        lambda n, a: f\"Hello, {n}! You are {a} years old.\"\n    )\n\n# React to any change in name or age\n@reactive(UserStore.name, UserStore.age)\ndef on_user_change(name, age):\n    print(f\"User updated: {name}, {age}\")\n\n# React only when specific conditions are met\nis_adult_online = (UserStore.is_online &gt;&gt; (lambda online: online)) &amp; (UserStore.age &gt;&gt; (lambda age: age &gt;= 18))\n@reactive(is_adult_online)\ndef on_adult_online(is_adult_online_state):\n    if is_adult_online_state:\n        print(f\"Adult user {UserStore.name.value} is now online!\")\n\n# Changes trigger appropriate reactions automatically\nUserStore.name = \"Bob\"      # Prints: User updated: Bob, 30\nUserStore.age = 25          # Prints: User updated: Bob, 25\nUserStore.is_online = True  # Prints: Adult user Bob is now online!\n</code></pre> <p>Notice how natural the code looks\u2014no explicit update calls, no subscription management, just straightforward Python that happens to be reactive.</p>"},{"location":"#core-concepts","title":"Core Concepts","text":"<p>FynX's design centers on four fundamental building blocks that work together to create reactive data flows:</p>"},{"location":"#observables","title":"Observables","text":"<p>Observables are the foundation of reactivity. An observable is simply a value that FynX watches for changes. When you modify an observable, FynX automatically notifies everything that depends on it. Think of observables as the source nodes in your application's dependency graph\u2014they're the raw state that drives everything else.</p>"},{"location":"#computed-values","title":"Computed Values","text":"<p>Computed values are derived data that automatically recalculates when their dependencies change. They provide memoization by default, meaning they only recompute when one of their inputs actually changes\u2014not on every access. This makes them both convenient and performant for expensive calculations. Computed values form the intermediate nodes in your dependency graph, transforming observables into the exact shape your application needs.</p>"},{"location":"#reactions","title":"Reactions","text":"<p>Reactions are side effects that execute automatically when their observed dependencies change. Use reactions for actions like updating a UI, making an API call, logging, or any other effect that should happen in response to state changes. While observables and computed values represent your data, reactions represent what your application does with that data.</p>"},{"location":"#stores","title":"Stores","text":"<p>Stores provide organizational structure by grouping related observables, computed values, and methods together. They offer convenient patterns for subscribing to changes and managing related state as a cohesive unit. Stores aren't required, but they help you organize complex state into logical, reusable components.</p>"},{"location":"#conditional-reactions","title":"Conditional Reactions","text":"<p>Conditional reactions extend the basic reaction pattern by only executing when specific conditions are met. They're perfect for implementing state machines, validation rules, or any scenario where you need fine-grained control over when effects trigger. This allows you to express complex conditional logic declaratively rather than scattering imperative checks throughout your code.</p>"},{"location":"#common-patterns","title":"Common Patterns","text":"<p>As you work with FynX, you'll find these patterns emerge naturally:</p> <p>State Management: Group related observables in Store classes to create logical boundaries in your application. Each store becomes a self-contained module of state with its own computed values and methods.</p> <p>Derived Data: Use computed values whenever you need data that depends on other data. The automatic memoization means you can freely access computed values without worrying about performance\u2014they only recalculate when necessary.</p> <p>Side Effects: Attach reactions to observables for any effect that should happen in response to state changes: updating a UI, sending analytics, making API calls, or writing to a database.</p> <p>Conditional Logic: Use watch decorators to implement state machines, validation rules, or event filtering. This keeps conditional logic declarative and colocated with the relevant state.</p> <p>Data Flow Composition: Use FynX's operators (<code>+</code> for piping values, <code>&gt;&gt;</code> for chaining, <code>&amp;</code> for combining) to build clear, expressive data transformation pipelines.</p>"},{"location":"#documentation","title":"Documentation","text":"<ul> <li>API Reference - Complete API documentation with organized sections</li> <li>Examples - Working examples and patterns</li> <li>GitHub Repository - Source code and issues</li> </ul>"},{"location":"#contributing","title":"Contributing","text":"<p>We welcome contributions! Please visit the GitHub repository for contribution guidelines, issue tracking, and development setup instructions.</p>"},{"location":"#license","title":"License","text":"<p>FynX is released under the MIT License. See the LICENSE file for complete terms.</p>"},{"location":"mathematical/mathematical-foundations/","title":"Mathematical Foundations of FynX","text":""},{"location":"mathematical/mathematical-foundations/#introduction","title":"Introduction","text":"<p>Picture a temperature sensor in your application. Right now it reads 72\u00b0F. A moment from now, it might read 73\u00b0F. An hour from now, perhaps 68\u00b0F. This simple scenario\u2014a value that changes over time\u2014appears constantly in programming. User input changes. API responses arrive. Database queries complete. The world is full of values that vary.</p> <p>Most reactive programming libraries handle this straightforwardly enough. You create an observable, transform it a few times, connect some UI elements, and things work. Then you add another layer. Then another. Somewhere around the fifth or sixth transformation, you notice something odd. An update happens in an unexpected order. You add a <code>console.log</code> to debug it, and suddenly everything works perfectly. You remove the log. It breaks again.</p> <p>These aren't bugs in your code\u2014they're symptoms of systems without firm foundations. When the mathematics isn't right, reactive programming becomes a house of cards. Each new feature is a gamble.</p> <p>FynX takes a different path. The reactive behavior isn't just tested\u2014it's proven. When you compose observables in FynX, there's exactly one way the system can behave, and category theory proves it's the correct way. This isn't about making programming more abstract. It's about making it more reliable.</p> <p>Let's explore how.</p>"},{"location":"mathematical/mathematical-foundations/#observables-as-functors","title":"Observables as Functors","text":""},{"location":"mathematical/mathematical-foundations/#a-value-that-changes","title":"A Value That Changes","text":"<p>Consider that temperature sensor again. Mathematically, we can think of it as a function from time to temperatures:</p> \\[\\mathcal{T} \\to \\text{Temperature}\\] <p>At time \\(t_1\\), it returns 72\u00b0F. At time \\(t_2\\), it returns 73\u00b0F. The sensor isn't storing a single value\u2014it's representing an entire temporal function.</p> <p>Now suppose you have a function that converts Celsius to Fahrenheit. It's a simple function on ordinary numbers:</p> <pre><code>def celsius_to_fahrenheit(c: float) -&gt; float:\n    return c * 9/5 + 32\n</code></pre> <p>But your sensor is an observable, not a number. What does it mean to apply this function to something that varies over time? The answer turns out to be elegant: you lift the function to work on the entire temporal function at once.</p> <pre><code>temp_c: Observable[float] = observable(20.0)\ntemp_f: Observable[float] = temp_c &gt;&gt; celsius_to_fahrenheit\n</code></pre> <p>The <code>&gt;&gt;</code> operator performs this lifting automatically. Give it a function on values, and it produces a function on observables. Whenever <code>temp_c</code> changes, <code>temp_f</code> updates accordingly, always maintaining the conversion relationship.</p>"},{"location":"mathematical/mathematical-foundations/#the-structure-beneath","title":"The Structure Beneath","text":"<p>This lifting operation isn't arbitrary. It has mathematical structure\u2014specifically, it defines what category theorists call a functor. The functor \\(\\mathcal{O}\\) takes types to observable types:</p> \\[\\mathcal{O}: \\mathbf{Type} \\to \\mathbf{Type}\\] <p>And it takes functions between types to lifted functions between observable types. But there's more. For this to be a proper functor, certain laws must hold.</p> <p>The first law says: if you lift the identity function (which does nothing), you get the identity on observables (which also does nothing):</p> \\[\\mathcal{O}(\\text{id}_A) = \\text{id}_{\\mathcal{O}(A)}\\] <p>In code: <code>obs &gt;&gt; (lambda x: x)</code> behaves exactly like <code>obs</code>. This seems obvious, but it's actually a strong constraint. It means lifting can't introduce side effects. It can't change timing. It must be transparent.</p> <p>The second law is more interesting. If you have two functions \\(f\\) and \\(g\\), then composing them first and then lifting should give the same result as lifting each separately and then composing:</p> \\[\\mathcal{O}(g \\circ f) = \\mathcal{O}(g) \\circ \\mathcal{O}(f)\\] <p>What this means in practice is beautiful: these two expressions are mathematically equivalent:</p> <pre><code>result = obs &gt;&gt; (lambda x: g(f(x)))\nresult = obs &gt;&gt; f &gt;&gt; g\n</code></pre> <p>You can split function chains or merge them freely. The order of operations is preserved exactly. There's no hidden complexity. The functor law guarantees they mean the same thing.</p>"},{"location":"mathematical/mathematical-foundations/#why-this-matters","title":"Why This Matters","text":"<p>Here's where theory meets practice in an unexpected way. Because the composition law holds, FynX can optimize your code automatically. When you write:</p> <pre><code>obs &gt;&gt; f &gt;&gt; g &gt;&gt; h\n</code></pre> <p>FynX can internally transform this into:</p> <pre><code>obs &gt;&gt; (lambda x: h(g(f(x))))\n</code></pre> <p>This isn't a risky optimization that might change behavior. The composition law proves it's safe. The mathematics tells us exactly which rewrites preserve semantics.</p> <p>This is why FynX stays efficient even with transformation chains thousands of levels deep. They're not actually thousands of separate observables\u2014they're fused into single operations, and the functor structure guarantees this fusion is valid.</p> <p>The elegance here is worth pausing to appreciate. You write code naturally, chaining transformations as makes sense to you. The mathematical structure beneath ensures both correctness and performance follow automatically.</p>"},{"location":"mathematical/mathematical-foundations/#products-combining-independent-values","title":"Products: Combining Independent Values","text":""},{"location":"mathematical/mathematical-foundations/#when-two-become-one","title":"When Two Become One","text":"<p>Consider a simple scenario: you're building a form with first name and last name fields. Each field is independent\u2014users can type into either one at any time. But at some point, you need both values together. Maybe to display a full name. Maybe to validate that both fields are filled. Maybe to submit them to a server.</p> <p>You want to combine two separate time-varying values into a single time-varying pair:</p> <pre><code>first_name: Observable[str] = observable(\"Jane\")\nlast_name: Observable[str] = observable(\"Doe\")\n\nfull_name_data: Observable[tuple[str, str]] = first_name + last_name\n</code></pre> <p>The <code>+</code> operator creates this combination. But what exactly has happened here? Category theory gives us a precise answer: we've constructed a product.</p> <p>The product satisfies an elegant isomorphism:</p> \\[\\mathcal{O}(A) \\times \\mathcal{O}(B) \\cong \\mathcal{O}(A \\times B)\\] <p>This says that combining two observables produces an observable of pairs, and these two perspectives\u2014\"two observables\" versus \"one observable of pairs\"\u2014are mathematically equivalent. The \\(\\cong\\) symbol means there's a natural way to go between them, and these translations are inverses.</p>"},{"location":"mathematical/mathematical-foundations/#the-universal-property","title":"The Universal Property","text":"<p>Products come with something called a universal property. The term sounds abstract, but the idea is practical: the product is the \"most general\" way to capture \"both A and B together.\"</p> <p>Formally, if you have any way of using two observables together, that usage factors uniquely through their product. This means you can't have two different approaches to combining the same observables that behave differently. The product captures the unique correct way.</p> <p>In practice, this manifests in a useful way. Consider:</p> <pre><code>product = first_name + last_name\n\nfull_name = product &gt;&gt; (lambda t: f\"{t[0]} {t[1]}\")\ninitials = product &gt;&gt; (lambda t: f\"{t[0][0]}.{t[1][0]}.\")\ndisplay = product &gt;&gt; (lambda t: f\"{t[1]}, {t[0]}\")\n</code></pre> <p>All three computations need both names. The universal property proves they're all talking about the same product. FynX computes <code>first_name + last_name</code> once, not three times. The optimizer can safely share this computation because the mathematics guarantees all three uses refer to the same mathematical object.</p>"},{"location":"mathematical/mathematical-foundations/#symmetry-and-associativity","title":"Symmetry and Associativity","text":"<p>Products have nice algebraic properties. They're symmetric\u2014order doesn't affect the structure:</p> <pre><code>ab = first_name + last_name    # Observable[tuple[str, str]]\nba = last_name + first_name    # Observable[tuple[str, str]]\n</code></pre> <p>These are isomorphic. Same information, different tuple order. The structure is preserved.</p> <p>They're also associative\u2014grouping doesn't matter:</p> <pre><code>city = observable(\"New York\")\n\nleft = (first_name + last_name) + city\nright = first_name + (last_name + city)\n</code></pre> <p>The nesting differs, but structurally, all three observables are combined correctly. Changes to any propagate through as expected.</p> <p>These properties aren't just mathematical curiosities. They tell the optimizer it can rearrange products safely, share common subproducts, and factor computations in whatever way is most efficient.</p>"},{"location":"mathematical/mathematical-foundations/#pullbacks-the-mathematics-of-filtering","title":"Pullbacks: The Mathematics of Filtering","text":""},{"location":"mathematical/mathematical-foundations/#starting-with-code","title":"Starting with Code","text":"<p>Suppose you're building a data dashboard. You have a stream of sensor readings, but you only want to display readings that meet certain quality criteria:</p> <pre><code>sensor_reading: Observable[float] = observable(42.5)\n\n# Define quality conditions\nis_in_range = sensor_reading &gt;&gt; (lambda x: 0 &lt;= x &lt;= 100)\nis_stable = sensor_reading &gt;&gt; (lambda x: abs(x - x) &lt; 5)  # simplified\nhas_signal = sensor_reading &gt;&gt; (lambda x: x is not None)\n\n# Only show readings that pass all quality checks\nvalid_reading = sensor_reading &amp; is_in_range &amp; is_stable &amp; has_signal\n</code></pre> <p>The <code>valid_reading</code> observable only has a value when all three conditions are satisfied. Set <code>sensor_reading</code> to 42.5, and if all checks pass, <code>valid_reading</code> emits 42.5. Set it to 150, and <code>valid_reading</code> goes silent\u2014it's no longer active because the range check fails.</p> <p>This pattern appears everywhere in reactive systems: - A \"Submit\" button that's only enabled when a form is valid - ETL pipelines that only process records matching data quality rules - Real-time dashboards that filter out anomalous data points - Shopping carts that only apply discounts when eligibility conditions are met</p> <p>Let's understand what's happening here through an analogy, then see the mathematical structure underneath.</p>"},{"location":"mathematical/mathematical-foundations/#the-airport-security-analogy","title":"The Airport Security Analogy","text":"<p>Think of it like airport security. Your data stream is passengers trying to board a flight. Each condition is a checkpoint:</p> <pre><code>Passenger Data\n     \u2193\n[Passport Control] \u2190 is_in_range check\n     \u2193\n[Security Screening] \u2190 is_stable check\n     \u2193\n[Boarding Pass Validation] \u2190 has_signal check\n     \u2193\n   Gate\n     \u2193\n  Flight (valid_reading)\n</code></pre> <p>Only passengers who pass all checkpoints make it to the gate. If you fail at any checkpoint, you don't continue. The gate only opens when all checkpoints have been cleared.</p> <p>When you write <code>data &amp; condition1 &amp; condition2</code>, you're building this chain of checkpoints. The conditional observable is the gate at the end\u2014it only opens when all conditions are satisfied.</p> <pre><code>sensor_reading.set(42.5)  # All conditions pass \u2192 gate opens\nsensor_reading.set(150)   # Fails range check \u2192 gate closes\nsensor_reading.set(-10)   # Fails range check \u2192 gate stays closed\nsensor_reading.set(55.0)  # All conditions pass \u2192 gate opens again\n</code></pre>"},{"location":"mathematical/mathematical-foundations/#more-practical-examples","title":"More Practical Examples","text":"<p>Example 1: Streamlit Dashboard with Live Filtering</p> <pre><code># User controls\nselected_category = observable(\"Electronics\")\nmin_price = observable(0.0)\nmax_price = observable(1000.0)\nin_stock_only = observable(True)\n\n# Product stream from database\nproducts = observable([...])\n\n# Conditions for filtering\nmatches_category = products &gt;&gt; (lambda p: p.category == selected_category.value)\nwithin_budget = products &gt;&gt; (lambda p: min_price.value &lt;= p.price &lt;= max_price.value)\nis_available = products &gt;&gt; (lambda p: not in_stock_only.value or p.stock &gt; 0)\n\n# Only show products meeting all criteria\nfiltered_products = products &amp; matches_category &amp; within_budget &amp; is_available\n\n# Dashboard automatically updates as users adjust filters\ndisplay(filtered_products)\n</code></pre> <p>As users move sliders or toggle checkboxes, <code>filtered_products</code> reactively updates\u2014showing only items that pass all active filters. The conditional observable handles state transitions automatically.</p> <p>Example 2: ETL Pipeline with Data Quality Gates</p> <pre><code># Raw data ingestion\nraw_records = observable(None)\n\n# Data quality conditions\nhas_required_fields = raw_records &gt;&gt; (lambda r: all(k in r for k in ['id', 'timestamp', 'value']))\ntimestamp_valid = raw_records &gt;&gt; (lambda r: r['timestamp'] &gt; last_processed_time)\nvalue_in_bounds = raw_records &gt;&gt; (lambda r: -1000 &lt;= r['value'] &lt;= 1000)\nno_duplicates = raw_records &gt;&gt; (lambda r: r['id'] not in processed_ids)\n\n# Only process records that pass quality gates\nprocessable_records = raw_records &amp; has_required_fields &amp; timestamp_valid &amp; value_in_bounds &amp; no_duplicates\n\n# Transform only valid records\ntransformed = processable_records &gt;&gt; transform_logic\n</code></pre> <p>The ETL pipeline automatically filters out malformed, duplicate, or out-of-bounds records. Each record either passes all quality gates and gets processed, or fails at least one gate and gets routed to error handling.</p> <p>Example 3: Form Validation State Machine</p> <pre><code># Form fields\nusername = observable(\"\")\nemail = observable(\"\")\npassword = observable(\"\")\nage = observable(0)\n\n# Validation conditions\nusername_valid = username &gt;&gt; (lambda u: len(u) &gt;= 3 and u.isalnum())\nemail_valid = email &gt;&gt; (lambda e: \"@\" in e and \".\" in e.split(\"@\")[-1])\npassword_strong = password &gt;&gt; (lambda p: len(p) &gt;= 8 and any(c.isupper() for c in p))\nage_appropriate = age &gt;&gt; (lambda a: 13 &lt;= a &lt;= 120)\n\n# Form only submittable when all validations pass\ncan_submit = username &amp; username_valid &amp; email_valid &amp; password_strong &amp; age_appropriate\n\n# Button state automatically reflects validation\nsubmit_button.enabled = can_submit.is_active\n</code></pre> <p>The form exists in one of two states: submittable (all validations pass) or not submittable (at least one validation fails). The conditional observable tracks this state automatically, and UI components bind directly to it.</p>"},{"location":"mathematical/mathematical-foundations/#the-categorical-structure","title":"The Categorical Structure","text":"<p>Now let's see the mathematical structure that makes this work. The pattern we've been using corresponds to what category theorists call a pullback.</p> <p>In general, a pullback is the limit of a cospan diagram. Given two morphisms pointing to a common object:</p> <pre><code>    X ---f--\u2192 Z \u2190--g--- Y\n</code></pre> <p>The pullback is a new object (often written \\(X \\times_Z Y\\)) along with projections making this diagram commute:</p> <pre><code>    X \u00d7_Z Y ----\u2192 Y\n       +          +\n       +          + g\n       \u2193          \u2193\n       X ---f--\u2192  Z\n</code></pre> <p>The pullback consists of pairs \\((x, y)\\) where \\(f(x) = g(y)\\)\u2014elements that \"agree\" when mapped to the common codomain.</p> <p>FynX applies this construction in a specialized way. Each condition is a function from the source observable to booleans:</p> <pre><code>Source Observable ---c_i--\u2192 Observable[Bool]\n</code></pre> <p>We're interested in values where all conditions map to <code>True</code>. Visually, for a single condition:</p> <pre><code>    ConditionalObservable ----\u2192 {True}\n            +                      +\n            + \u03c0                    +\n            \u2193                      \u2193\n    Source Observable ---c--\u2192 Observable[Bool]\n</code></pre> <p>This is a pullback along the morphism selecting <code>True</code> from the boolean domain. The conditional observable is the fiber over <code>True</code>\u2014the subset of source values where the condition holds.</p> <p>For multiple conditions, we're taking the intersection of multiple such fibers:</p> \\[\\text{ConditionalObservable}(s, c_1, \\ldots, c_n) \\cong \\{ x \\in s \\mid c_1(x) \\wedge c_2(x) \\wedge \\cdots \\wedge c_n(x) \\}\\] <p>Each condition creates a checkpoint. The conditional observable represents values that clear all checkpoints\u2014the pullback ensures this subset is well-defined categorically.</p>"},{"location":"mathematical/mathematical-foundations/#special-properties","title":"Special Properties","text":"<p>Here's something interesting. General pullbacks in category theory don't necessarily commute or associate. But FynX's pullbacks do, and there's a specific reason why.</p> <p>All our conditions map to the same codomain (\\(\\mathbb{B}\\)). They all filter to the same fiber (<code>True</code>). And logical AND is both commutative and associative. These structural properties of Boolean algebra transfer to our pullback construction:</p> <p>Commutativity: The order of conditions doesn't matter: \\(\\(\\text{data} \\&amp; c_1 \\&amp; c_2 \\equiv \\text{data} \\&amp; c_2 \\&amp; c_1\\)\\)</p> <p>Associativity: Grouping doesn't matter: \\(\\((\\text{data} \\&amp; c_1) \\&amp; c_2 \\equiv \\text{data} \\&amp; (c_1 \\&amp; c_2)\\)\\)</p> <p>This is specific to how FynX constructs pullbacks. In the general category-theoretic setting, these properties don't always hold. But in our Boolean filtering context, they do, and this enables useful optimizations.</p>"},{"location":"mathematical/mathematical-foundations/#states-and-transitions","title":"States and Transitions","text":"<p>A conditional observable exists in one of three states. It might have never been active\u2014conditions have never been satisfied. It might be currently active\u2014all conditions are satisfied right now. Or it might be inactive\u2014conditions were satisfied before, but aren't currently.</p> <p>The implementation respects these states precisely:</p> <pre><code>@property\ndef value(self):\n    if self.is_active:\n        return self._value\n    elif self._has_ever_had_valid_value:\n        raise ConditionalNotMet(\"Conditions not currently satisfied\")\n    else:\n        raise ConditionalNeverMet(\"Conditions never satisfied\")\n</code></pre> <p>You can only access the value when you're in the fiber\u2014when all conditions hold. This isn't just good error handling. It's implementing the mathematical structure correctly.</p>"},{"location":"mathematical/mathematical-foundations/#optimization-through-structure","title":"Optimization Through Structure","text":"<p>Because our conditional pullbacks commute and associate, FynX can fuse them:</p> \\[\\text{obs} \\&amp; c_1 \\&amp; c_2 \\&amp; c_3 \\equiv \\text{obs} \\&amp; (c_1 \\wedge c_2 \\wedge c_3)\\] <p>Instead of three separate conditional observables checking conditions in sequence, the optimizer creates one conditional with a combined predicate. This isn't changing semantics\u2014the pullback structure proves these are equivalent. But checking one combined condition is faster than chaining through multiple conditionals.</p> <p>The mathematics doesn't just ensure correctness. It reveals where optimizations are valid.</p>"},{"location":"mathematical/mathematical-foundations/#composition-building-complex-systems","title":"Composition: Building Complex Systems","text":""},{"location":"mathematical/mathematical-foundations/#combining-the-pieces","title":"Combining the Pieces","text":"<p>The real power emerges when you compose these structures together. Consider form validation\u2014a common pattern where correctness matters:</p> <pre><code>email = observable(\"\")\npassword = observable(\"\")\nconfirmation = observable(\"\")\nterms_accepted = observable(False)\n\n# Functors: lift validation functions\nis_valid_email = email &gt;&gt; (lambda e: \"@\" in e and \".\" in e)\nis_strong_password = password &gt;&gt; (lambda p: len(p) &gt;= 8)\n\n# Product: combine related fields\npasswords_match = (password + confirmation) &gt;&gt; (lambda pc: pc[0] == pc[1])\n\n# Pullback: form is valid only when all conditions hold\nform_valid = email &amp; is_valid_email &amp; is_strong_password &amp; passwords_match &amp; terms_accepted\n\n# Functor: create submission payload when valid\nsubmission = form_valid &gt;&gt; (lambda e: {\n    \"email\": email.value,\n    \"password\": password.value\n})\n</code></pre> <p>This pipeline has multiple source observables, derived validations, a product combining related fields, a pullback filtering to valid states, and a final transformation. Each piece uses one of the structures we've discussed.</p> <p>The composition works correctly because each structure has precise semantics. Functors transform values predictably. Products combine observables in a well-defined way. Pullbacks filter with exact conditions. And the universal properties guarantee these pieces fit together uniquely.</p>"},{"location":"mathematical/mathematical-foundations/#the-categorical-guarantee","title":"The Categorical Guarantee","text":"<p>When you write complex reactive graphs like this, you're not hoping the library handles edge cases correctly. The categorical structure proves it must. Functoriality ensures transformations compose without surprises. Products combine values in the unique correct way. Pullbacks filter with precise state transitions. Universal properties prove there's only one valid way these pieces can interact.</p> <p>This is what mathematical foundations really provide\u2014not abstraction for its own sake, but constraints that force implementations to be correct.</p>"},{"location":"mathematical/mathematical-foundations/#the-optimizer-category-theory-as-compiler","title":"The Optimizer: Category Theory as Compiler","text":""},{"location":"mathematical/mathematical-foundations/#automatic-optimization","title":"Automatic Optimization","text":"<p>FynX achieves strong performance\u2014353,000+ state updates per second, dependency chains 2,776 levels deep, 47,000+ components updating efficiently\u2014all in pure Python. This performance comes from automatic optimization guided by the mathematical structures we've explored.</p> <p>The optimizer applies four types of rewrites, each justified by category theory.</p>"},{"location":"mathematical/mathematical-foundations/#functor-composition-fusion","title":"Functor Composition Fusion","text":"<p>The composition law proves that sequential transformations can safely fuse:</p> \\[\\text{obs} \\gg f \\gg g \\gg h \\rightarrow \\text{obs} \\gg (h \\circ g \\circ f)\\] <p>Instead of creating intermediate observables for each <code>&gt;&gt;</code>, FynX fuses the entire chain into a single computed observable. This is why deep chains stay efficient\u2014they're not actually thousands of separate observables, just composed functions in one observable.</p> <p>The functor laws don't just allow this optimization\u2014they prove it's semantics-preserving.</p>"},{"location":"mathematical/mathematical-foundations/#product-factorization","title":"Product Factorization","text":"<p>The universal property of products proves that multiple computations needing the same product can share it:</p> <pre><code># User writes:\nresult1 = (a + b) &gt;&gt; f\nresult2 = (a + b) &gt;&gt; g\nresult3 = (a + b) &gt;&gt; h\n\n# Optimizer produces:\nproduct = a + b\nresult1 = product &gt;&gt; f\nresult2 = product &gt;&gt; g\nresult3 = product &gt;&gt; h\n</code></pre> <p>The product is computed once. When 47,000 components depend on a single product, they all reference the same computation. The universal property proves this factorization is valid.</p>"},{"location":"mathematical/mathematical-foundations/#pullback-fusion","title":"Pullback Fusion","text":"<p>The commutativity and associativity of Boolean pullbacks allow combining sequential filters:</p> \\[\\text{obs} \\&amp; c_1 \\&amp; c_2 \\&amp; c_3 \\rightarrow \\text{obs} \\&amp; (c_1 \\wedge c_2 \\wedge c_3)\\] <p>Multiple conditional checks become one. The algebraic structure proves this fusion preserves semantics.</p>"},{"location":"mathematical/mathematical-foundations/#cost-based-materialization","title":"Cost-Based Materialization","text":"<p>The optimizer decides whether to cache or recompute each node using a cost model:</p> \\[C(\\sigma) = \\alpha \\cdot +\\text{Dep}(\\sigma)+ + \\beta \\cdot \\mathbb{E}[\\text{Updates}(\\sigma)] + \\gamma \\cdot \\text{depth}(\\sigma)\\] <p>This cost functional has important mathematical structure. It's a monoidal functor from the reactive category to the ordered monoid \\((\\mathbb{R}^+, +, 0)\\). This means:</p> <p>\\(C(g \\circ f) \\leq C(g) + C(f)\\)</p> <p>Cost flows from sources to dependents through the graph structure. When we compute a node's cost, we're summing its local computation cost with the costs flowing from its dependencies. This monoidal composition ensures that optimization decisions compose correctly\u2014choosing the minimal-cost materialization strategy at each node yields a globally optimal strategy.</p> <p>The optimizer handles two types of costs:</p> <p>Monoidal cost: Flows through the category following composition laws. For a computed node, this is either the memory cost of materialization (\\(\\alpha\\)) or the recomputation cost (\\(\\beta \\cdot \\text{frequency} \\cdot \\text{computation\\_cost}\\)).</p> <p>Sharing penalty: Accounts for redundant computation when a non-materialized node has multiple dependents. This breaks the monoidal structure slightly but captures the real cost of sharing in practice.</p> <p>For frequently-accessed or deep nodes, caching wins. For cheap or rarely-accessed nodes, recomputation wins.</p>"},{"location":"mathematical/mathematical-foundations/#why-optimization-is-sound","title":"Why Optimization is Sound","text":"<p>These aren't heuristics discovered through profiling. Each rewrite is justified by category theory. Composition collapse follows from functor laws. Product factorization follows from universal properties. Pullback fusion follows from Boolean algebra structure. Materialization follows from monoidal cost composition.</p> <p>The optimizer can be aggressive because the mathematics proves when rewrites preserve semantics. This is optimization guided by proof.</p>"},{"location":"mathematical/mathematical-foundations/#dependency-graphs-and-update-order","title":"Dependency Graphs and Update Order","text":""},{"location":"mathematical/mathematical-foundations/#the-hidden-dag","title":"The Hidden DAG","text":"<p>Behind every FynX program is a directed acyclic graph. Nodes are observables. Edges represent dependencies\u2014if B depends on A, there's an edge from A to B.</p> <p>This graph structure is fundamental to how reactivity works. When A changes, everything reachable from A through outgoing edges needs to update. The acyclic property is crucial\u2014if the graph had cycles, you'd have circular dependencies, and the system couldn't compute a stable state.</p> <p>FynX detects cycles at runtime:</p> <pre><code>if current_context and self in current_context.dependencies:\n    raise RuntimeError(\"Circular dependency detected!\")\n</code></pre>"},{"location":"mathematical/mathematical-foundations/#topological-order","title":"Topological Order","text":"<p>When multiple observables change, the update order matters profoundly. Consider:</p> <pre><code>a = observable(1)\nb = a &gt;&gt; (lambda x: x * 2)\nc = b &gt;&gt; (lambda x: x + 10)\n</code></pre> <p>If <code>a</code> changes to 5, both <code>b</code> and <code>c</code> need updating. But <code>c</code> depends on <code>b</code>, so we must update <code>b</code> first. Otherwise <code>c</code> would read a stale value and compute incorrectly.</p> <p>FynX processes updates in topological order\u2014dependencies before dependents:</p> <pre><code>def _topological_sort_notifications(cls, observables):\n    sources = []      # No dependencies\n    computed = []     # Depend on sources\n    conditionals = [] # Depend on others\n    return sources + computed + conditionals\n</code></pre> <p>This ensures that when an observable evaluates, all its dependencies have already been updated. It's not an optimization\u2014it's a correctness requirement.</p>"},{"location":"mathematical/mathematical-foundations/#batched-processing","title":"Batched Processing","text":"<p>FynX batches notifications for efficiency. When multiple observables change in quick succession, all changes are collected, sorted topologically, and processed in one sweep:</p> <pre><code>_pending_notifications: Set[\"Observable\"] = set()\n\ndef set(self, value):\n    if self._value != value:\n        self._value = value\n        Observable._pending_notifications.add(self)\n        if not Observable._notification_scheduled:\n            Observable._notification_scheduled = True\n            Observable._process_notifications()\n</code></pre> <p>This batching provides two benefits: each observable updates once per batch rather than once per dependency change, and all dependents see a consistent snapshot of their dependencies.</p>"},{"location":"mathematical/mathematical-foundations/#performance-in-practice","title":"Performance in Practice","text":""},{"location":"mathematical/mathematical-foundations/#the-numbers","title":"The Numbers","text":"<p>FynX's benchmark suite measures fundamental operations:</p> <ul> <li>Observable creation: 794,000 ops/sec</li> <li>Individual updates: 353,000 ops/sec</li> <li>Chain propagation: 1,640 ops/sec for 2,776-link chains</li> <li>Reactive fan-out: 47,000 ops/sec with 47,427 dependent components</li> </ul> <p>Average latencies are sub-microsecond for individual updates, 609 microseconds per dependency link in complex chains.</p>"},{"location":"mathematical/mathematical-foundations/#scaling-properties","title":"Scaling Properties","text":"<p>The categorical structure provides specific scaling characteristics:</p> <p>Linear in dependencies: Each dependency adds constant cost, as it must.</p> <p>Sublinear in depth: Fusion keeps deep chains efficient. A 1,000-level chain may fuse into a single operation, giving logarithmic rather than linear behavior in practice.</p> <p>Constant in fan-out: Product sharing makes fan-out nearly independent of dependent count. The product is computed once whether 10 or 10,000 components use it.</p> <p>Batched amortization: Multiple changes in a batch share topological sorting costs, so amortized cost per change decreases as batches grow.</p> <p>These properties follow from the categorical structure. The theory predicts how performance scales.</p>"},{"location":"mathematical/mathematical-foundations/#related-work-and-context","title":"Related Work and Context","text":"<p>FynX builds on established concepts in functional reactive programming and category theory. Functors appear prominently in languages like Haskell and libraries like Scala Cats. Product types are fundamental to type theory. Pullbacks have been applied to constraint systems and relational databases.</p> <p>FynX's contribution is applying these structures specifically to reactive observables in Python, with automatic optimization guided by categorical properties. The mathematical foundation isn't novel, but its application to this domain and language is distinctive.</p>"},{"location":"mathematical/mathematical-foundations/#conclusion","title":"Conclusion","text":"<p>We've explored how category theory provides foundations for reactive programming\u2014not as abstract theory, but as practical structure. Functors ensure transformations compose predictably. Products combine observables in a principled way. Pullbacks filter with precise semantics. And these same structures that guarantee correctness reveal optimization opportunities.</p> <p>The mathematical foundations serve three purposes: they prove compositions work correctly, they show where optimizations preserve semantics, and they enable natural composition of observables.</p> <p>Understanding these foundations isn't required to use FynX effectively. The <code>&gt;&gt;</code>, <code>+</code>, and <code>&amp;</code> operators work intuitively without knowing category theory. But the mathematics explains why the library behaves as it does, why certain design decisions were made, and why optimizations are valid.</p> <p>Category theory transforms reactive programming from a collection of patterns into a structured system with provable properties. The elegance is that complexity becomes composability. Theory becomes tool. And mathematics guides engineering toward correctness.</p>"},{"location":"reference/api/","title":"API Reference","text":"<p>This reference provides comprehensive documentation of FynX's public API. FynX is a reactive programming library that makes your application state respond automatically to changes\u2014think of it as a spreadsheet for your code, where updating one cell automatically recalculates all the formulas that depend on it.</p>"},{"location":"reference/api/#a-mental-model-for-fynx","title":"A Mental Model for FynX","text":"<p>Before diving into the API details, it helps to understand FynX's core philosophy:</p> <p>Traditional programming is imperative: You tell your code exactly when to update things. Change a variable here, update the UI there, recalculate this value over there. You're responsible for remembering all the connections.</p> <p>FynX is declarative: You describe relationships between values, and FynX handles the updates automatically. Change a value once, and everything that depends on it updates correctly, in the right order, every time.</p> <p>This mental shift\u2014from managing updates to declaring relationships\u2014is what makes thinking reactively so powerful.</p>"},{"location":"reference/api/#your-learning-path","title":"Your Learning Path","text":"<p>FynX's API is designed to be learned progressively, with each concept building on the previous one:</p> <ol> <li>Start with Observables \u2014 Learn to create reactive values that notify subscribers when they change</li> <li>Organize with Stores \u2014 Group related observables into cohesive units with clean APIs</li> <li>Filter Conditionally \u2014 Control when reactions occur based on runtime conditions</li> <li>Automate with Decorators \u2014 Eliminate boilerplate and express reactive relationships declaratively</li> </ol> <p>Each section in this reference assumes you understand the previous sections. If you encounter an unfamiliar concept, backtrack to the earlier pages.</p>"},{"location":"reference/api/#core-concepts","title":"Core Concepts","text":""},{"location":"reference/api/#observables-reactive-values","title":"Observables: Reactive Values","text":"<p>Observables are containers for values that change over time. Unlike regular variables, they automatically notify anyone who's interested when their values change.</p> <p>Observable \u2014 The foundation of FynX. Create observables with <code>observable(initial_value)</code>, read them with <code>.value</code>, write them with <code>.set(new_value)</code>. Every other FynX feature builds on this simple primitive.</p> <p>ComputedObservable \u2014 Values that automatically recalculate when their dependencies change. Create them with the <code>&gt;&gt;</code> operator: <code>full_name = (first + last) &gt;&gt; (lambda f, l: f\"{f} {l}\")</code>. The <code>&gt;&gt;</code> operator transforms observables through functions, creating a new computed observable. Alternatively, use the <code>.then(func)</code> method on observables for the same result. FynX tracks dependencies automatically and ensures computed values always stay up-to-date.</p> <p>MergedObservable \u2014 Combine multiple observables into a single reactive tuple using the <code>+</code> operator: <code>position = x + y + z</code>. When any source changes, subscribers receive all values as a tuple. This is the foundation for reactive relationships that depend on multiple values.</p> <p>ConditionalObservable \u2014 Observables that emit when conditions are satisfied. Create them with the <code>&amp;</code> operator: <code>valid_submission = form_data &amp; is_valid</code>. This enables sophisticated reactive logic without cluttering your code with conditional checks.</p> <p>Observable Descriptors \u2014 The mechanism behind Store class attributes. When you write <code>name = observable(\"Alice\")</code> in a Store class, you're creating a descriptor that provides clean property access without <code>.value</code> or <code>.set()</code>.</p> <p>Observable Operators \u2014 The operators (<code>+</code>, <code>&gt;&gt;</code>, <code>&amp;</code>, <code>~</code>) and methods (<code>.then()</code>, <code>.requiring()</code>) that let you compose observables into reactive pipelines. The <code>&gt;&gt;</code> operator is the primary way to transform observables, passing values through functions. Understanding these operators unlocks FynX's full expressive power.</p>"},{"location":"reference/api/#stores-organizing-state","title":"Stores: Organizing State","text":"<p>While standalone observables are useful for small scripts, real applications need structure. Stores group related observables and computed values into cohesive units.</p> <p>Store &amp; @observable \u2014 Create Store classes that encapsulate related state. Use <code>@observable</code> to make class attributes reactive, or use <code>observable()</code> as a class attribute descriptor. This gives you clean property access: <code>UserStore.name = \"Alice\"</code> instead of <code>user_name.set(\"Alice\")</code>. Stores are where FynX really shines in application development.</p>"},{"location":"reference/api/#decorators-declarative-reactions","title":"Decorators: Declarative Reactions","text":"<p>Decorators let you declare what should happen when observables change, without manually managing subscriptions.</p> <p>@reactive \u2014 Run functions automatically when dependencies change. This is how you implement side effects\u2014logging, UI updates, API calls\u2014that should happen in response to state changes. The function runs immediately and again whenever any observable it reads changes. Use with conditional observables for event-driven reactions: <code>@reactive(condition &amp; other_condition)</code>.</p>"},{"location":"reference/api/#api-quick-reference","title":"API Quick Reference","text":""},{"location":"reference/api/#creating-reactive-state","title":"Creating Reactive State","text":"<pre><code>from fynx import observable, Store\n\n# Standalone observables\ncount = observable(0)\nname = observable(\"Alice\")\n\n# Store-based observables\nclass AppStore(Store):\n    count = observable(0)\n    name = observable(\"Alice\")\n</code></pre>"},{"location":"reference/api/#reading-and-writing","title":"Reading and Writing","text":"<pre><code># Standalone observables\ncurrent = count.value          # Read\ncount.set(current + 1)         # Write\n\n# Store observables\ncurrent = AppStore.count       # Read\nAppStore.count = current + 1   # Write\n</code></pre>"},{"location":"reference/api/#deriving-values","title":"Deriving Values","text":"<pre><code># Using the &gt;&gt; operator (recommended)\ndoubled = count &gt;&gt; (lambda c: c * 2)\nfull_name = (first + last) &gt;&gt; (lambda f, l: f\"{f} {l}\")\n\n# Using .then() method (alternative syntax)\ndoubled = count.then(lambda c: c * 2)\nfull_name = (first + last).then(lambda f, l: f\"{f} {l}\")\n</code></pre>"},{"location":"reference/api/#reacting-to-changes","title":"Reacting to Changes","text":"<pre><code># Manual subscription\ncount.subscribe(lambda val: print(f\"Count: {val}\"))\n\n# Using @reactive decorator\n@reactive(count)\ndef log_count(val):\n    print(f\"Count: {val}\")\n\n# Using @reactive with conditional observables for event-driven reactions\nis_above_threshold = count &gt;&gt; (lambda c: c &gt; 10)\n@reactive(is_above_threshold)\ndef on_threshold(is_above):\n    if is_above:\n        print(\"Count exceeded 10!\")\n</code></pre>"},{"location":"reference/api/#composing-observables","title":"Composing Observables","text":"<pre><code># Merge multiple sources\nposition = x + y + z\n\n# Transform values with &gt;&gt; operator\ndoubled = count &gt;&gt; (lambda c: c * 2)\n\n# Or use .then() method\ndoubled = count.then(lambda c: c * 2)\n\n# Filter conditionally\nshould_save = has_changes &amp; is_valid\n\n# Negate conditions\nis_idle = ~is_busy\n</code></pre>"},{"location":"reference/api/#complete-example-putting-it-all-together","title":"Complete Example: Putting It All Together","text":"<p>Here's how these concepts work together in a realistic scenario:</p> <pre><code>from fynx import Store, observable, reactive\n\nclass ShoppingCartStore(Store):\n    # Basic reactive state\n    items = observable([])\n    discount_code = observable(None)\n\n# Computed values using &gt;&gt; operator\nsubtotal = ShoppingCartStore.items &gt;&gt; (\n    lambda items: sum(item['price'] * item['quantity'] for item in items)\n)\n\ndiscount_amount = (ShoppingCartStore.items + ShoppingCartStore.discount_code) &gt;&gt; (\n    lambda items, code: sum(item['price'] * item['quantity'] for item in items) * 0.20\n    if code == \"SAVE20\" else 0.0\n)\n\ntotal = (subtotal + discount_amount) &gt;&gt; (\n    lambda sub, disc: sub - disc\n)\n\n# Conditional observable for checkout eligibility\nhas_items = ShoppingCartStore.items &gt;&gt; (lambda i: len(i) &gt; 0)\ntotal_positive = total &gt;&gt; (lambda t: t &gt; 0)\ncan_checkout = has_items &amp; total_positive\n\n# React to changes automatically\n@reactive(total)\ndef update_ui_total(t):\n    print(f\"\ud83d\udcb0 New total: ${t:.2f}\")\n\n# React to checkout eligibility using conditional observables\n@reactive(can_checkout)\ndef enable_checkout_button(can_checkout_val):\n    if can_checkout_val:\n        print(\"\u2705 Checkout button enabled\")\n\n# Use the store\nShoppingCartStore.items = [\n    {'name': 'Widget', 'price': 10.00, 'quantity': 2}\n]\n# Output: \ud83d\udcb0 New total: $20.00\n# Output: \u2705 Checkout button enabled\n\nShoppingCartStore.discount_code = \"SAVE20\"\n# Output: \ud83d\udcb0 New total: $16.00\n</code></pre>"},{"location":"reference/api/#documentation-conventions","title":"Documentation Conventions","text":"<p>Throughout this reference, we follow consistent patterns:</p> <ul> <li>Type signatures use Python type hints for clarity and enable IDE autocomplete</li> <li>Examples progress from simple to complex within each page</li> <li>Notes highlight gotchas that trip up newcomers</li> <li>Performance tips appear when relevant to optimization decisions</li> <li>See also links connect related concepts and alternative approaches</li> </ul>"},{"location":"reference/api/#navigating-this-reference","title":"Navigating This Reference","text":""},{"location":"reference/api/#new-to-fynx","title":"New to FynX?","text":"<p>Read in order: Observable \u2192 Store \u2192 @reactive \u2192 ConditionalObservable</p>"},{"location":"reference/api/#building-an-application","title":"Building an application?","text":"<p>Focus on: Store, Observable Operators (especially <code>&gt;&gt;</code>), @reactive</p>"},{"location":"reference/api/#need-complex-state-logic","title":"Need complex state logic?","text":"<p>Dive into: Observable Operators, ConditionalObservable, @reactive</p>"},{"location":"reference/api/#performance-optimization","title":"Performance optimization?","text":"<p>See: ComputedObservable for memoization, Observable for subscription management</p>"},{"location":"reference/api/#curious-about-implementation","title":"Curious about implementation?","text":"<p>Explore: Observable Descriptors to understand how the magic works</p> <p>For conceptual introductions and tutorials, return to the main documentation.</p>"},{"location":"reference/computed-observable/","title":"Derived Observables","text":"<p>Derived observables are created using the <code>.then()</code> method or <code>&gt;&gt;</code> operator to transform values from source observables.</p>"},{"location":"reference/computed-observable/#creating-derived-observables","title":"Creating Derived Observables","text":"<pre><code>from fynx import observable\n\n# Source observable\ncount = observable(0)\n\n# Derived observable using .then()\ndoubled = count.then(lambda x: x * 2)\n\n# Derived observable using &gt;&gt; operator\ntripled = count &gt;&gt; (lambda x: x * 3)\n\n# Subscribe to changes\ndoubled.subscribe(lambda x: print(f\"Doubled: {x}\"))\ntripled.subscribe(lambda x: print(f\"Tripled: {x}\"))\n\n# Update source\ncount.set(5)  # Prints: Doubled: 10, Tripled: 15\n</code></pre>"},{"location":"reference/computed-observable/#chaining-transformations","title":"Chaining Transformations","text":"<pre><code># Chain multiple transformations\nprocessed = count.then(lambda x: x * 2).then(lambda x: x + 1)\n\n# Or using &gt;&gt; operator\nprocessed = count &gt;&gt; (lambda x: x * 2) &gt;&gt; (lambda x: x + 1)\n\nprocessed.subscribe(lambda x: print(f\"Processed: {x}\"))\ncount.set(3)  # Prints: Processed: 7\n</code></pre>"},{"location":"reference/computed-observable/#using-named-functions","title":"Using Named Functions","text":"<p>For better readability and reusability, use named functions instead of lambdas:</p> <pre><code>def double(x):\n    return x * 2\n\ndef add_one(x):\n    return x + 1\n\n# Clean, readable transformations\ndoubled = count.then(double)\nincremented = doubled.then(add_one)\n\n# Or with &gt;&gt; operator\nresult = count &gt;&gt; double &gt;&gt; add_one\n</code></pre>"},{"location":"reference/computed-observable/#key-properties","title":"Key Properties","text":"<ul> <li>Reactive: Automatically update when source observables change</li> <li>Immutable: Don't modify source values, create new derived values</li> <li>Composable: Can be chained and combined with other observables</li> <li>Lazy: Only compute when subscribed to or when source changes</li> </ul>"},{"location":"reference/conditional-observable/","title":"ConditionalObservable","text":"<p>Observables that only emit values when specific conditions are met.</p>"},{"location":"reference/conditional-observable/#creating-conditional-observables","title":"Creating Conditional Observables","text":"<p>Use the <code>&amp;</code> operator to create conditional observables:</p> <pre><code>from fynx import observable\n\n# Source observable\ncount = observable(0)\n\n# Conditional observable - only emits when count &gt; 5\nfiltered = count &amp; (lambda x: x &gt; 5)\n\nfiltered.subscribe(lambda x: print(f\"Filtered: {x}\"))\n\ncount.set(3)  # No output\ncount.set(7)  # Prints: Filtered: 7\ncount.set(2)  # No output\n</code></pre>"},{"location":"reference/conditional-observable/#multiple-conditions","title":"Multiple Conditions","text":"<p>Chain multiple conditions using the <code>&amp;</code> operator:</p> <pre><code># Only emit when count is between 5 and 10\nrange_filtered = count &amp; (lambda x: x &gt;= 5) &amp; (lambda x: x &lt;= 10)\n\nrange_filtered.subscribe(lambda x: print(f\"In range: {x}\"))\n\ncount.set(3)   # No output\ncount.set(7)   # Prints: In range: 7\ncount.set(15)  # No output\n</code></pre>"},{"location":"reference/conditional-observable/#using-named-functions","title":"Using Named Functions","text":"<p>For better readability, use named functions:</p> <pre><code>def is_positive(x):\n    return x &gt; 0\n\ndef is_even(x):\n    return x % 2 == 0\n\n# Only emit positive even numbers\npositive_even = count &amp; is_positive &amp; is_even\n\npositive_even.subscribe(lambda x: print(f\"Positive even: {x}\"))\n\ncount.set(-2)  # No output\ncount.set(3)   # No output\ncount.set(4)   # Prints: Positive even: 4\n</code></pre>"},{"location":"reference/conditional-observable/#key-properties","title":"Key Properties","text":"<ul> <li>Filtering: Only emit values that satisfy all conditions</li> <li>Reactive: Automatically re-evaluate conditions when source changes</li> <li>Composable: Can be combined with other observables using <code>&amp;</code>, <code>+</code>, and <code>&gt;&gt;</code></li> <li>Efficient: Conditions are only evaluated when source values change</li> </ul>"},{"location":"reference/merged-observable/","title":"MergedObservable","text":"<p>Observables that combine multiple values using the merge operator (<code>+</code>).</p>"},{"location":"reference/merged-observable/#fynx.observable.merged--fynx-mergedobservable-combined-reactive-values","title":"FynX MergedObservable - Combined Reactive Values","text":"<p>This module provides the MergedObservable class, which combines multiple individual observables into a single reactive computed observable. This enables treating related observables as a cohesive group that updates atomically when any component changes.</p> <p>Merged observables are read-only computed observables that derive their value from their source observables. They are useful for:</p> <ul> <li>Coordinated Updates: When multiple values need to change together</li> <li>Computed Relationships: When derived values depend on multiple inputs</li> <li>Tuple Operations: When you need to pass multiple reactive values as a unit</li> <li>State Composition: Building complex state from simpler reactive components</li> </ul> <p>The merge operation is created using the <code>+</code> operator between observables:</p> <pre><code>from fynx import observable\n\nwidth = observable(10)\nheight = observable(20)\ndimensions = width + height  # Creates MergedObservable\nprint(dimensions.value)  # (10, 20)\n\nwidth.set(15)\nprint(dimensions.value)  # (15, 20)\n\n# Merged observables are read-only\ndimensions.set((5, 5))  # Raises ValueError: Computed observables are read-only\n</code></pre>"},{"location":"reference/merged-observable/#fynx.observable.merged.MergedObservable","title":"MergedObservable","text":"<pre><code>MergedObservable(*observables)\n</code></pre> <p>A computed observable that combines multiple observables into a single reactive tuple.</p> <p>MergedObservable creates a read-only computed observable whose value is a tuple containing the current values of all source observables. When any source observable changes, the merged observable automatically recalculates its tuple value and notifies all subscribers.</p> <p>As a computed observable, MergedObservable is read-only and cannot be set directly. Its value is always derived from its source observables, ensuring consistency.</p> <p>This enables treating multiple related reactive values as a single atomic unit, which is particularly useful for:</p> <ul> <li>Functions that need multiple related parameters</li> <li>Computed values that depend on several inputs</li> <li>Coordinated state updates across multiple variables</li> <li>Maintaining referential consistency between related values</li> </ul> Example <pre><code>from fynx import observable\n\n# Individual observables\nx = observable(10)\ny = observable(20)\n\n# Merge them into a single reactive unit\npoint = x + y\nprint(point.value)  # (10, 20)\n\n# Computed values can work with the tuple\ndistance_from_origin = point.then(\n    lambda px, py: (px**2 + py**2)**0.5\n)\nprint(distance_from_origin.value)  # 22.360679774997898\n\n# Changes to either coordinate update everything\nx.set(15)\nprint(point.value)                  # (15, 20)\nprint(distance_from_origin.value)   # 25.0\n</code></pre> Note <p>The merged observable's value is always a tuple, even when merging just two observables. This provides a consistent interface for computed functions.</p> See Also <p>ComputedObservable: Base computed observable class</p> <p>operator: For creating derived values from merged observables</p> <p>Create a merged observable from multiple source observables.</p> <p>Parameters:</p> Name Type Description Default <code>*observables</code> <code>Observable</code> <p>Variable number of Observable instances to combine.          At least one observable must be provided.</p> <code>()</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no observables are provided</p>"},{"location":"reference/merged-observable/#fynx.observable.merged.MergedObservable.value","title":"value","text":"<pre><code>value\n</code></pre> <p>Get the current tuple value, using cache when possible.</p> <p>Returns the current values of all source observables as a tuple. Uses caching to avoid recomputing the tuple on every access.</p> <p>Returns:</p> Type Description <p>A tuple containing the current values of all source observables,</p> <p>in the order they were provided to the constructor.</p> Example <pre><code>x = Observable(\"x\", 10)\ny = Observable(\"y\", 20)\nmerged = x + y\n\nprint(merged.value)  # (10, 20)\nx.set(15)\nprint(merged.value)  # (15, 20) - cache invalidated and recomputed\n</code></pre>"},{"location":"reference/merged-observable/#fynx.observable.merged.MergedObservable.__add__","title":"__add__","text":"<pre><code>__add__(other)\n</code></pre> <p>Chain merging with another observable using the + operator.</p> <p>Enables fluent syntax for building up merged observables incrementally. Each + operation creates a new MergedObservable containing all previous observables plus the new one.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Observable</code> <p>Another Observable to merge with this merged observable</p> required <p>Returns:</p> Type Description <code>MergedObservable</code> <p>A new MergedObservable containing all source observables from this</p> <code>MergedObservable</code> <p>merged observable plus the additional observable.</p>"},{"location":"reference/merged-observable/#fynx.observable.merged.MergedObservable.__enter__","title":"__enter__","text":"<pre><code>__enter__()\n</code></pre> <p>Context manager entry for reactive blocks.</p> <p>Enables experimental syntax for defining reactive blocks that execute whenever any of the merged observables change.</p> <p>Returns:</p> Type Description <p>A context object that can be called with a function to create reactive behavior.</p> Example <pre><code># Experimental context manager syntax\nwith merged_obs as ctx:\n    ctx(lambda x, y: print(f\"Values changed: {x}, {y}\"))\n</code></pre> Note <p>This is an experimental feature. The more common approach is to use subscribe() or the @reactive decorator.</p>"},{"location":"reference/merged-observable/#fynx.observable.merged.MergedObservable.__exit__","title":"__exit__","text":"<pre><code>__exit__(exc_type, exc_val, exc_tb)\n</code></pre> <p>Context manager exit.</p> <p>Currently does nothing, but allows the context manager to work properly.</p>"},{"location":"reference/merged-observable/#fynx.observable.merged.MergedObservable.subscribe","title":"subscribe","text":"<pre><code>subscribe(func)\n</code></pre> <p>Subscribe a function to react to changes in any of the merged observables.</p> <p>The subscribed function will be called whenever any source observable changes. This provides a way to react to coordinated changes across multiple observables.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable</code> <p>A callable that will receive the current values of all merged   observables as separate arguments, in the order they were merged.   The function signature should match the number of merged observables.</p> required <p>Returns:</p> Type Description <code>MergedObservable[T]</code> <p>This merged observable instance for method chaining.</p> <p>Examples:</p> <pre><code>x = Observable(\"x\", 1)\ny = Observable(\"y\", 2)\ncoords = x + y\n\ndef on_coords_change(x_val, y_val):\n    print(f\"Coordinates: ({x_val}, {y_val})\")\n\ncoords.subscribe(on_coords_change)\n\nx.set(10)  # Prints: \"Coordinates: (10, 2)\"\ny.set(20)  # Prints: \"Coordinates: (10, 20)\"\n</code></pre> Note <p>The function is called only when observables change. It is not called immediately upon subscription.</p> See Also <p>unsubscribe: Remove a subscription reactive: Decorator-based reactive functions</p>"},{"location":"reference/merged-observable/#fynx.observable.merged.MergedObservable.unsubscribe","title":"unsubscribe","text":"<pre><code>unsubscribe(func)\n</code></pre> <p>Unsubscribe a function from this merged observable.</p> <p>Removes the subscription for the specified function, preventing it from being called when the merged observable changes. This properly cleans up the reactive context and removes all observers.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable</code> <p>The function that was previously subscribed to this merged observable.   Must be the same function object that was passed to subscribe().</p> required <p>Examples:</p> <pre><code>def handler(x, y):\n    print(f\"Changed: {x}, {y}\")\n\ncoords = x + y\ncoords.subscribe(handler)\n\n# Later, unsubscribe\ncoords.unsubscribe(handler)  # No longer called when coords change\n</code></pre> Note <p>This only removes subscriptions to this specific merged observable. If the same function is subscribed to other observables, those subscriptions remain active.</p> See Also <p>subscribe: Add a subscription</p>"},{"location":"reference/observable-descriptors/","title":"Observable Descriptors","text":"<p>Classes for creating observable attributes in Store classes and other contexts.</p>"},{"location":"reference/observable-descriptors/#fynx.observable.descriptors--fynx-observable-descriptors-reactive-attribute-descriptors","title":"FynX Observable Descriptors - Reactive Attribute Descriptors","text":"<p>This module provides descriptor classes that enable transparent reactive programming in class attributes. These descriptors bridge the gap between regular Python attribute access and reactive capabilities, allowing Store classes to provide both familiar attribute syntax and full reactive behavior.</p>"},{"location":"reference/observable-descriptors/#fynx.observable.descriptors--transparent-reactivity","title":"Transparent Reactivity","text":"<p>FynX's descriptors enable \"transparent reactivity\" - the ability to write code that looks like regular attribute access while maintaining automatic dependency tracking and change propagation. This means you can use observables in existing code without major syntax changes.</p> <p>Instead of: <pre><code># Traditional reactive approach\nstore.counter.subscribe(lambda v: print(v))\nstore.counter.set(5)\n\n# Manual dependency tracking\ndef update_total():\n    total = store.price.value * store.quantity.value\n</code></pre></p> <p>You can write: <pre><code># Transparent reactive approach\nprint(store.counter)  # Direct access\nstore.counter = 5     # Automatic updates\n\n# Automatic dependency tracking\ntotal = store.price * store.quantity  # Reactive computation\n</code></pre></p>"},{"location":"reference/observable-descriptors/#fynx.observable.descriptors--how-it-works","title":"How It Works","text":"<p>The descriptor system works through two key components:</p> <ol> <li> <p>SubscriptableDescriptor: Attached to class attributes, creates and manages    the underlying Observable instances at the class level.</p> </li> <li> <p>ObservableValue: Returned when accessing descriptor attributes, provides    transparent value access while maintaining reactive capabilities.</p> </li> </ol> <p>When you access <code>store.counter</code>, the descriptor returns an ObservableValue that wraps the actual Observable, allowing natural value operations while preserving reactive behavior.</p>"},{"location":"reference/observable-descriptors/#fynx.observable.descriptors--key-benefits","title":"Key Benefits","text":"<ul> <li>Familiar Syntax: Use regular attribute access (<code>obj.attr = value</code>)</li> <li>Reactive Capabilities: Full access to subscription and operators</li> <li>Type Safety: Maintains type information through generics</li> <li>Performance: Efficient caching and lazy evaluation</li> <li>Compatibility: Works with existing Python idioms (iteration, comparison, etc.)</li> </ul>"},{"location":"reference/observable-descriptors/#fynx.observable.descriptors--common-patterns","title":"Common Patterns","text":"<p>Store Attributes: <pre><code>class UserStore(Store):\n    name = observable(\"Alice\")\n    age = observable(30)\n\n# Access like regular attributes\nprint(UserStore.name)      # \"Alice\"\nUserStore.age = 31         # Triggers reactive updates\n\n# But also provides reactive methods\nUserStore.name.subscribe(lambda n: print(f\"Name: {n}\"))\n</code></pre></p> <p>Transparent Integration: <pre><code># Works with existing Python constructs\nif store.is_enabled:\n    print(\"Enabled\")\n\nfor item in store.items:\n    print(item)\n\n# String formatting\nmessage = f\"User: {store.name}, Age: {store.age}\"\n</code></pre></p> <p>Reactive Operators: <pre><code># All operators work transparently\nfull_name = store.first_name + store.last_name &gt;&gt; (lambda f, l: f\"{f} {l}\")\nis_adult = store.age &gt;&gt; (lambda a: a &gt;= 18)\nvalid_user = store.name &amp; is_adult\n</code></pre></p>"},{"location":"reference/observable-descriptors/#fynx.observable.descriptors--implementation-details","title":"Implementation Details","text":"<p>Descriptor Protocol: Uses <code>__get__</code>, <code>__set__</code>, and <code>__set_name__</code> to integrate with Python's attribute system.</p> <p>Class-Level Storage: Observables are stored at the class level to ensure shared state across instances.</p> <p>Lazy Initialization: ObservableValue instances are created on-demand and cached for performance.</p> <p>Type Preservation: Generic types ensure compile-time type safety.</p>"},{"location":"reference/observable-descriptors/#fynx.observable.descriptors--performance-considerations","title":"Performance Considerations","text":"<ul> <li>Memory Efficient: Reuses Observable instances across attribute access</li> <li>Lazy Creation: ObservableValue wrappers created only when needed</li> <li>Minimal Overhead: Thin wrapper around actual Observable instances</li> <li>Caching: Internal caching prevents redundant operations</li> </ul>"},{"location":"reference/observable-descriptors/#fynx.observable.descriptors--best-practices","title":"Best Practices","text":"<ul> <li>Use Store Classes: Leverage descriptors through Store classes for better organization</li> <li>Consistent Access: Use either direct access or reactive methods, not both inconsistently</li> <li>Type Hints: Provide type annotations for better IDE support</li> <li>Documentation: Document store attributes and their purposes</li> </ul>"},{"location":"reference/observable-descriptors/#fynx.observable.descriptors--limitations","title":"Limitations","text":"<ul> <li>Descriptor behavior requires class-level attribute assignment</li> <li>Not suitable for instance-specific reactive attributes</li> <li>Some advanced Python features may not work as expected with wrapped values</li> </ul>"},{"location":"reference/observable-descriptors/#fynx.observable.descriptors--see-also","title":"See Also","text":"<ul> <li><code>fynx.store</code>: Store classes that use these descriptors</li> <li><code>fynx.observable</code>: Core observable classes</li> <li><code>fynx.computed</code>: Creating derived reactive values</li> </ul>"},{"location":"reference/observable-descriptors/#fynx.observable.descriptors.ObservableValue","title":"ObservableValue","text":"<pre><code>ObservableValue(observable)\n</code></pre> <p>A transparent wrapper that combines direct value access with observable capabilities.</p> <p>ObservableValue acts as a bridge between regular Python value access and reactive programming. It behaves like the underlying value in most contexts (equality, string conversion, iteration, etc.) while also providing access to observable methods like subscription and operator overloading.</p> <p>This class enables Store classes and other descriptor-based reactive systems to provide both familiar value access (<code>store.attr = value</code>) and reactive capabilities (<code>store.attr.subscribe(callback)</code>) through a single attribute.</p> <p>Key Features: - Transparent Value Access: Behaves like the underlying value for most operations - Observable Methods: Provides subscription and reactive operator access - Automatic Synchronization: Keeps the displayed value in sync with the observable - Operator Support: Enables <code>+</code>, <code>&gt;&gt;</code>, and other reactive operators - Type Safety: Generic type parameter ensures type-safe operations</p> Example <pre><code>from fynx import Store, observable\n\nclass CounterStore(Store):\n    count = observable(0)\n\n# ObservableValue provides both value access and reactive methods\ncounter = CounterStore.count\n\n# Direct value access (like a regular attribute)\nprint(counter)              # 0\nprint(counter == 0)         # True\nprint(len(counter))         # TypeError (unless value is a collection)\n\n# Observable methods\ncounter.set(5)              # Update the value\ncounter.subscribe(lambda x: print(f\"Count: {x}\"))\n\n# Reactive operators\ndoubled = counter &gt;&gt; (lambda x: x * 2)\n</code></pre> Note <p>ObservableValue instances are typically created automatically by SubscriptableDescriptor when accessing observable attributes on Store classes. You usually won't instantiate this class directly.</p> See Also <p>SubscriptableDescriptor: Creates ObservableValue instances for class attributes Observable: The underlying reactive value class Store: Uses ObservableValue for transparent reactive attributes</p>"},{"location":"reference/observable-descriptors/#fynx.observable.descriptors.ObservableValue.observable","title":"observable","text":"<pre><code>observable\n</code></pre> <p>Get the underlying observable instance.</p>"},{"location":"reference/observable-descriptors/#fynx.observable.descriptors.ObservableValue.__eq__","title":"__eq__","text":"<pre><code>__eq__(other)\n</code></pre> <p>Equality comparison delegates to the underlying observable.</p>"},{"location":"reference/observable-descriptors/#fynx.observable.descriptors.ObservableValue.__hash__","title":"__hash__","text":"<pre><code>__hash__()\n</code></pre> <p>Make ObservableValue hashable by delegating to the underlying observable.</p>"},{"location":"reference/observable-descriptors/#fynx.observable.descriptors.SubscriptableDescriptor","title":"SubscriptableDescriptor","text":"<pre><code>SubscriptableDescriptor(initial_value=None, original_observable=None)\n</code></pre> <p>Descriptor that creates reactive class attributes with transparent observable behavior.</p> <p>SubscriptableDescriptor enables Store classes and other reactive containers to define attributes that behave like regular Python attributes while providing full reactive capabilities. When accessed, it returns an ObservableValue instance that combines direct value access with observable methods.</p> <p>This descriptor is the foundation for FynX's transparent reactive programming model, allowing you to write code that looks like regular attribute access while maintaining full reactive capabilities.</p> <p>Key Features: - Class-Level Observables: Creates observables at the class level for shared state - Transparent Access: Attributes behave like regular values but are reactive - Automatic Management: Handles observable lifecycle and descriptor protocol - Store Integration: Designed to work seamlessly with Store classes - Memory Efficient: Reuses observable instances across class access</p> How It Works <ol> <li>When assigned to a class attribute, stores initial value and owner class</li> <li>On first access, creates a class-level Observable instance</li> <li>Returns an ObservableValue wrapper for transparent reactive access</li> <li>Subsequent accesses reuse the same observable instance</li> </ol> Example <pre><code>from fynx import Store, observable\n\nclass UserStore(Store):\n    # This creates a SubscriptableDescriptor\n    name = observable(\"Alice\")\n    age = observable(30)\n\n# Access returns ObservableValue instances\nuser_name = UserStore.name    # ObservableValue wrapping Observable\nuser_age = UserStore.age      # ObservableValue wrapping Observable\n\n# Behaves like regular attributes\nprint(user_name)              # \"Alice\"\nUserStore.name = \"Bob\"        # Updates the observable\nprint(user_name)              # \"Bob\"\n\n# But also provides reactive methods\nUserStore.name.subscribe(lambda n: print(f\"Name changed to: {n}\"))\n</code></pre> Note <p>This descriptor is typically used indirectly through the <code>observable()</code> function in Store classes. Direct instantiation is usually not needed.</p> See Also <p>ObservableValue: The wrapper returned by this descriptor observable: Convenience function that creates SubscriptableDescriptor instances Store: Uses this descriptor for reactive class attributes</p>"},{"location":"reference/observable-descriptors/#fynx.observable.descriptors.SubscriptableDescriptor.__get__","title":"__get__","text":"<pre><code>__get__(instance, owner)\n</code></pre> <p>Get the observable value for this attribute.</p>"},{"location":"reference/observable-descriptors/#fynx.observable.descriptors.SubscriptableDescriptor.__set__","title":"__set__","text":"<pre><code>__set__(instance, value)\n</code></pre> <p>Set the value on the observable.</p>"},{"location":"reference/observable-descriptors/#fynx.observable.descriptors.SubscriptableDescriptor.__set_name__","title":"__set_name__","text":"<pre><code>__set_name__(owner, name)\n</code></pre> <p>Called when the descriptor is assigned to a class attribute.</p>"},{"location":"reference/observable-operators/","title":"Observable Operators","text":"<p>Special operators for composing and transforming observables.</p>"},{"location":"reference/observable-operators/#fynx.observable.operators--fynx-operators-observable-operator-implementations-and-mixins","title":"FynX Operators - Observable Operator Implementations and Mixins","text":"<p>This module provides the core operator implementations and mixins that enable FynX's fluent reactive programming syntax. These operators allow observables to be composed using intuitive Python operators, creating complex reactive behaviors from simple building blocks.</p>"},{"location":"reference/observable-operators/#fynx.observable.operators--why-operators","title":"Why Operators?","text":"<p>FynX uses Python's operator overloading to provide a natural, readable syntax for reactive programming. Instead of verbose method calls, you can express reactive relationships using familiar operators:</p> <ul> <li><code>observable &gt;&gt; function</code> - Transform values reactively</li> <li><code>observable &amp; condition</code> - Filter values conditionally</li> <li><code>obs1 + obs2 + obs3</code> - Combine observables</li> </ul> <p>This approach makes reactive code more declarative and easier to understand.</p>"},{"location":"reference/observable-operators/#fynx.observable.operators--operator-overview","title":"Operator Overview","text":"<p>Transform (<code>&gt;&gt;</code>): Apply functions to create derived values <pre><code>doubled = counter &gt;&gt; (lambda x: x * 2)\n</code></pre></p> <p>Filter (<code>&amp;</code>): Only emit values when conditions are met <pre><code>valid_data = data &amp; is_valid\n</code></pre></p> <p>Combine (<code>+</code>): Merge multiple observables into tuples <pre><code>coordinates = x + y + z\n</code></pre></p> <p>These operators work together to create complex reactive pipelines: <pre><code>result = (x + y) &gt;&gt; (lambda a, b: a + b) &amp; (total &gt;&gt; (lambda t: t &gt; 10))\n</code></pre></p>"},{"location":"reference/observable-operators/#fynx.observable.operators--operator-mixins","title":"Operator Mixins","text":"<p>This module also provides mixin classes that consolidate operator overloading logic:</p> <p>OperatorMixin: Provides common reactive operators (add, rshift, and, invert) for all observable types that support reactive composition.</p> <p>TupleMixin: Adds tuple-like behavior (iter, len, getitem, setitem) for observables that represent collections of values.</p> <p>ValueMixin: Provides transparent value wrapper behavior for ObservableValue instances, making them behave like regular Python values while supporting reactive operators.</p>"},{"location":"reference/observable-operators/#fynx.observable.operators--implementation-details","title":"Implementation Details","text":"<p>The operators are implemented as standalone functions rather than methods to avoid circular import issues and enable lazy loading. They are called automatically when you use the corresponding operators on Observable instances.</p> <p>The functions handle different observable types (regular, merged, conditional) appropriately, ensuring consistent behavior across the reactive system.</p>"},{"location":"reference/observable-operators/#fynx.observable.operators--performance-characteristics","title":"Performance Characteristics","text":"<ul> <li>Lazy Evaluation: Operators create computed/conditional observables that   only evaluate when needed</li> <li>Efficient Composition: Multiple operators can be chained without   creating intermediate objects</li> <li>Memory Conscious: Operators reuse existing infrastructure rather than   creating new classes</li> </ul>"},{"location":"reference/observable-operators/#fynx.observable.operators--common-patterns","title":"Common Patterns","text":"<p>Data Processing Pipeline: <pre><code>raw_data = observable([])\nprocessed = (raw_data\n    &gt;&gt; (lambda d: [x for x in d if x &gt; 0])  # Filter positive values\n    &gt;&gt; (lambda d: sorted(d))                # Sort results\n    &gt;&gt; (lambda d: sum(d) / len(d) if d else 0))  # Calculate average\n</code></pre></p> <p>Conditional UI Updates: <pre><code>user_input = observable(\"\")\nis_valid = user_input &gt;&gt; (lambda s: len(s) &gt;= 3)\nshow_error = user_input &amp; ~is_valid  # Show error when input is invalid but not empty\n</code></pre></p> <p>Reactive Calculations: <pre><code>price = observable(10.0)\nquantity = observable(1)\ntax_rate = observable(0.08)\n\nsubtotal = (price + quantity) &gt;&gt; (lambda p, q: p * q)\ntax = subtotal &gt;&gt; (lambda s: s * tax_rate.value)\ntotal = (subtotal + tax) &gt;&gt; (lambda s, t: s + t)\n</code></pre></p>"},{"location":"reference/observable-operators/#fynx.observable.operators--error-handling","title":"Error Handling","text":"<p>Operators handle errors gracefully: - Transformation function errors are propagated but don't break the reactive system - Invalid operator usage provides clear error messages - Circular dependencies are detected and prevented</p>"},{"location":"reference/observable-operators/#fynx.observable.operators--best-practices","title":"Best Practices","text":"<ul> <li>Keep Functions Pure: Transformation functions should not have side effects</li> <li>Use Meaningful Lambdas: Complex operations deserve named functions</li> <li>Chain Thoughtfully: Break complex chains into intermediate variables for clarity</li> <li>Handle Edge Cases: Consider what happens with None, empty collections, etc.</li> </ul>"},{"location":"reference/observable-operators/#fynx.observable.operators--migration-from-method-calls","title":"Migration from Method Calls","text":"<p>If you're familiar with other reactive libraries, here's how FynX operators compare:</p> <pre><code># Other libraries (method-based)\nresult = obs.map(lambda x: x * 2).filter(lambda x: x &gt; 10)\n\n# FynX (operator-based)\nresult = obs &gt;&gt; (lambda x: x * 2) &amp; (obs &gt;&gt; (lambda x: x &gt; 10))\n</code></pre> <p>The operator syntax is more concise and readable for simple transformations.</p>"},{"location":"reference/observable-operators/#fynx.observable.operators--see-also","title":"See Also","text":"<ul> <li><code>fynx.observable</code>: Core observable classes that use these operators and mixins</li> <li><code>fynx.computed</code>: Computed observables created by the <code>&gt;&gt;</code> operator</li> <li><code>fynx.watch</code>: Conditional reactive functions (alternative to <code>&amp;</code>)</li> </ul>"},{"location":"reference/observable-operators/#fynx.observable.operators.OperatorMixin","title":"OperatorMixin","text":"<p>Mixin class providing common reactive operators for observable classes.</p> <p>This mixin consolidates the operator overloading logic that was previously duplicated across multiple observable classes. It provides the core reactive operators (add, rshift, and, invert) that enable FynX's fluent reactive programming syntax.</p> <p>Classes inheriting from this mixin get automatic support for: - Merging with <code>+</code> operator - Transformation with <code>&gt;&gt;</code> operator - Conditional filtering with <code>&amp;</code> operator - Boolean negation with <code>~</code> operator</p> <p>This mixin should be used by classes that represent reactive values and need to support reactive composition operations.</p>"},{"location":"reference/observable-operators/#fynx.observable.operators.OperatorMixin.__add__","title":"__add__","text":"<pre><code>__add__(other)\n</code></pre> <p>Combine this observable with another using the + operator.</p> <p>This creates a merged observable that contains a tuple of both values and updates automatically when either observable changes.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <p>Another Observable to combine with</p> required <p>Returns:</p> Type Description <code>Mergeable</code> <p>A MergedObservable containing both values as a tuple</p>"},{"location":"reference/observable-operators/#fynx.observable.operators.OperatorMixin.__and__","title":"__and__","text":"<pre><code>__and__(condition)\n</code></pre> <p>Create a conditional observable using the &amp; operator for filtered reactivity.</p> <p>This creates a ConditionalObservable that only emits values when all specified conditions are True, enabling precise control over reactive updates.</p> <p>Parameters:</p> Name Type Description Default <code>condition</code> <p>A boolean Observable, callable, or compound condition</p> required <p>Returns:</p> Type Description <code>Conditional</code> <p>A ConditionalObservable that filters values based on the condition</p>"},{"location":"reference/observable-operators/#fynx.observable.operators.OperatorMixin.__invert__","title":"__invert__","text":"<pre><code>__invert__()\n</code></pre> <p>Create a negated boolean observable using the ~ operator.</p> <p>This creates a computed observable that returns the logical negation of the current boolean value, useful for creating inverse conditions.</p> <p>Returns:</p> Type Description <code>Observable[bool]</code> <p>A computed Observable[bool] with negated boolean value</p>"},{"location":"reference/observable-operators/#fynx.observable.operators.OperatorMixin.__or__","title":"__or__","text":"<pre><code>__or__(other)\n</code></pre> <p>Create a logical OR condition using the | operator.</p> <p>This creates a conditional observable that only emits when the OR result is truthy. If the initial OR result is falsy, raises ConditionalNeverMet.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <p>Another boolean observable to OR with</p> required <p>Returns:</p> Type Description <code>Observable</code> <p>A conditional observable that only emits when OR is truthy</p> <p>Raises:</p> Type Description <code>ConditionalNeverMet</code> <p>If initial OR result is falsy</p>"},{"location":"reference/observable-operators/#fynx.observable.operators.OperatorMixin.__radd__","title":"__radd__","text":"<pre><code>__radd__(other)\n</code></pre> <p>Support right-side addition for merging observables.</p> <p>This enables expressions like <code>other + self</code> to work correctly, ensuring that merged observables can be chained properly.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <p>Another Observable to combine with</p> required <p>Returns:</p> Type Description <code>Mergeable</code> <p>A MergedObservable containing both values as a tuple</p>"},{"location":"reference/observable-operators/#fynx.observable.operators.OperatorMixin.__rshift__","title":"__rshift__","text":"<pre><code>__rshift__(func)\n</code></pre> <p>Apply a transformation function using the &gt;&gt; operator to create computed observables.</p> <p>This implements the functorial map operation over observables, allowing you to transform observable values through pure functions while preserving reactivity.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable</code> <p>A pure function to apply to the observable's value(s)</p> required <p>Returns:</p> Type Description <code>Observable</code> <p>A new computed Observable containing the transformed values</p>"},{"location":"reference/observable-operators/#fynx.observable.operators.TupleMixin","title":"TupleMixin","text":"<p>Mixin class providing tuple-like operators for merged observables.</p> <p>This mixin adds tuple-like behavior to observables that represent collections of values (like MergedObservable). It provides operators for iteration, indexing, and length operations that make merged observables behave like tuples of their component values.</p> <p>Classes inheriting from this mixin get automatic support for: - Iteration with <code>for item in merged:</code> - Length with <code>len(merged)</code> - Indexing with <code>merged[0]</code>, <code>merged[-1]</code>, etc. - Setting values by index with <code>merged[0] = new_value</code></p>"},{"location":"reference/observable-operators/#fynx.observable.operators.TupleMixin.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(index)\n</code></pre> <p>Allow indexing into the merged observable like a tuple.</p>"},{"location":"reference/observable-operators/#fynx.observable.operators.TupleMixin.__iter__","title":"__iter__","text":"<pre><code>__iter__()\n</code></pre> <p>Allow iteration over the tuple value.</p>"},{"location":"reference/observable-operators/#fynx.observable.operators.TupleMixin.__len__","title":"__len__","text":"<pre><code>__len__()\n</code></pre> <p>Return the number of combined observables.</p>"},{"location":"reference/observable-operators/#fynx.observable.operators.TupleMixin.__setitem__","title":"__setitem__","text":"<pre><code>__setitem__(index, value)\n</code></pre> <p>Allow setting values by index, updating the corresponding source observable.</p>"},{"location":"reference/observable-operators/#fynx.observable.operators.ValueMixin","title":"ValueMixin","text":"<p>Mixin class providing value wrapper operators for ObservableValue.</p> <p>This mixin adds operators that make observable values behave transparently like their underlying values in most Python contexts. It provides magic methods for equality, string conversion, iteration, indexing, etc., while also supporting the reactive operators.</p> <p>Classes inheriting from this mixin get automatic support for: - Value-like behavior (equality, string conversion, etc.) - Reactive operators (add, and, invert, rshift) - Transparent access to the wrapped observable</p>"},{"location":"reference/observable-operators/#fynx.observable.operators.ValueMixin.__add__","title":"__add__","text":"<pre><code>__add__(other)\n</code></pre> <p>Support merging observables with + operator.</p>"},{"location":"reference/observable-operators/#fynx.observable.operators.ValueMixin.__and__","title":"__and__","text":"<pre><code>__and__(condition)\n</code></pre> <p>Support conditional observables with &amp; operator.</p>"},{"location":"reference/observable-operators/#fynx.observable.operators.ValueMixin.__invert__","title":"__invert__","text":"<pre><code>__invert__()\n</code></pre> <p>Support negating conditions with ~ operator.</p>"},{"location":"reference/observable-operators/#fynx.observable.operators.ValueMixin.__radd__","title":"__radd__","text":"<pre><code>__radd__(other)\n</code></pre> <p>Support right-side addition for merging observables.</p>"},{"location":"reference/observable-operators/#fynx.observable.operators.ValueMixin.__rshift__","title":"__rshift__","text":"<pre><code>__rshift__(func)\n</code></pre> <p>Support computed observables with &gt;&gt; operator.</p>"},{"location":"reference/observable-operators/#fynx.observable.operators.and_operator","title":"and_operator","text":"<pre><code>and_operator(obs, condition)\n</code></pre> <p>Implement the <code>&amp;</code> operator for creating conditional observables.</p> <p>This operator creates conditional observables that only emit values when boolean conditions are satisfied. The resulting observable filters the reactive stream, preventing unnecessary updates and computations when conditions aren't met.</p> <p>Parameters:</p> Name Type Description Default <code>obs</code> <p>The source observable whose values will be conditionally emitted.</p> required <code>condition</code> <p>A boolean observable that acts as a gate. Values from <code>obs</code>       are only emitted when this condition is True.</p> required <p>Returns:</p> Type Description <p>A new ConditionalObservable that only emits values when the condition is met.</p> <p>The observable starts with None if the condition is initially False.</p> <p>Examples:</p> <pre><code>from fynx.observable import Observable\n\n# Basic conditional filtering\ndata = Observable(\"data\", \"hello\")\nis_ready = Observable(\"ready\", False)\n\nfiltered = data &amp; is_ready  # Only emits when is_ready is True\n\nfiltered.subscribe(lambda x: print(f\"Received: {x}\"))\ndata.set(\"world\")      # No output (is_ready is False)\nis_ready.set(True)     # Prints: \"Received: world\"\n\n# Multiple conditions (chained)\nuser_present = Observable(\"present\", True)\nsmart_data = data &amp; is_ready &amp; user_present  # All must be True\n\n# Practical example: temperature monitoring\ntemperature = Observable(\"temp\", 20)\nalarm_enabled = Observable(\"alarm\", True)\nis_critical = Observable(\"critical\", False)\n\nalarm_trigger = temperature &amp; alarm_enabled &amp; is_critical\nalarm_trigger.subscribe(lambda t: print(f\"\ud83d\udea8 Alarm: {t}\u00b0C\"))\n</code></pre> Note <p>Multiple conditions can be chained: <code>obs &amp; cond1 &amp; cond2 &amp; cond3</code>. All conditions must be True for values to be emitted.</p> See Also <p>ConditionalObservable: The class that implements conditional behavior Observable.and: The magic method that calls this operator</p>"},{"location":"reference/observable-operators/#fynx.observable.operators.rshift_operator","title":"rshift_operator","text":"<pre><code>rshift_operator(obs, func)\n</code></pre> <p>Implement the <code>&gt;&gt;</code> operator with comprehensive categorical optimization.</p> <p>This operator creates computed observables using the full categorical optimization system, applying functor composition fusion, product factorization, and cost-optimal materialization strategies automatically.</p> <p>Categorical Optimization System: - Rule 1: Functor composition collapse (fuses sequential transformations) - Rule 2: Product factorization (shares common subexpressions) - Rule 3: Pullback fusion (combines sequential filters) - Rule 4: Cost-optimal materialization (decides what to cache vs recompute)</p> <p>The optimization uses a cost functional C(\u03c3) = \u03b1\u00b7|Dep(\u03c3)| + \u03b2\u00b7E[Updates(\u03c3)] + \u03b3\u00b7depth(\u03c3) to find semantically equivalent observables with minimal computational cost.</p> <p>For merged observables (created with <code>+</code>), the function receives multiple arguments corresponding to the tuple values. For single observables, it receives one argument.</p> <p>Parameters:</p> Name Type Description Default <code>obs</code> <code>Observable[T]</code> <p>The source observable(s) to transform. Can be a single Observable or  a MergedObservable (from <code>+</code> operator).</p> required <code>func</code> <code>Callable[..., U]</code> <p>A pure function that transforms the observable value(s). For merged   observables, receives unpacked tuple values as separate arguments.</p> required <p>Returns:</p> Type Description <code>Observable[U]</code> <p>A new computed observable with optimal structure. Updates automatically</p> <code>Observable[U]</code> <p>when source observables change, but with dramatically improved performance</p> <code>Observable[U]</code> <p>through categorical optimizations.</p> <p>Examples:</p> <pre><code>from fynx.observable import Observable\n\n# Single observable with automatic optimization\ncounter = Observable(\"counter\", 5)\nresult = counter &gt;&gt; (lambda x: x * 2) &gt;&gt; (lambda x: x + 10) &gt;&gt; str\n# Automatically optimized to single fused computation\n\n# Complex reactive pipelines are optimized globally\nwidth = Observable(\"width\", 10)\nheight = Observable(\"height\", 20)\narea = (width + height) &gt;&gt; (lambda w, h: w * h)\nvolume = (width + height + Observable(\"depth\", 5)) &gt;&gt; (lambda w, h, d: w * h * d)\n# Shared width/height computations are factored out automatically\n</code></pre> Performance <ul> <li>Chain fusion: O(N) depth \u2192 O(1) for transformation chains</li> <li>Subexpression sharing: Eliminates redundant computations</li> <li>Cost optimization: Balances memory vs computation tradeoffs</li> <li>Typical speedup: 1000\u00d7 - 10000\u00d7 for deep reactive graphs</li> </ul> See Also <p>Observable.then: The method that creates computed observables MergedObservable: For combining multiple observables with <code>+</code> optimizer: The categorical optimization system</p>"},{"location":"reference/observable/","title":"Observable","text":"<p>The core observable class that provides reactive values.</p> <p>A reactive value that automatically notifies dependents when it changes.</p> <p>Observable is the core primitive of FynX's reactivity system. It wraps a value and provides transparent reactive behavior - when the value changes, all dependent computations and reactions are automatically notified and updated.</p> <p>Key Features: - Transparent: Behaves like a regular value but with reactive capabilities - Dependency Tracking: Automatically tracks which reactive contexts depend on it - Change Notification: Notifies all observers when the value changes - Type Safety: Generic type parameter ensures type-safe operations - Lazy Evaluation: Computations only re-run when actually needed - Circular Dependency Detection: Prevents infinite loops at runtime</p> <p>Observable implements various magic methods (<code>__eq__</code>, <code>__str__</code>, etc.) to behave like its underlying value in most contexts, making it easy to use in existing code without modification.</p> <p>Attributes:</p> Name Type Description <code>key</code> <code>Optional[str]</code> <p>Unique identifier for debugging and serialization</p> <code>_value</code> <code>Optional[T]</code> <p>The current wrapped value</p> <code>_observers</code> <code>Set[Callable]</code> <p>Set of observer functions</p> Class Attributes <p>_current_context (Optional[ReactiveContext]): Current reactive execution context _context_stack (List[ReactiveContext]): Stack of nested reactive contexts</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Optional[str]</code> <p>A unique identifier for this observable (used for debugging).  If None, will be set to \"\" and updated in set_name. <code>None</code> <code>initial_value</code> <code>Optional[T]</code> <p>The initial value to store. Can be any type.</p> <code>None</code> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If a circular dependency is detected during value updates.</p> Example <pre><code>from fynx.observable import Observable\n\n# Create an observable\ncounter = Observable(\"counter\", 0)\n\n# Direct access (transparent behavior)\nprint(counter.value)  # 0\nprint(counter == 0)   # True\nprint(str(counter))   # \"0\"\n\n# Subscribe to changes\ndef on_change():\n    print(f\"Counter changed to: {counter.value}\")\n\ncounter.subscribe(on_change)\ncounter.set(5)  # Prints: \"Counter changed to: 5\"\n</code></pre> Note <p>While you can create Observable instances directly, it's often more convenient to use the <code>observable()</code> descriptor in Store classes for better organization and automatic serialization support.</p> See Also <p>Store: For organizing observables into reactive state containers computed: For creating derived values from observables reactive: For creating reactive functions that respond to changes</p> <p>Initialize an observable value.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Optional[str]</code> <p>A unique identifier for this observable (used for serialization).  If None, will be set to \"\" and updated in set_name. <code>None</code> <code>initial_value</code> <code>Optional[T]</code> <p>The initial value to store</p> <code>None</code>"},{"location":"reference/observable/#fynx.observable.base.Observable.key","title":"key","text":"<pre><code>key\n</code></pre> <p>Get the unique identifier for this observable.</p>"},{"location":"reference/observable/#fynx.observable.base.Observable.value","title":"value","text":"<pre><code>value\n</code></pre> <p>Get the current value of this observable.</p> <p>Accessing the value property automatically registers this observable as a dependency if called within a reactive context (computation or reaction).</p> <p>Returns:</p> Type Description <code>Optional[T]</code> <p>The current value stored in this observable, or None if not set.</p> Note <p>This property is tracked by the reactive system. Use it instead of accessing _value directly to ensure proper dependency tracking.</p> Example <pre><code>obs = Observable(\"counter\", 5)\nprint(obs.value)  # 5\n\n# In a reactive context, this creates a dependency\n@reactive(obs)\ndef print_value(val):\n    print(f\"Value: {val}\")\n</code></pre>"},{"location":"reference/observable/#fynx.observable.base.Observable.__bool__","title":"__bool__","text":"<pre><code>__bool__()\n</code></pre> <p>Boolean conversion returns whether the value is truthy.</p> <p>This allows observables to be used directly in boolean contexts (if statements, boolean operations) just like regular values.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the wrapped value is truthy, False otherwise.</p> Example <pre><code>obs = Observable(\"flag\", True)\nif obs:  # Works like if obs.value\n    print(\"Observable is truthy\")\n\nobs.set(0)  # False\nif not obs:  # Works like if not obs.value\n    print(\"Observable is falsy\")\n</code></pre>"},{"location":"reference/observable/#fynx.observable.base.Observable.__eq__","title":"__eq__","text":"<pre><code>__eq__(other)\n</code></pre> <p>Equality comparison with another value or observable.</p> <p>Compares the wrapped values for equality. If comparing with another Observable, compares their wrapped values.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>object</code> <p>Value or Observable to compare with</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the values are equal, False otherwise.</p> Example <pre><code>obs1 = Observable(\"a\", 5)\nobs2 = Observable(\"b\", 5)\nregular_val = 5\n\nobs1 == obs2      # True (both wrap 5)\nobs1 == regular_val  # True (observable equals regular value)\nobs1 == 10        # False (5 != 10)\n</code></pre>"},{"location":"reference/observable/#fynx.observable.base.Observable.__hash__","title":"__hash__","text":"<pre><code>__hash__()\n</code></pre> <p>Hash based on object identity, not value.</p> <p>Since values may be unhashable (like dicts, lists), observables hash based on their object identity rather than their value.</p> <p>Returns:</p> Type Description <code>int</code> <p>Hash of the observable's object identity.</p> Note <p>This means observables with the same value will not be considered equal for hashing purposes, only identical objects.</p> Example <pre><code>obs1 = Observable(\"a\", [1, 2, 3])\nobs2 = Observable(\"b\", [1, 2, 3])\n\n# These will have different hashes despite same value\nhash(obs1) != hash(obs2)  # True\n\n# But identical objects hash the same\nhash(obs1) == hash(obs1)  # True\n</code></pre>"},{"location":"reference/observable/#fynx.observable.base.Observable.__repr__","title":"__repr__","text":"<pre><code>__repr__()\n</code></pre> <p>Developer representation showing the observable's key and current value.</p> <p>Returns:</p> Type Description <code>str</code> <p>A string representation useful for debugging and development.</p> Example <pre><code>obs = Observable(\"counter\", 42)\nprint(repr(obs))  # Observable('counter', 42)\n</code></pre>"},{"location":"reference/observable/#fynx.observable.base.Observable.__set_name__","title":"__set_name__","text":"<pre><code>__set_name__(owner, name)\n</code></pre> <p>Called when this Observable is assigned to a class attribute.</p> <p>This method implements the descriptor protocol to enable automatic conversion of Observable instances to appropriate descriptors based on the owning class type.</p> <p>For Store classes, the conversion is handled by StoreMeta metaclass. For other classes, converts to SubscriptableDescriptor for class-level observable behavior.</p> <p>Parameters:</p> Name Type Description Default <code>owner</code> <code>Type</code> <p>The class that owns this attribute</p> required <code>name</code> <code>str</code> <p>The name of the attribute being assigned</p> required Note <p>This method is called automatically by Python when an Observable instance is assigned to a class attribute. It modifies the class to use the appropriate descriptor for reactive behavior.</p> Example <pre><code>class MyClass:\n    obs = Observable(\"counter\", 0)  # __set_name__ called here\n\n# Gets converted to a descriptor automatically\ninstance = MyClass()\nprint(instance.obs)  # Uses descriptor\n</code></pre>"},{"location":"reference/observable/#fynx.observable.base.Observable.__str__","title":"__str__","text":"<pre><code>__str__()\n</code></pre> <p>String representation of the wrapped value.</p> <p>Returns the string representation of the current value, enabling observables to be used seamlessly in string contexts.</p> <p>Returns:</p> Type Description <code>str</code> <p>String representation of the wrapped value.</p> Example <pre><code>obs = Observable(\"name\", \"Alice\")\nprint(f\"Hello {obs}\")  # Prints: \"Hello Alice\"\nmessage = \"User: \" + obs  # Works like \"User: \" + obs.value\n</code></pre>"},{"location":"reference/observable/#fynx.observable.base.Observable.add_observer","title":"add_observer","text":"<pre><code>add_observer(observer)\n</code></pre> <p>Add an observer function that will be called when this observable changes.</p> <p>Parameters:</p> Name Type Description Default <code>observer</code> <code>Callable</code> <p>A callable that takes no arguments</p> required"},{"location":"reference/observable/#fynx.observable.base.Observable.remove_observer","title":"remove_observer","text":"<pre><code>remove_observer(observer)\n</code></pre> <p>Remove an observer function.</p> <p>Parameters:</p> Name Type Description Default <code>observer</code> <code>Callable</code> <p>The observer function to remove</p> required"},{"location":"reference/observable/#fynx.observable.base.Observable.set","title":"set","text":"<pre><code>set(value)\n</code></pre> <p>Set the value and notify all observers if the value changed.</p> <p>This method updates the observable's value and triggers change notifications to all registered observers. The update only occurs if the new value is different from the current value (using != comparison).</p> <p>Circular dependency detection is performed to prevent infinite loops where a computation tries to modify one of its own dependencies.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Optional[T]</code> <p>The new value to set. Can be any type compatible with the    observable's generic type parameter.</p> required <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If setting this value would create a circular dependency          (e.g., a computed value trying to modify its own input).</p> Example <pre><code>obs = Observable(\"counter\", 0)\nobs.set(5)  # Triggers observers if value changed\n\n# No change, no notification\nobs.set(5)  # Same value, observers not called\n</code></pre> Note <p>Equality is checked using <code>!=</code> operator, so custom objects should implement proper equality comparison if needed.</p>"},{"location":"reference/observable/#fynx.observable.base.Observable.subscribe","title":"subscribe","text":"<pre><code>subscribe(func)\n</code></pre> <p>Subscribe a function to react to changes in this observable.</p> <p>The subscribed function will be called whenever the observable's value changes.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable</code> <p>A callable that accepts one argument (the new value).   The function will be called whenever the observable's value changes.</p> required <p>Returns:</p> Type Description <code>Observable[T]</code> <p>This observable instance for method chaining.</p> Example <pre><code>def on_change(new_value):\n    print(f\"Observable changed to: {new_value}\")\n\nobs = Observable(\"counter\", 0)\nobs.subscribe(on_change)\n\nobs.set(5)  # Prints: \"Observable changed to: 5\"\n</code></pre> Note <p>The function is called only when the observable's value changes. It is not called immediately upon subscription.</p> See Also <p>unsubscribe: Remove a subscription reactive: Decorator-based subscription with automatic dependency tracking</p>"},{"location":"reference/observable/#fynx.observable.base.Observable.unsubscribe","title":"unsubscribe","text":"<pre><code>unsubscribe(func)\n</code></pre> <p>Unsubscribe a function from this observable.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable</code> <p>The function to unsubscribe from this observable</p> required"},{"location":"reference/reactive-decorator/","title":"Understanding the @reactive Decorator","text":"<p>The <code>@reactive</code> decorator bridges your pure, functional data transformations with the messy, real world of side effects. Think of it as the membrane between your application's logic and everything outside it\u2014the UI, the network, the file system, the console.</p>"},{"location":"reference/reactive-decorator/#starting-simple","title":"Starting Simple","text":"<p>Let's see what reactive functions look like in practice:</p> <pre><code>from fynx import reactive, observable\n\ncount = observable(0)\n\n@reactive(count)\ndef log_count(value):\n    print(f\"Count: {value}\")\n\ncount.set(5)   # Prints: \"Count: 5\"\ncount.set(10)  # Prints: \"Count: 10\"\n</code></pre> <p>The function runs automatically whenever <code>count</code> changes. You declare what should happen when data changes, and the framework handles the timing.</p>"},{"location":"reference/reactive-decorator/#the-commitment-what-you-gain-and-what-you-give-up","title":"The Commitment: What You Gain and What You Give Up","text":"<p>Once you decorate a function with <code>@reactive</code>, you're making a commitment. The function becomes automatic\u2014it runs when its dependencies change. In exchange, you lose the ability to call it manually:</p> <pre><code>@reactive(count)\ndef log_count(value):\n    print(f\"Count: {value}\")\n\nlog_count(10)  # Raises fynx.reactive.ReactiveFunctionWasCalled exception\n</code></pre> <p>This isn't an arbitrary restriction. It's protecting you from confusion. If you could call <code>log_count()</code> manually and have it trigger automatically, which version of the value is authoritative? The manual call or the reactive update? The framework eliminates this ambiguity by enforcing one mode at a time.</p> <p>You can always change your mind, though. Call <code>.unsubscribe()</code> to sever the reactive connection and return the function to normal, non-reactive behavior:</p> <pre><code>@reactive(count)\ndef log_count(value):\n    print(f\"Count: {value}\")\n\ncount.set(5)   # Prints: \"Count: 5\"\n\nlog_count.unsubscribe()  # Severs the reactive connection\n\ncount.set(10)  # No output\u2014the function is no longer reactive\nlog_count(15)  # Prints: \"Count: 15\"\u2014now works as a normal function\n</code></pre> <p>After unsubscribing, the function reverts to its original, non-reactive form. You can call it manually again, and it will no longer respond to changes in its former dependencies.</p>"},{"location":"reference/reactive-decorator/#a-crucial-detail-initial-state-and-change-semantics","title":"A Crucial Detail: Initial State and Change Semantics","text":"<p>Here's something that might surprise you: when you create a reactive function, it doesn't fire immediately with the current value. It only fires when the value changes.</p> <pre><code>ready = observable(True)  # Already true\n\n@reactive(ready)\ndef on_ready(value):\n    print(f\"Ready: {value}\")\n\n# Nothing prints yet, even though ready is True\n\nready.set(False)  # Prints: \"Ready: False\"\nready.set(True)   # Prints: \"Ready: True\"\n</code></pre> <p>This behavior has deep roots in category theory\u2014reactive functions form what's called a \"pullback\" in categorical semantics. The initial state isn't captured because you haven't pulled back through a change yet. You're observing the flow of changes, not the snapshot of current state.</p> <p>This matters enormously for initialization logic. If you need something to run immediately based on current state, you'll need to handle that separately. Reactive functions are about responding to transitions, not about reflecting static state.</p>"},{"location":"reference/reactive-decorator/#conditional-reactions-the-mobx-when-pattern","title":"Conditional Reactions: The MobX <code>when</code> Pattern","text":"<p>Here's where things get powerful. You can combine observables with logical operators to create conditional reactions that only fire when specific conditions are met:</p> <pre><code>is_logged_in = observable(False)\nhas_data = observable(False)\nis_loading = observable(True)\nshould_sync = observable(False)\n\n# React only when logged in AND has data AND NOT loading OR should sync\n@reactive(is_logged_in &amp; has_data &amp; ~is_loading + should_sync)\ndef sync_to_server(should_run):\n    if should_run:\n        perform_sync()\n</code></pre> <p>The operators work as you'd expect:</p> <ul> <li><code>&amp;</code> is logical AND</li> <li><code>+</code> is logical OR</li> <li><code>~</code> is logical NOT (negation)</li> </ul> <p>These create composite observables that emit values based on boolean logic applied to their constituent observables. The critical insight: the reaction still follows the change-only semantics. Even if your condition is <code>True</code> at the moment you attach the reactive function, it won't fire until something changes and the condition is met.</p> <pre><code>logged_in = observable(True)\nverified = observable(True)\n\n# Even though both are already True, this doesn't fire yet\n@reactive(logged_in &amp; verified)\ndef enable_premium_features(both_true):\n    print(\"Premium features enabled\")\n\n# Nothing printed yet\n\nlogged_in.set(False)  # Condition now False, triggers reaction\n# Prints: \"Premium features enabled\" with value False\n\nverified.set(False)  # Both False, triggers reaction\n# Prints: \"Premium features enabled\" with value False\n\nlogged_in.set(True)  # One is True, one is False, triggers reaction\n# Prints: \"Premium features enabled\" with value False\n\nverified.set(True)  # Both True now, triggers reaction\n# Prints: \"Premium features enabled\" with value True\n</code></pre> <p>This mirrors MobX's <code>when</code> behavior, but with more compositional flexibility. You're not limited to simple conditions\u2014you can build arbitrarily complex boolean expressions that describe exactly when your side effect should consider running.</p>"},{"location":"reference/reactive-decorator/#multiple-dependencies-without-conditions","title":"Multiple Dependencies Without Conditions","text":"<p>Sometimes you just want a reaction to fire whenever any of several observables change, without boolean logic:</p> <pre><code>name = observable(\"Alice\")\nage = observable(30)\n\n# Derive a combined observable first\nfull_name = (name + age) &gt;&gt; (lambda n, a: f\"{n} ({a} years old)\")\n\n# Then react to changes in the derivation\n@reactive(full_name)\ndef update_display(display_name):\n    print(f\"Display: {display_name}\")\n\nname.set(\"Bob\")  # Triggers with \"Bob (30 years old)\"\nage.set(31)      # Triggers with \"Bob (31 years old)\"\n</code></pre> <p>Notice the pattern: derive first, react second. The <code>+</code> operator here isn't doing boolean OR\u2014it's combining observables into a tuple-like stream. The <code>&gt;&gt;</code> operator then transforms that stream. Only after you've created a derived observable do you attach the reaction.</p>"},{"location":"reference/reactive-decorator/#the-core-insight-where-reactive-belongs","title":"The Core Insight: Where @reactive Belongs","text":"<p>Here's the fundamental principle that makes reactive systems maintainable: <code>@reactive</code> is for side effects, not for deriving state.</p> <p>When you're tempted to use <code>@reactive</code>, ask yourself: \"Am I computing a new value from existing data, or am I sending information outside my application?\" If you're computing, you want <code>&gt;&gt;</code> or <code>+</code> operators. If you're communicating with the outside world, you want <code>@reactive</code>.</p> <p>This distinction creates what we call the \"functional core, reactive shell\" pattern. Your core is pure transformations\u2014testable, predictable, composable. Your shell is reactions\u2014the unavoidable side effects that make your application actually do something.</p> <p>Let's see this in a real example:</p> <pre><code># ===== FUNCTIONAL CORE (Pure) =====\nclass OrderCore(Store):\n    items = observable([])\n    shipping_address = observable(None)\n    payment_method = observable(None)\n    is_processing = observable(False)\n\n    # Pure derivations\u2014no side effects anywhere\n    subtotal = items &gt;&gt; (lambda i: sum(x['price'] * x['qty'] for x in i))\n    has_items = items &gt;&gt; (lambda i: len(i) &gt; 0)\n    has_address = shipping_address &gt;&gt; (lambda a: a is not None)\n    has_payment = payment_method &gt;&gt; (lambda p: p is not None)\n\n    # Boolean logic for conditions\n    can_checkout = (has_items &amp; has_address &amp; has_payment &amp; ~is_processing) &gt;&gt; (lambda x: x)\n\n    tax = subtotal &gt;&gt; (lambda s: s * 0.08)\n    total = (subtotal + tax) &gt;&gt; (lambda s, t: s + t)\n\n# ===== REACTIVE SHELL (Impure) =====\n@reactive(OrderCore.can_checkout)\ndef update_checkout_button(can_checkout):\n    button.disabled = not can_checkout\n\n@reactive(OrderCore.total)\ndef update_display(total):\n    render_total(f\"${total:.2f}\")\n\n# Only auto-save when we have items and aren't processing\n@reactive(OrderCore.has_items &amp; ~OrderCore.is_processing)\ndef auto_save(should_save):\n    if should_save:\n        save_to_db(OrderCore.to_dict())\n</code></pre> <p>Notice how the core is entirely composed of derivations\u2014values computed from other values. No database calls, no DOM manipulation, no network requests. These pure transformations are easy to test, easy to understand, and easy to change.</p> <p>The reactions appear only at the boundary. They're where your perfect functional world meets reality: updating a button's state, rendering to the screen, persisting to a database. The conditional operators let you express exactly when these side effects should occur, without polluting your core logic.</p>"},{"location":"reference/reactive-decorator/#the-trap-of-clever-reactions","title":"The Trap of Clever Reactions","text":"<p>The biggest pitfall with <code>@reactive</code> is trying to be too clever. Three patterns consistently cause problems:</p> <p>The infinite loop. When a reaction modifies what it's watching, you've created a feedback cycle:</p> <pre><code>count = observable(0)\n\n@reactive(count)\ndef increment_forever(value):\n    count.set(value + 1)  # Every change triggers another change\n</code></pre> <p>This is obvious in toy examples but can hide in real code when the dependency is indirect. The change semantics don't save you here\u2014each change triggers the reaction, which causes another change, ad infinitum.</p> <p>The hidden cache. When reactions maintain their own state, you've split your application's state across two systems:</p> <pre><code>results_cache = {}\n\n@reactive(query)\ndef update_cache(query_string):\n    results_cache[query_string] = fetch_results(query_string)\n</code></pre> <p>Now you have to remember that <code>results_cache</code> exists and keep it synchronized. Better to make the cache itself observable and derive from it.</p> <p>The sequential assumption. When reactions depend on each other's execution order, you've created fragile coupling:</p> <pre><code>shared_list = []\n\n@reactive(data)\ndef reaction_one(value):\n    shared_list.append(value)\n\n@reactive(data)\ndef reaction_two(value):\n    # Assumes reaction_one has already run\n    print(f\"List has {len(shared_list)} items\")\n</code></pre> <p>The second reaction assumes the first has already run. But that's an implementation detail, not a guarantee. If execution order changes, your code breaks silently.</p> <p>The fix for all three is the same: keep reactions independent and stateless. Let the observable system coordinate state. Keep reactions purely about effects.</p>"},{"location":"reference/reactive-decorator/#advanced-patterns-conditional-guards-and-cleanup","title":"Advanced Patterns: Conditional Guards and Cleanup","text":"<p>The conditional operators shine when you need to guard expensive or sensitive operations:</p> <pre><code>user = observable(None)\nhas_permission = observable(False)\nis_online = observable(False)\n\n# Only sync when user is logged in, has permission, and is online\n@reactive(user &amp; has_permission &amp; is_online)\ndef sync_sensitive_data(should_sync):\n    if should_sync and user.get():\n        api.sync_user_data(user.get().id)\n\n# Later, when you want to stop syncing entirely:\nsync_sensitive_data.unsubscribe()\n</code></pre> <p>The unsubscribe mechanism becomes particularly important in cleanup scenarios. If your reactive function represents a resource that needs explicit teardown (like a WebSocket connection or a file handle), you can unsubscribe when you're done to prevent further reactions and then perform cleanup in the function itself.</p>"},{"location":"reference/reactive-decorator/#store-level-reactions","title":"Store-Level Reactions","text":"<p>Stores collect related observables, and you can react to derived properties on stores just like standalone observables:</p> <pre><code>class UserStore(Store):\n    name = observable(\"Alice\")\n    age = observable(30)\n    is_active = observable(True)\n\n    user_summary = (name + age) &gt;&gt; (lambda n, a: f\"{n}, {a}\")\n    should_display = is_active &amp; (age &gt;&gt; (lambda a: a &gt;= 18))\n\n@reactive(UserStore.user_summary)\ndef sync_to_server(summary):\n    api.post('/user/update', {'summary': summary})\n\n@reactive(UserStore.should_display)\ndef toggle_profile_visibility(should_show):\n    profile_element.visible = should_show\n\nUserStore.name = \"Bob\"  # Triggers first reaction\nUserStore.age = 31      # Triggers both reactions\nUserStore.is_active = False  # Triggers second reaction only\n</code></pre> <p>The store becomes your functional core. The reactions watching it become your shell. This separation makes testing straightforward\u2014test the store logic in isolation, mock the side effects in the reactions.</p> <p>The Big Picture: Use <code>@reactive</code> sparingly. Most of your code should be pure derivations using <code>&gt;&gt;</code>, <code>+</code>, <code>&amp;</code>, and <code>~</code>. Reactions appear only at the edges, where your application must interact with something external. The conditional operators let you express exactly when these interactions should happen without mixing conditions into your business logic. When you find yourself reaching for <code>@reactive</code>, pause and ask: \"Is this really a side effect, or am I just deriving new state?\" That question alone will guide you toward cleaner, more maintainable reactive systems.</p>"},{"location":"reference/reactive-decorator/#fynx.reactive.ReactiveFunctionWasCalled","title":"ReactiveFunctionWasCalled","text":"<p>Raised when a reactive function is called manually instead of through reactive triggers.</p> <p>Reactive functions are designed to run automatically when their observable dependencies change. Manually calling them mixes reactive and imperative paradigms and should be avoided.</p> <p>Instead of calling reactive functions directly, modify the observable values that trigger them.</p>"},{"location":"reference/reactive-decorator/#fynx.reactive.ReactiveWrapper","title":"ReactiveWrapper","text":"<pre><code>ReactiveWrapper(func, targets)\n</code></pre> <p>Wraps a reactive function and manages its subscription lifecycle.</p> <p>This wrapper acts like the original function but prevents manual calls while subscribed. After unsubscribe(), it becomes a normal function again.</p> <p>Initialize the wrapper with the function and its reactive targets.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable</code> <p>The original function to wrap</p> required <code>targets</code> <code>tuple</code> <p>Tuple of observables/stores to react to</p> required"},{"location":"reference/reactive-decorator/#fynx.reactive.ReactiveWrapper.__call__","title":"__call__","text":"<pre><code>__call__(*args, **kwargs)\n</code></pre> <p>Call the wrapped function, raising an error if still subscribed.</p>"},{"location":"reference/reactive-decorator/#fynx.reactive.ReactiveWrapper.unsubscribe","title":"unsubscribe","text":"<pre><code>unsubscribe()\n</code></pre> <p>Unsubscribe from all reactive targets, making this a normal function again.</p>"},{"location":"reference/reactive-decorator/#fynx.reactive.reactive","title":"reactive","text":"<pre><code>reactive(*targets)\n</code></pre> <p>Create a reactive handler that works as a decorator.</p> <p>This is a convenience wrapper around subscribe() that works as a decorator.</p> As decorator <p>@reactive(store) - reacts to all observables in store @reactive(observable) - reacts to single observable @reactive(obs1, obs2, ...) - reacts to multiple observables</p> <p>Parameters:</p> Name Type Description Default <code>*targets</code> <p>Store class, Observable instance(s), or multiple Observable instances</p> <code>()</code> <p>Returns:</p> Type Description <p>ReactiveWrapper instance that acts like the original function</p>"},{"location":"reference/store/","title":"Store Class","text":"<p>Container class for grouping observables and managing reactive state.</p>"},{"location":"reference/store/#fynx.store--fynx-store-reactive-state-management-components","title":"FynX Store - Reactive State Management Components","text":"<p>This module provides the core components for reactive state management in FynX, enabling you to create organized, reactive state containers that group related observables together with convenient subscription and state management methods.</p>"},{"location":"reference/store/#fynx.store--why-use-stores","title":"Why Use Stores?","text":"<p>Stores help you organize your application's reactive state into logical units. Instead of having observables scattered throughout your codebase, Stores group related data together and provide convenient methods for subscribing to changes, serializing state, and managing the reactive lifecycle.</p> <p>Stores are particularly useful for: - Application State: Global app state like user preferences, theme settings - Feature State: State for specific features like shopping cart, user profile - Component State: Local state that needs to be shared across multiple components - Business Logic: Computed values and derived state based on raw data</p>"},{"location":"reference/store/#fynx.store--core-components","title":"Core Components","text":"<p>Store: A base class for creating reactive state containers. Store classes can define observable attributes using the <code>observable()</code> descriptor, and automatically provide methods for subscribing to changes and managing state.</p> <p>observable: A descriptor function that creates observable attributes on Store classes. Use this to define reactive properties in your Store subclasses.</p> <p>StoreSnapshot: An immutable snapshot of store state at a specific point in time, useful for debugging, logging, and ensuring consistent state access.</p> <p>StoreMeta: A metaclass that automatically converts observable attributes to descriptors and provides type hint compatibility for mypy.</p>"},{"location":"reference/store/#fynx.store--key-features","title":"Key Features","text":"<ul> <li>Automatic Observable Management: Store metaclass handles observable creation</li> <li>Convenient Subscriptions: Subscribe to all changes or individual observables</li> <li>State Serialization: Save and restore store state with <code>to_dict()</code> and <code>load_state()</code></li> <li>Type Safety: Full type hint support for better IDE experience</li> <li>Memory Efficient: Automatic cleanup and efficient change detection</li> <li>Composable: Easy to combine and nest multiple stores</li> </ul>"},{"location":"reference/store/#fynx.store--basic-usage","title":"Basic Usage","text":"<pre><code>from fynx import Store, observable\n\nclass CounterStore(Store):\n    count = observable(0)\n    name = observable(\"My Counter\")\n\n# Access values like regular attributes\nprint(CounterStore.count)  # 0\nCounterStore.count = 5     # Updates the observable\n\n# Subscribe to all changes in the store\n@CounterStore.subscribe\ndef on_store_change(snapshot):\n    print(f\"Store changed: count={snapshot.count}, name={snapshot.name}\")\n\nCounterStore.count = 10  # Triggers: \"Store changed: count=10, name=My Counter\"\n</code></pre>"},{"location":"reference/store/#fynx.store--advanced-patterns","title":"Advanced Patterns","text":""},{"location":"reference/store/#fynx.store--computed-properties-in-stores","title":"Computed Properties in Stores","text":"<pre><code>from fynx import Store, observable\n\nclass UserStore(Store):\n    first_name = observable(\"John\")\n    last_name = observable(\"Doe\")\n    age = observable(30)\n\n    # Computed properties using the &gt;&gt; operator\n    full_name = (first_name + last_name) &gt;&gt; (\n        lambda fname, lname: f\"{fname} {lname}\"\n    )\n\n    is_adult = age &gt;&gt; (lambda a: a &gt;= 18)\n\nprint(UserStore.full_name)  # \"John Doe\"\nUserStore.first_name = \"Jane\"\nprint(UserStore.full_name)  # \"Jane Doe\" (automatically updated)\n</code></pre>"},{"location":"reference/store/#fynx.store--state-persistence","title":"State Persistence","text":"<pre><code># Save store state\nstate = CounterStore.to_dict()\n# state = {\"count\": 10, \"name\": \"My Counter\"}\n\n# Restore state later\nCounterStore.load_state(state)\nprint(CounterStore.count)  # 10\n</code></pre>"},{"location":"reference/store/#fynx.store--store-composition","title":"Store Composition","text":"<pre><code>class AppStore(Store):\n    theme = observable(\"light\")\n    language = observable(\"en\")\n\nclass UserStore(Store):\n    name = observable(\"Alice\")\n    preferences = observable({})\n\n# Use both stores independently\nAppStore.theme = \"dark\"\nUserStore.name = \"Bob\"\n</code></pre>"},{"location":"reference/store/#fynx.store--common-patterns","title":"Common Patterns","text":"<p>Singleton Stores: Use class-level access for global state:</p> <pre><code>class GlobalStore(Store):\n    is_loading = observable(False)\n    current_user = observable(None)\n\n# Access globally\nGlobalStore.is_loading = True\n</code></pre> <p>```</p>"},{"location":"reference/store/#fynx.store--see-also","title":"See Also","text":"<ul> <li><code>fynx.observable</code>: Core observable classes and operators</li> <li><code>fynx.computed</code>: Creating computed properties</li> <li><code>fynx.reactive</code>: Reactive decorators for side effects</li> <li><code>fynx.watch</code>: Conditional reactive functions</li> </ul>"},{"location":"reference/store/#fynx.store.Store","title":"Store","text":"<p>Base class for reactive state containers with observable attributes.</p> <p>Store provides a convenient way to group related observable values together and manage their lifecycle as a cohesive unit. Store subclasses can define observable attributes using the <code>observable()</code> descriptor, and Store provides methods for subscribing to changes, serializing state, and managing the reactive relationships.</p> <p>Key Features: - Automatic observable attribute detection and management - Convenient subscription methods for reacting to state changes - Serialization/deserialization support for persistence - Snapshot functionality for debugging and state inspection</p> Example <pre><code>from fynx import Store, observable\n\nclass CounterStore(Store):\n    count = observable(0)\n    name = observable(\"Counter\")\n\n# Subscribe to all changes\n@CounterStore.subscribe\ndef on_change(snapshot):\n    print(f\"Counter: {snapshot.count}, Name: {snapshot.name}\")\n\n# Changes trigger reactions\nCounterStore.count = 5  # Prints: Counter: 5, Name: Counter\nCounterStore.name = \"My Counter\"  # Prints: Counter: 5, Name: My Counter\n</code></pre> Note <p>Store uses a metaclass to intercept attribute assignment, allowing <code>Store.attr = value</code> syntax to work seamlessly with observables.</p>"},{"location":"reference/store/#fynx.store.Store.load_state","title":"load_state","text":"<pre><code>load_state(state_dict)\n</code></pre> <p>Load state from a dictionary into the store's observables.</p>"},{"location":"reference/store/#fynx.store.Store.subscribe","title":"subscribe","text":"<pre><code>subscribe(func)\n</code></pre> <p>Subscribe a function to react to all observable changes in the store.</p>"},{"location":"reference/store/#fynx.store.Store.to_dict","title":"to_dict","text":"<pre><code>to_dict()\n</code></pre> <p>Serialize all observable values to a dictionary.</p>"},{"location":"reference/store/#fynx.store.Store.unsubscribe","title":"unsubscribe","text":"<pre><code>unsubscribe(func)\n</code></pre> <p>Unsubscribe a function from all observables.</p>"},{"location":"reference/store/#fynx.store.StoreMeta","title":"StoreMeta","text":"<p>Metaclass for Store to automatically convert observable attributes to descriptors and adjust type hints for mypy compatibility.</p>"},{"location":"reference/store/#fynx.store.StoreMeta.__setattr__","title":"__setattr__","text":"<pre><code>__setattr__(name, value)\n</code></pre> <p>Intercept class attribute assignment for observables.</p>"},{"location":"reference/store/#fynx.store.StoreSnapshot","title":"StoreSnapshot","text":"<pre><code>StoreSnapshot(store_class, observable_attrs)\n</code></pre> <p>Immutable snapshot of store observable values at a specific point in time.</p>"},{"location":"reference/store/#fynx.store.StoreSnapshot.__getattr__","title":"__getattr__","text":"<pre><code>__getattr__(name)\n</code></pre> <p>Access snapshot values or fall back to class attributes.</p>"},{"location":"reference/store/#fynx.store.observable","title":"observable","text":"<pre><code>observable(initial_value=None)\n</code></pre> <p>Create an observable with an initial value, used as a descriptor in Store classes.</p>"},{"location":"tutorial/conditionals/","title":"Conditionals: Filtering and Logic on Observables","text":"<p>Observables track changes, and the <code>&gt;&gt;</code> operator transforms data. But what about controlling when data flows through your reactive system? What if you only want certain values to pass through?</p> <p>What if you only want to react when certain conditions are true? What if you want to combine multiple conditions? What if you need to filter out unwanted values?</p> <p>That's where FynX's conditional operators come in. They let you create observables that only produce values when conditions are met, filter data streams, and combine logical expressions.</p>"},{"location":"tutorial/conditionals/#the-problem-not-all-data-should-pass-through","title":"The Problem: Not All Data Should Pass Through","text":"<p>Consider this scenario:</p> <pre><code>temperature = observable(20)\nweather_alerts = []\n\n# You only want alerts when temperature is extreme\ntemperature.subscribe(lambda temp: {\n    if temp &gt; 30 or temp &lt; 0:\n        weather_alerts.append(f\"Temperature alert: {temp}\u00b0C\")\n})\n</code></pre> <p>This works, but it's verbose. You have to write filtering logic in every subscriber. The filtering is mixed with the reaction logic. And if multiple subscribers need the same filtering, you repeat yourself.</p>"},{"location":"tutorial/conditionals/#the-solution-conditional-observables","title":"The Solution: Conditional Observables","text":"<p>FynX gives you operators that create filtered, conditional observables. The insight: separate the condition logic from the filtering operation.</p> <pre><code>temperature = observable(20)\n\n# First, create a boolean observable representing the condition\nis_extreme = temperature &gt;&gt; (lambda temp: temp &gt; 30 or temp &lt; 0)\n\n# Then, filter the original observable based on that condition\nextreme_temps = temperature &amp; is_extreme\n\nextreme_temps.subscribe(lambda temp: {\n    print(f\"Temperature alert: {temp}\u00b0C\")\n})\n</code></pre> <p>Now the filtering is declarative and reusable. The <code>extreme_temps</code> observable only produces values when the condition is met.</p>"},{"location":"tutorial/conditionals/#the-operator-boolean-composition","title":"The &amp; Operator: Boolean Composition","text":"<p>The <code>&amp;</code> operator combines multiple boolean observables into compound boolean conditions. The result emits the source observable's value when ALL conditions are <code>True</code>, and does not emit when any condition becomes <code>False</code>:</p> <pre><code>from fynx import observable\n\nscores = observable(85)\n\n# Create a boolean condition observable\nis_high_score = scores &gt;&gt; (lambda score: score &gt; 90)\n\n# Filter the original scores based on the condition\nhigh_scores = scores &amp; is_high_score\n\nhigh_scores.subscribe(lambda score: {\n    print(f\"\ud83c\udf89 High score achieved: {score}\")\n})\n\nscores.set(88)  # No emission (condition became False)\nscores.set(95)  # Prints: \"\ud83c\udf89 High score achieved: 95\" (condition became True)\nscores.set(87)  # No emission (condition became False)\n</code></pre> <p>The <code>&amp;</code> operator creates a ConditionalObservable that only emits when conditions are met, making it ideal for reactive boolean logic and state management.</p>"},{"location":"tutorial/conditionals/#using-conditional-observables-with-reactive","title":"Using Conditional Observables with @reactive","text":"<p>The <code>&amp;</code> operator creates conditional observables that work perfectly with <code>@reactive</code> for event-driven reactions:</p> <pre><code>from fynx import observable, reactive\n\nscores = observable(85)\n\n# Create a boolean condition observable\nis_high_score = scores &gt;&gt; (lambda score: score &gt; 90)\n\n# Use with @reactive for event-driven reactions\n@reactive(is_high_score)\ndef on_high_score(is_high):\n    if is_high:\n        print(f\"\ud83c\udf89 High score achieved: {scores.value}\")\n\nscores.set(88)  # No output (condition not met)\nscores.set(95)  # Prints: \"\ud83c\udf89 High score achieved: 95\"\nscores.set(87)  # No output (condition no longer met)\n</code></pre> <p>This pattern gives you event-driven reactions while maintaining the reactive paradigm.</p>"},{"location":"tutorial/conditionals/#complex-predicates-with","title":"Complex Predicates with &amp;","text":"<p>Your condition functions can be as complex as needed with the <code>&amp;</code> operator:</p> <pre><code>user = observable({\"name\": \"Alice\", \"age\": 30, \"country\": \"US\"})\n\n# Complex validation logic as a boolean observable\nis_valid_user = user &gt;&gt; (lambda u: {\n    u[\"age\"] &gt;= 18 and\n    u[\"country\"] in [\"US\", \"CA\", \"UK\"] and\n    len(u[\"name\"]) &gt; 2 and\n    \"@\" not in u[\"name\"]  # No emails in names\n})\n\n# Create compound boolean condition with &amp; operator\nvalid_users = user &amp; is_valid_user\n\nvalid_users.subscribe(lambda user_data: {\n    if user_data is not None:\n        print(f\"\u2705 Valid user: {user_data['name']}\")\n    else:\n        print(\"\u274c User no longer valid\")\n})\n</code></pre> <p>The <code>&amp;</code> operator emits <code>None</code> when validation fails, allowing you to react to both valid and invalid states.</p>"},{"location":"tutorial/conditionals/#the-operator-logical-negation","title":"The ~ Operator: Logical Negation","text":"<p>The <code>~</code> operator inverts boolean conditions. It works on boolean observables:</p> <pre><code>is_online = observable(True)\n\n# Create a negated boolean observable\nis_offline = ~is_online\n\n# React when user goes offline (when is_offline becomes True)\noffline_events = is_offline\n\noffline_events.subscribe(lambda _: {\n    print(\"User went offline\")\n})\n\nis_online.set(False)  # is_offline becomes True, prints: \"User went offline\"\nis_online.set(True)   # is_offline becomes False, no output\n</code></pre>"},{"location":"tutorial/conditionals/#the-operator-logical-or","title":"The | Operator: Logical OR","text":"<p>The <code>|</code> operator creates logical OR conditions between boolean observables. It emits when ANY of the conditions is truthy:</p> <pre><code>is_error = observable(False)\nis_warning = observable(True)\nis_critical = observable(False)\n\n# Logical OR using | operator\nneeds_attention = is_error | is_warning | is_critical\n\n# Alternative using .either() method\nneeds_attention_alt = is_error.either(is_warning).either(is_critical)\n\nneeds_attention.subscribe(lambda needs_attention: {\n    if needs_attention:\n        print(\"\u26a0\ufe0f System needs attention!\")\n})\n\n# Updates automatically when any condition changes\nis_error.set(True)    # Prints: \"\u26a0\ufe0f System needs attention!\"\nis_warning.set(False) # Still prints (is_error is True)\nis_error.set(False)   # Still prints (is_critical is False, but was True initially)\n</code></pre> <p>The <code>|</code> operator creates conditional observables that only emit when the OR result is truthy. If the initial OR result is falsy, it raises <code>ConditionalNeverMet</code>.</p>"},{"location":"tutorial/conditionals/#combining-or-with-other-operators","title":"Combining OR with Other Operators","text":"<p>You can combine <code>|</code> with <code>&amp;</code> and <code>~</code> for complex logical expressions:</p> <pre><code>user_input = observable(\"\")\nis_admin = observable(False)\nis_moderator = observable(True)\n\n# Create boolean conditions\nhas_input = user_input &gt;&gt; (lambda u: len(u) &gt; 0)\nhas_permission = is_admin | is_moderator  # OR condition\nis_not_empty = has_input &amp; (lambda h: h == True)  # AND condition\n\n# Complex condition: user has input AND (is admin OR moderator)\ncan_submit = user_input &amp; has_input &amp; has_permission\n\ncan_submit.subscribe(lambda can_submit: {\n    if can_submit is not None:\n        print(\"\u2705 User can submit\")\n    else:\n        print(\"\u274c User cannot submit\")\n})\n\nuser_input.set(\"Hello\")  # Prints: \"\u2705 User can submit\"\nis_moderator.set(False)  # Prints: \"\u274c User cannot submit\" (no permission)\nis_admin.set(True)       # Prints: \"\u2705 User can submit\" (admin permission)\n</code></pre>"},{"location":"tutorial/conditionals/#combining-negation-with-filtering","title":"Combining Negation with Filtering","text":"<p>Create \"everything except\" patterns:</p> <pre><code>status = observable(\"loading\")\n\n# Create boolean condition for non-loading states\nis_not_loading = status &gt;&gt; (lambda s: s != \"loading\")\n\n# React to any status except \"loading\"\nnon_loading_status = status &amp; is_not_loading\n\nnon_loading_status.subscribe(lambda status_val: {\n    print(f\"Status changed to: {status_val}\")\n})\n\nstatus.set(\"loading\")    # No output (filtered out)\nstatus.set(\"success\")    # Prints: \"Status changed to: success\"\nstatus.set(\"error\")      # Prints: \"Status changed to: error\"\n</code></pre>"},{"location":"tutorial/conditionals/#real-world-example-form-validation","title":"Real-World Example: Form Validation","text":"<p>Form validation is perfect for conditional observables with the <code>&amp;</code> operator:</p> <pre><code>email = observable(\"\")\npassword = observable(\"\")\nterms_accepted = observable(False)\n\n# Validation conditions as boolean observables\nemail_valid = email &gt;&gt; (lambda e: \"@\" in e and \".\" in e.split(\"@\")[1])\npassword_strong = password &gt;&gt; (lambda p: len(p) &gt;= 8)\nterms_checked = terms_accepted &gt;&gt; (lambda t: t == True)\n\n# Form is valid only when all conditions are true\nform_valid = email &amp; email_valid &amp; password_strong &amp; terms_checked\n\nform_valid.subscribe(lambda is_valid: {\n    if is_valid is not None:\n        print(\"\u2705 Form is complete and valid!\")\n    else:\n        print(\"\u274c Form validation failed\")\n})\n\n# Simulate form filling\nemail.set(\"user@\")           # Prints: \"\u274c Form validation failed\" (email invalid)\npassword.set(\"pass\")         # Still invalid\nterms_accepted.set(True)     # Still invalid\n\nemail.set(\"user@example.com\")  # Still invalid (password too short)\npassword.set(\"secure123\")      # Prints: \"\u2705 Form is complete and valid!\"\npassword.set(\"short\")          # Prints: \"\u274c Form validation failed\" (password weak)\n</code></pre> <p>The <code>&amp;</code> operator emits <code>None</code> when validation fails, allowing you to handle both valid and invalid states in your UI.</p>"},{"location":"tutorial/conditionals/#advanced-patterns-state-machines-with-conditionals","title":"Advanced Patterns: State Machines with Conditionals","text":"<p>Build state machines using conditional logic:</p> <pre><code>app_state = observable(\"initializing\")\nuser_authenticated = observable(False)\ndata_loaded = observable(False)\n\n# Define state conditions as boolean observables\nis_app_ready = app_state &gt;&gt; (lambda s: s == \"ready\")\nis_user_auth = user_authenticated &gt;&gt; (lambda a: a == True)\nis_data_loaded = data_loaded &gt;&gt; (lambda d: d == True)\nis_app_error = app_state &gt;&gt; (lambda s: s == \"error\")\n\n# Combine conditions - app is ready when all are true\nready_state = app_state &amp; is_app_ready &amp; is_user_auth &amp; is_data_loaded\n\n# Error state\nerror_state = app_state &amp; is_app_error\n\n# React to state transitions\nready_state.subscribe(lambda _: {\n    print(\"\ud83d\ude80 Application is fully ready!\")\n})\n\nerror_state.subscribe(lambda _: {\n    print(\"\u274c Application encountered an error\")\n})\n\n# Simulate app lifecycle\napp_state.set(\"authenticating\")\nuser_authenticated.set(True)\napp_state.set(\"loading_data\")\ndata_loaded.set(True)\napp_state.set(\"ready\")  # Triggers \"fully ready\" message\n</code></pre>"},{"location":"tutorial/conditionals/#conditional-operators-with-derived-values","title":"Conditional Operators with Derived Values","text":"<p>Combine conditionals with the <code>&gt;&gt;</code> operator for powerful data processing:</p> <pre><code>sensor_readings = observable([])\n\n# Create condition for sufficient data\nhas_enough_data = sensor_readings &gt;&gt; (lambda readings: len(readings) &gt;= 3)\n\n# Only process readings when we have enough data\nvalid_readings = sensor_readings &amp; has_enough_data\n\n# Then calculate statistics\naverage_reading = valid_readings &gt;&gt; (lambda readings: sum(readings) / len(readings))\n\naverage_reading.subscribe(lambda avg: {\n    print(f\"Average sensor reading: {avg:.2f}\")\n})\n\nsensor_readings.set([1, 2])        # No output (not enough data)\nsensor_readings.set([1, 2, 3, 4])  # Prints: \"Average sensor reading: 2.50\"\n</code></pre>"},{"location":"tutorial/conditionals/#performance-benefits","title":"Performance Benefits","text":"<p>Conditional observables improve performance by:</p> <ol> <li>Reducing unnecessary computations - Only process data that meets criteria</li> <li>Filtering at the source - Don't pass unwanted data to subscribers</li> <li>Early termination - Stop reactive chains when conditions aren't met</li> </ol> <pre><code># Without conditionals - expensive operation runs on every change\nraw_data = observable(\"some data\")\nprocessed_data = raw_data &gt;&gt; (lambda d: expensive_cleanup(d))\nfinal_result = processed_data &gt;&gt; (lambda d: expensive_analysis(d))\n\n# With conditionals - expensive operations only run when needed\nclean_data = raw_data &amp; (lambda d: is_worth_processing(d))\nprocessed_data = clean_data &gt;&gt; (lambda d: expensive_cleanup(d))\nfinal_result = processed_data &gt;&gt; (lambda d: expensive_analysis(d))\n</code></pre>"},{"location":"tutorial/conditionals/#common-patterns","title":"Common Patterns","text":""},{"location":"tutorial/conditionals/#pattern-1-threshold-monitoring","title":"Pattern 1: Threshold Monitoring","text":"<pre><code>temperature = observable(20)\n\n# Create threshold conditions\nis_hot = temperature &gt;&gt; (lambda t: t &gt; 25)\nis_cold = temperature &gt;&gt; (lambda t: t &lt; 10)\n\n# Alert when temperature crosses thresholds\nhot_weather = temperature &amp; is_hot\ncold_weather = temperature &amp; is_cold\n\nhot_weather.subscribe(lambda t: print(f\"\ud83c\udf21\ufe0f Hot: {t}\u00b0C\"))\ncold_weather.subscribe(lambda t: print(f\"\ud83e\uddca Cold: {t}\u00b0C\"))\n</code></pre>"},{"location":"tutorial/conditionals/#pattern-2-data-quality-gates","title":"Pattern 2: Data Quality Gates","text":"<pre><code>api_response = observable(None)\n\n# Create validation condition\nis_valid_response = api_response &gt;&gt; (lambda resp: {\n    resp is not None and\n    resp.get(\"status\") == \"success\" and\n    resp.get(\"data\") is not None\n})\n\n# Only process successful responses with data\nvalid_responses = api_response &amp; is_valid_response\n\nvalid_responses.subscribe(lambda resp: {\n    process_data(resp[\"data\"])\n})\n</code></pre>"},{"location":"tutorial/conditionals/#pattern-3-feature-flags-with-conditions","title":"Pattern 3: Feature Flags with Conditions","text":"<pre><code>feature_enabled = observable(False)\nuser_premium = observable(False)\nexperiment_active = observable(True)\n\n# Create boolean conditions\nis_feature_on = feature_enabled &gt;&gt; (lambda e: e == True)\nis_premium_user = user_premium &gt;&gt; (lambda p: p == True)\nis_experiment_on = experiment_active &gt;&gt; (lambda a: a == True)\n\n# Feature is available only under specific conditions\ncan_use_feature = feature_enabled &amp; is_feature_on &amp; is_premium_user &amp; is_experiment_on\n\ncan_use_feature.subscribe(lambda _: {\n    enable_premium_feature()\n})\n</code></pre>"},{"location":"tutorial/conditionals/#gotchas-and-best-practices","title":"Gotchas and Best Practices","text":""},{"location":"tutorial/conditionals/#gotcha-1-condition-functions-run-frequently","title":"Gotcha 1: Condition Functions Run Frequently","text":"<pre><code># Bad - expensive condition runs on every change\nslow_condition = data &amp; (lambda d: expensive_validation(d))\n\n# Better - cache expensive conditions\nis_valid = data &gt;&gt; (lambda d: expensive_validation(d))\nvalid_data = is_valid &amp; (lambda v: v == True)\n</code></pre>"},{"location":"tutorial/conditionals/#gotcha-2-negation-can-be-confusing","title":"Gotcha 2: Negation Can Be Confusing","text":"<pre><code>flag = observable(True)\n\n# This creates an observable that emits when flag becomes False\nnot_flag = ~flag\n\n# But this doesn't do what you might expect\nwrong_not_flag = flag &amp; (lambda f: not f)  # Less clear than ~\n</code></pre>"},{"location":"tutorial/conditionals/#best-practice-keep-conditions-simple","title":"Best Practice: Keep Conditions Simple","text":"<pre><code># Good - simple, focused conditions\nis_adult = age &amp; (lambda a: a &gt;= 18)\nhas_permission = role &amp; (lambda r: r in [\"admin\", \"moderator\"])\n\n# Avoid - complex conditions\ncomplex_check = user &amp; (lambda u: {\n    u[\"age\"] &gt;= 18 and\n    u[\"role\"] in [\"admin\", \"moderator\"] and\n    u[\"verified\"] and\n    not u[\"banned\"]\n})\n</code></pre>"},{"location":"tutorial/conditionals/#best-practice-name-your-conditions","title":"Best Practice: Name Your Conditions","text":"<pre><code>def is_valid_email(email):\n    return \"@\" in email and \".\" in email.split(\"@\")[1]\n\ndef is_strong_password(pwd):\n    return len(pwd) &gt;= 8\n\n# Much clearer than inline lambdas\nemail_ok = email &amp; is_valid_email\npassword_ok = password &amp; is_strong_password\nform_valid = (email_ok &amp; (lambda _: True)) &amp; (password_ok &amp; (lambda _: True))\n</code></pre>"},{"location":"tutorial/conditionals/#the-big-picture","title":"The Big Picture","text":"<p>Conditionals transform your reactive system from \"process everything\" to \"process only what matters\":</p> <ul> <li><code>&amp;</code> operator: Filter data streams based on predicates</li> <li><code>|</code> operator: Create logical OR conditions between boolean observables</li> <li><code>~</code> operator: Invert boolean conditions</li> <li>Performance: Skip unnecessary computations</li> <li>Clarity: Separate filtering logic from reaction logic</li> <li>Composition: Combine conditions with other operators</li> </ul> <p>Think of conditionals as reactive filters. They let you create observables that only emit valuable data, reducing noise and improving performance. Combined with transformations (<code>&gt;&gt;</code>) and reactions (<code>@reactive</code>), they give you a complete toolkit for building sophisticated reactive applications.</p> <p>The next step is organizing these reactive pieces into reusable units called Stores\u2014the architectural pattern that brings everything together.</p>"},{"location":"tutorial/derived-observables/","title":"Transforming Data with <code>.then()</code> and <code>&gt;&gt;</code>","text":"<p>Observables hold reactive values, and conditionals filter them. But what truly unlocks FynX's power is transformation\u2014the ability to derive new values from existing ones automatically.</p> <p>FynX provides two ways to create derived observables: the <code>.then()</code> method and the <code>&gt;&gt;</code> operator. Both create computed observables that automatically stay in sync with their sources. When the source changes, the transformation function runs, and the derived observable updates.</p> <p>This is where reactive programming stops being about \"responding to changes\" and starts being about \"declaring relationships.\" You describe how values relate to each other, and FynX handles the synchronization.</p>"},{"location":"tutorial/derived-observables/#the-problem-manual-recalculation","title":"The Problem: Manual Recalculation","text":"<p>Consider a shopping cart where you need to calculate totals, taxes, and shipping:</p> <pre><code>cart_items = [{'name': 'Widget', 'price': 10, 'quantity': 2}]\ntax_rate = 0.08\nshipping_threshold = 50\n\n# Manual calculations\nsubtotal = sum(item['price'] * item['quantity'] for item in cart_items)\ntax = subtotal * tax_rate\nshipping = 0 if subtotal &gt;= shipping_threshold else 5.99\ntotal = subtotal + tax + shipping\n\nprint(f\"Subtotal: ${subtotal:.2f}\")\nprint(f\"Tax: ${tax:.2f}\")\nprint(f\"Shipping: ${shipping:.2f}\")\nprint(f\"Total: ${total:.2f}\")\n</code></pre> <p>Now add an item to the cart. You have to manually recalculate everything:</p> <pre><code>cart_items.append({'name': 'Gadget', 'price': 15, 'quantity': 1})\n\n# Recalculate everything again\nsubtotal = sum(item['price'] * item['quantity'] for item in cart_items)\ntax = subtotal * tax_rate\nshipping = 0 if subtotal &gt;= shipping_threshold else 5.99\ntotal = subtotal + tax + shipping\n\nprint(f\"Subtotal: ${subtotal:.2f}\")  # Have to remember to do this\nprint(f\"Tax: ${tax:.2f}\")          # Have to remember to do this\nprint(f\"Shipping: ${shipping:.2f}\") # Have to remember to do this\nprint(f\"Total: ${total:.2f}\")       # Have to remember to do this\n</code></pre> <p>Every time state changes, you have to remember to update all the derived values. Miss one and your display goes stale. This is the synchronization problem that plagues traditional applications.</p>"},{"location":"tutorial/derived-observables/#the-solution-declarative-derivation","title":"The Solution: Declarative Derivation","text":"<p>With FynX's <code>.then()</code> method and <code>&gt;&gt;</code> operator, you declare the relationships once:</p> <pre><code>from fynx import observable\n\ncart_items = observable([{'name': 'Widget', 'price': 10, 'quantity': 2}])\ntax_rate = observable(0.08)\nshipping_threshold = observable(50)\n\n# Define transformation functions\ndef calculate_subtotal(items):\n    return sum(item['price'] * item['quantity'] for item in items)\n\ndef calculate_tax(subtotal):\n    return subtotal * tax_rate.value\n\ndef calculate_shipping(subtotal):\n    return 0 if subtotal &gt;= shipping_threshold.value else 5.99\n\ndef calculate_total(subtotal, tax, shipping):\n    return subtotal + tax + shipping\n\n# Declarative transformations using .then()\nsubtotal = cart_items.then(calculate_subtotal)\ntax = subtotal.then(calculate_tax)\nshipping = subtotal.then(calculate_shipping)\ntotal = (subtotal + tax + shipping).then(calculate_total)\n\n# Subscribe to see results\ndef print_subtotal(s):\n    print(f\"Subtotal: ${s:.2f}\")\n\ndef print_tax(t):\n    print(f\"Tax: ${t:.2f}\")\n\ndef print_shipping(s):\n    print(f\"Shipping: ${s:.2f}\")\n\ndef print_total(t):\n    print(f\"Total: ${t:.2f}\")\n\nsubtotal.subscribe(print_subtotal)\ntax.subscribe(print_tax)\nshipping.subscribe(print_shipping)\ntotal.subscribe(print_total)\n\n# Now just change the source data\ncart_items.set(cart_items.value + [{'name': 'Gadget', 'price': 15, 'quantity': 1}])\n# All derived values update automatically!\n</code></pre> <p>You declare what each value means in terms of others. Changes propagate automatically. No manual recalculation. No stale data. No forgotten updates.</p>"},{"location":"tutorial/derived-observables/#how-then-and-work-function-application","title":"How <code>.then()</code> and <code>&gt;&gt;</code> Work: Function Application","text":"<p>Both <code>.then()</code> and <code>&gt;&gt;</code> create computed observables, but with slightly different syntax:</p> <ul> <li><code>.then()</code>: <code>source_observable.then(transformation_function)</code> - Method syntax</li> <li><code>&gt;&gt;</code>: <code>source_observable &gt;&gt; transformation_function</code> - Operator syntax</li> </ul> <p>Both approaches:</p> <ul> <li>Take the current value from the source observable</li> <li>Pass it to your transformation function immediately (eager evaluation)</li> <li>Wrap the result in a new observable</li> <li>Automatically re-run the transformation when the source changes</li> </ul> <pre><code>numbers = observable([1, 2, 3])\n\ndef sum_numbers(nums):\n    return sum(nums)\n\n# Both approaches work identically\ntotal_method = numbers.then(sum_numbers)  # Using .then()\ntotal_operator = numbers &gt;&gt; sum_numbers    # Using &gt;&gt;\n\n# Both total_method.value and total_operator.value are 6\n\n# Transformation re-runs when source changes\nnumbers.set([4, 5, 6])  # Both become 15\n</code></pre>"},{"location":"tutorial/derived-observables/#chaining-and-multiple-transformations","title":"Chaining and Multiple Transformations","text":"<p>Since both <code>.then()</code> and <code>&gt;&gt;</code> return new observables, you can chain transformations:</p> <pre><code>numbers = observable([1, 2, 3])\n\ndef sum_numbers(nums):\n    return sum(nums)\n\ndef format_total(total):\n    return f\"Total: {total}\"\n\n# Chain using .then()\ntotal_method = numbers.then(sum_numbers)\ndescription_method = total_method.then(format_total)\n\n# Chain using &gt;&gt; (more concise)\ndescription_operator = numbers &gt;&gt; sum_numbers &gt;&gt; format_total\n\ndescription_method.subscribe(print)\ndescription_operator.subscribe(print)\n\nnumbers.set([4, 5, 6])\n# Both print: \"Total: 15\"\n</code></pre>"},{"location":"tutorial/derived-observables/#function-signatures","title":"Function Signatures","text":"<p>Your transformation functions receive the source observable's value as their first argument:</p> <pre><code># Single observable transformation\nname = observable(\"alice\")\n\ndef create_greeting(n):\n    return f\"Hello, {n.title()}!\"\n\ngreeting_method = name.then(create_greeting)\ngreeting_operator = name &gt;&gt; create_greeting\n\n# Multiple observables (using + first)\nfirst = observable(\"John\")\nlast = observable(\"Doe\")\n\ndef combine_names(first_name, last_name):\n    return f\"{first_name} {last_name}\"\n\nfull_name_method = (first + last).then(combine_names)\nfull_name_operator = (first + last) &gt;&gt; combine_names\n</code></pre>"},{"location":"tutorial/derived-observables/#return-values","title":"Return Values","text":"<p>Your functions can return anything\u2014a number, string, list, dictionary, even another observable:</p> <pre><code>data = observable({'users': [{'name': 'Alice'}, {'name': 'Bob'}]})\n\ndef extract_user_count(d):\n    return len(d['users'])\n\ndef extract_user_names(d):\n    return [u['name'] for u in d['users']]\n\ndef create_count_observable(d):\n    return observable(len(d['users']))\n\n# Extract user count\nuser_count = data.then(extract_user_count)\n\n# Extract user names\nuser_names = data.then(extract_user_names)\n\n# Create a derived observable\nuser_count_obs = data.then(create_count_observable)\n</code></pre>"},{"location":"tutorial/derived-observables/#chaining-transformations","title":"Chaining Transformations","text":"<p>Since both <code>.then()</code> and <code>&gt;&gt;</code> return new observables, you can chain transformations:</p> <pre><code>raw_data = observable([1, 2, 3, None, 4, None])\n\ndef filter_none(data):\n    return [x for x in data if x is not None]\n\ndef filter_positive(clean):\n    return [x for x in clean if x &gt; 0]\n\ndef sum_values(filtered):\n    return sum(filtered)\n\ndef format_result(total):\n    return f\"Total: {total}\"\n\n# Chain using .then() - explicit and readable\nresult_method = (raw_data\n    .then(filter_none)      # Filter out None\n    .then(filter_positive)  # Filter positive\n    .then(sum_values)       # Sum\n    .then(format_result))   # Format\n\n# Chain using &gt;&gt; - more concise\nresult_operator = (raw_data\n    &gt;&gt; filter_none\n    &gt;&gt; filter_positive\n    &gt;&gt; sum_values\n    &gt;&gt; format_result)\n\nresult_method.subscribe(print)\nresult_operator.subscribe(print)\n\nraw_data.set([5, None, -1, 10])\n# Both print: \"Total: 15\"\n</code></pre> <p>Each step in the chain is reactive. Change the input and the entire pipeline recalculates automatically.</p>"},{"location":"tutorial/derived-observables/#combining-with-other-operators","title":"Combining with Other Operators","text":"<p>Both <code>.then()</code> and <code>&gt;&gt;</code> work beautifully with FynX's other operators:</p> <pre><code>prices = observable([10, 20, 30])\ndiscount_rate = observable(0.1)\n\ndef calculate_discounted_total(prices_and_rate):\n    prices, rate = prices_and_rate\n    return sum(price * (1 - rate) for price in prices)\n\ndef is_expensive(total):\n    return total &gt; 50\n\ndef format_expensive_message(total_and_is_expensive):\n    total, is_exp = total_and_is_expensive\n    return f\"High-value order: ${total:.2f}\"\n\n# Use + to combine, then transform\ndiscounted_total_method = (prices + discount_rate).then(calculate_discounted_total)\ndiscounted_total_operator = (prices + discount_rate) &gt;&gt; calculate_discounted_total\n\n# Use &amp; for conditions, then format\nis_expensive_method = discounted_total_method.then(is_expensive)\nis_expensive_operator = discounted_total_method &gt;&gt; is_expensive\n\nexpensive_message_method = (discounted_total_method + is_expensive_method).then(format_expensive_message)\nexpensive_message_operator = (discounted_total_method + is_expensive_operator) &gt;&gt; format_expensive_message\n</code></pre>"},{"location":"tutorial/derived-observables/#performance-characteristics","title":"Performance Characteristics","text":"<p>Derived observables are lazy and efficient:</p> <ul> <li>Memoization: Results are cached until source values change</li> <li>Selective Updates: Only recalculates when dependencies actually change</li> <li>No Redundant Work: If a transformation result hasn't changed, downstream observers don't re-run</li> </ul> <pre><code>def slow_computation(data):\n    # Simulate expensive operation\n    time.sleep(0.1)\n    return data * 2\n\n# This transformation only runs when expensive_data changes\nexpensive_result_method = expensive_data.then(slow_computation)\nexpensive_result_operator = expensive_data &gt;&gt; slow_computation\n\n# If expensive_data stays the same, slow_computation doesn't re-run\nexpensive_data.set(same_value)  # No recalculation\n</code></pre>"},{"location":"tutorial/derived-observables/#error-handling-in-transformations","title":"Error Handling in Transformations","text":"<p>Transformations can fail. FynX evaluates transformations eagerly when they're created, so errors in your transformation functions will be thrown immediately:</p> <pre><code>data = observable({'value': 42})\n\ndef access_missing_key(d):\n    return d['missing_key'] * 2  # KeyError here!\n\n# This will throw a KeyError immediately when the transformation is created\nresult_method = data.then(access_missing_key)  # KeyError!\nresult_operator = data &gt;&gt; access_missing_key   # KeyError!\n</code></pre> <p>Handle errors by ensuring your data is in the expected format before creating transformations, or by transforming the data to a safe format first.</p>"},{"location":"tutorial/derived-observables/#when-to-use-value-and-when-not-to","title":"When to Use <code>.value</code> (and When Not To)","text":"<p>Understanding when to access <code>.value</code> versus passing the observable itself is crucial for writing effective reactive code.</p> <p>Use <code>.value</code> when you need the actual data for immediate use:</p> <pre><code>name = observable(\"alice\")\nage = observable(30)\n\n# Reading for immediate use\nprint(f\"Current user: {name.value}, age {age.value}\")\n\n# Passing to non-reactive functions\nresult = some_function(name.value, age.value)\n\n# Conditionals based on current state\nif age.value &gt;= 18:\n    print(\"Adult user\")\n</code></pre> <p>When you access <code>.value</code>, you're saying \"I need this data right now for a calculation or decision.\" This is perfect for one-time reads, immediate computations, or interfacing with code that doesn't understand observables.</p> <p>Don't use <code>.value</code> when building reactive relationships:</p> <pre><code># Bad: Reads .value immediately, loses reactivity\ntotal = items.value.reduce(sum)  # Just a number, won't update\n\n# Good: Keeps reactivity by transforming the observable\ndef sum_items(item_list):\n    return sum(item_list)\n\ntotal_method = items.then(sum_items)  # Updates when items changes\ntotal_operator = items &gt;&gt; sum_items   # Updates when items changes\n</code></pre> <p>The moment you call <code>.value</code>, you extract the data and break the reactive chain. If you're building something that should update automatically when the source changes, work with the observable itself, not its value.</p> <p>Pass observables to reactive operators:</p> <pre><code># These operators expect observables, not values\ndef double_count(c):\n    return c * 2\n\nderived_method = count.then(double_count)  # Pass count, not count.value\nderived_operator = count &gt;&gt; double_count   # Pass count, not count.value\nmerged = first_name + last_name            # Pass observables, not .value\nfiltered = items &amp; is_valid                # Pass observables, not .value\n</code></pre> <p>The operators (<code>.then()</code>, <code>&gt;&gt;</code>, <code>+</code>, <code>&amp;</code>, <code>~</code>) are designed to work with observables and maintain reactivity. When you pass <code>.value</code> to them, you're passing a static snapshot instead of a reactive stream.</p> <p>Inside subscribers and reactive functions, <code>.value</code> is fine:</p> <pre><code>counter = observable(0)\n\ndef print_count(count):\n    print(f\"Count: {count}\")\n\n# The function receives the value directly as an argument\ncounter.subscribe(print_count)\n\ndef print_double_count_and_age(count):\n    print(f\"Double count: {count}, Age: {age.value}\")\n\n# But if you need to read OTHER observables inside, use .value\ncounter.subscribe(print_double_count_and_age)\n</code></pre> <p>When your function is already being called reactively (through a subscription or decorator), using <code>.value</code> inside it to read other observables is perfectly appropriate. You're already in a reactive context.</p> <p>Rule of thumb: If you want something to update automatically when the observable changes, don't use <code>.value</code>. If you just need to read the current value for immediate use, <code>.value</code> is correct.</p>"},{"location":"tutorial/derived-observables/#observable-mutation-detection","title":"Observable Mutation Detection","text":"<p>FynX can't automatically detect changes to the contents of observables:</p> <pre><code>items = observable([1, 2, 3])\n\n# This does NOT trigger subscribers\nitems.value.append(4)\n\n# You must explicitly call .set()\nitems.set(items.value + [4])  # This DOES trigger subscribers\n</code></pre> <p>FynX can't detect mutations to the objects inside observables. When you modify a list, dictionary, or custom object in place, subscribers won't know. You must call <code>.set()</code> with the updated value\u2014even if it's the same object reference\u2014to trigger reactivity.</p>"},{"location":"tutorial/derived-observables/#external-state-dependencies","title":"External State Dependencies","text":"<p>Derived observables don't track external variables:</p> <pre><code>external_multiplier = 2\n\ncounter = observable(0)\n\ndef multiply_by_external(c):\n    return c * external_multiplier\n\n# This depends on external_multiplier, but FynX doesn't know\ndoubled_method = counter.then(multiply_by_external)\ndoubled_operator = counter &gt;&gt; multiply_by_external\n\nexternal_multiplier = 3\ncounter.set(5)  # Still uses old multiplier value (2), result = 10\n</code></pre> <p>If your transformation depends on variables outside the observable, FynX won't track those dependencies. Keep all reactive state inside observables for predictable behavior.</p>"},{"location":"tutorial/derived-observables/#best-practices-for-transformations","title":"Best Practices for Transformations","text":""},{"location":"tutorial/derived-observables/#1-keep-transformations-pure","title":"1. Keep Transformations Pure","text":"<pre><code># Good - Pure function, same input always gives same output\ndef to_uppercase(n):\n    return n.upper()\n\nuppercase_method = name.then(to_uppercase)\nuppercase_operator = name &gt;&gt; to_uppercase\n\n# Avoid - Impure function, depends on external state\nimport random\n\ndef random_case(n):\n    return n.upper() if random.random() &gt; 0.5 else n.lower()\n\nrandom_case_method = name.then(random_case)  # Unpredictable\nrandom_case_operator = name &gt;&gt; random_case   # Unpredictable\n</code></pre> <p>Pure functions make your reactive system predictable and testable.</p>"},{"location":"tutorial/derived-observables/#2-handle-edge-cases","title":"2. Handle Edge Cases","text":"<pre><code># Good - Handles empty lists gracefully\ndef safe_average(nums):\n    return sum(nums) / len(nums) if nums else 0\n\naverage_method = numbers.then(safe_average)\naverage_operator = numbers &gt;&gt; safe_average\n\n# Avoid - Will crash on empty list\ndef unsafe_average(nums):\n    return sum(nums) / len(nums)\n\nunsafe_method = numbers.then(unsafe_average)  # Crashes on empty list\nunsafe_operator = numbers &gt;&gt; unsafe_average   # Crashes on empty list\n</code></pre> <p>Defensive programming prevents runtime errors in your reactive pipelines.</p>"},{"location":"tutorial/derived-observables/#3-name-your-transformations","title":"3. Name Your Transformations","text":"<pre><code># Clear intent\ndef calculate_age(date):\n    return (datetime.now() - date).days // 365\n\ndef is_adult(age):\n    return age &gt;= 18\n\nuser_age_method = birth_date.then(calculate_age)\nuser_age_operator = birth_date &gt;&gt; calculate_age\n\nis_adult_method = user_age_method.then(is_adult)\nis_adult_operator = user_age_operator &gt;&gt; is_adult\n\neligible_for_voting = is_adult_method &amp; has_citizenship\n\n# Unclear intent\ndef transform(d):\n    return calculate_age(d)\n\ndef filter_age(age):\n    return age &gt;= 18\n\ntransformed_method = birth_date.then(transform)\nfiltered_method = transformed_method.then(filter_age)\n</code></pre> <p>Descriptive names make your reactive graphs self-documenting.</p>"},{"location":"tutorial/derived-observables/#4-avoid-deep-nesting","title":"4. Avoid Deep Nesting","text":"<pre><code># Good - Break complex transformations into steps\ndef extract_user_data(response):\n    return response['user']\n\ndef extract_user_age(user_data):\n    return user_data['age']\n\ndef is_adult(age):\n    return age &gt;= 18\n\n# Each of these are identical\nuser_data_method = api_response.then(extract_user_data)\nuser_data_operator = api_response &gt;&gt; extract_user_data\n\nuser_age_method = user_data_method.then(extract_user_age)\nuser_age_operator = user_data_operator &gt;&gt; extract_user_age\n\nis_adult_method = user_age_method.then(is_adult)\nis_adult_operator = user_age_operator &gt;&gt; is_adult\n\n# Avoid - Hard to debug and modify\ndef complex_extraction(response):\n    return response['user']['age'] &gt;= 18\n\ncomplex_method = api_response.then(complex_extraction)\ncomplex_operator = api_response &gt;&gt; complex_extraction\n</code></pre> <p>Small, focused transformations are easier to test and maintain.</p>"},{"location":"tutorial/derived-observables/#5-consider-performance","title":"5. Consider Performance","text":"<pre><code># Good - Efficient for large lists\ndef sum_list(lst):\n    return sum(lst)\n\nsummed_method = large_list.then(sum_list)\nsummed_operator = large_list &gt;&gt; sum_list\n\n# Better - Lazy evaluation with generator\ndef sum_generator(lst):\n    return sum(x for x in lst)\n\nsummed_lazy_method = large_list.then(sum_generator)\nsummed_lazy_operator = large_list &gt;&gt; sum_generator\n</code></pre> <p>Be mindful of performance, especially with large data structures.</p>"},{"location":"tutorial/derived-observables/#common-transformation-patterns","title":"Common Transformation Patterns","text":""},{"location":"tutorial/derived-observables/#data-validation","title":"Data Validation","text":"<pre><code>email = observable(\"user@\")\n\ndef validate_email(e):\n    return \"@\" in e and \".\" in e.split(\"@\")[1]\n\ndef email_feedback(valid):\n    return \"Valid\" if valid else \"Invalid\"\n\nis_valid_email_method = email.then(validate_email)\nis_valid_email_operator = email &gt;&gt; validate_email\n\nemail_feedback_method = is_valid_email_method.then(email_feedback)\nemail_feedback_operator = is_valid_email_operator &gt;&gt; email_feedback\n</code></pre>"},{"location":"tutorial/derived-observables/#data-formatting","title":"Data Formatting","text":"<pre><code>price = observable(29.99)\n\ndef format_price(p):\n    return f\"${p:.2f}\"\n\nformatted_price_method = price.then(format_price)\nformatted_price_operator = price &gt;&gt; format_price\n</code></pre>"},{"location":"tutorial/derived-observables/#collection-operations","title":"Collection Operations","text":"<pre><code>items = observable([1, 2, 3, 4, 5])\n\ndef filter_evens(lst):\n    return [x for x in lst if x % 2 == 0]\n\ndef double_items(lst):\n    return [x * 2 for x in lst]\n\ndef sum_items(lst):\n    return sum(lst)\n\n# Filter\nevens_method = items.then(filter_evens)\nevens_operator = items &gt;&gt; filter_evens\n\n# Map\ndoubled_method = items.then(double_items)\ndoubled_operator = items &gt;&gt; double_items\n\n# Reduce\ntotal_method = items.then(sum_items)\ntotal_operator = items &gt;&gt; sum_items\n</code></pre>"},{"location":"tutorial/derived-observables/#state-derivation","title":"State Derivation","text":"<pre><code>app_state = observable(\"loading\")\n\ndef is_loading_state(s):\n    return s == \"loading\"\n\ndef is_error_state(s):\n    return s == \"error\"\n\ndef is_ready_state(s):\n    return s == \"ready\"\n\nis_loading_method = app_state.then(is_loading_state)\nis_loading_operator = app_state &gt;&gt; is_loading_state\n\nis_error_method = app_state.then(is_error_state)\nis_error_operator = app_state &gt;&gt; is_error_state\n\nis_ready_method = app_state.then(is_ready_state)\nis_ready_operator = app_state &gt;&gt; is_ready_state\n</code></pre>"},{"location":"tutorial/derived-observables/#the-big-picture","title":"The Big Picture","text":"<p>Both <code>.then()</code> and <code>&gt;&gt;</code> transform FynX from a simple notification system into a powerful data transformation engine. You stop writing imperative update code and start declaring relationships:</p> <ul> <li>From: \"When X changes, update Y, then update Z\"</li> <li>To: \"Y is a transformation of X, Z is a transformation of Y\"</li> </ul> <p>This declarative approach eliminates entire categories of bugs:</p> <ul> <li>No stale data: Derived values always reflect current source values</li> <li>No forgotten updates: The reactive graph handles all propagation</li> <li>No manual synchronization: Relationships are maintained automatically</li> </ul> <p>Combined with conditionals (<code>&amp;</code>) and merging (<code>+</code>), derived observables give you a complete toolkit for building reactive data pipelines. You describe what your data should look like, and FynX ensures it stays that way.</p> <p>The next step is organizing these reactive pieces into reusable units called Stores\u2014the architectural pattern that brings everything together.</p>"},{"location":"tutorial/observables/","title":"Observables: The Foundation of Reactivity","text":"<p>An observable is a value that changes over time and tells you when it changes. That's it. Everything else in FynX\u2014every operator, every decorator, every pattern\u2014builds on this simple idea.</p> <p>Think of a regular Python variable:</p> <pre><code>count = 0\ncount = 1\ncount = 2\n</code></pre> <p>When <code>count</code> changes, nothing happens. The value updates silently, and any code that depends on <code>count</code> has no idea. You have to manually check for changes, manually update dependent state, manually keep everything synchronized.</p> <p>Now think of an observable:</p> <pre><code>from fynx import observable\n\ncount = observable(0)\ncount.set(1)\ncount.set(2)\n</code></pre> <p>When an observable changes, it notifies anyone who's listening. Dependent computations recalculate automatically. UI updates happen without explicit instructions. The reactive graph maintains its own consistency.</p> <p>This is the fundamental shift: from telling your code when to update to declaring what should be true. FynX handles the rest.</p>"},{"location":"tutorial/observables/#creating-your-first-observable","title":"Creating Your First Observable","text":"<p>Start by importing the <code>observable</code> function and giving it an initial value:</p> <pre><code>from fynx import observable\n\n# Create observables with initial values of any type\nname = observable(\"Alice\")\nage = observable(30)\nscores = observable([85, 92, 78])\nuser = observable({\"id\": 1, \"active\": True})\n</code></pre> <p>The initial value can be anything\u2014strings, numbers, lists, dictionaries, custom objects, even <code>None</code>. FynX doesn't care about the type. It just wraps the value and makes it reactive.</p>"},{"location":"tutorial/observables/#reading-observable-values","title":"Reading Observable Values","text":"<p>To read what's inside an observable, use the <code>.value</code> property:</p> <pre><code>name = observable(\"Alice\")\n\nprint(name.value)  # \"Alice\"\nprint(age.value)   # 30\n</code></pre> <p>This looks like extra syntax compared to regular variables, and it is. But that <code>.value</code> access does something important: it registers that your code depends on this observable. When you read <code>.value</code> inside a reactive context (we'll get to those soon), FynX automatically tracks the dependency and ensures your code re-runs when the observable changes.</p>"},{"location":"tutorial/observables/#writing-observable-values","title":"Writing Observable Values","text":"<p>To change what's inside an observable, use the <code>.set()</code> method:</p> <pre><code>name = observable(\"Alice\")\n\nname.set(\"Bob\")\nprint(name.value)  # \"Bob\"\n\nname.set(\"Charlie\")\nprint(name.value)  # \"Charlie\"\n</code></pre> <p>Each call to <code>.set()</code> does two things:</p> <ol> <li>Updates the internal value</li> <li>Notifies all subscribers that the value changed</li> </ol> <p>This notification is what makes observables reactive. Without it, they'd just be awkward wrappers around regular values.</p>"},{"location":"tutorial/observables/#subscribing-to-changes","title":"Subscribing to Changes","text":"<p>The real power of observables emerges when you subscribe to them. A subscription is a function that runs whenever the observable changes:</p> <pre><code>name = observable(\"Alice\")\n\ndef greet(new_name):\n    print(f\"Hello, {new_name}!\")\n\n# Subscribe to changes\nname.subscribe(greet)\n\n# Now changes trigger the subscriber\nname.set(\"Bob\")      # Prints: \"Hello, Bob!\"\nname.set(\"Charlie\")  # Prints: \"Hello, Charlie!\"\n</code></pre> <p>Your subscriber function receives the new value as its argument. The function runs immediately when you call <code>.set()</code>, after the value updates but before <code>.set()</code> returns.</p> <p>You can subscribe multiple functions to the same observable:</p> <pre><code>counter = observable(0)\n\ncounter.subscribe(lambda n: print(f\"Count: {n}\"))\ncounter.subscribe(lambda n: print(f\"Double: {n * 2}\"))\ncounter.subscribe(lambda n: print(f\"Square: {n ** 2}\"))\n\ncounter.set(5)\n# Output:\n# Count: 5\n# Double: 10\n# Square: 25\n</code></pre> <p>All subscribers receive the same value, and they run in the order you subscribed them.</p>"},{"location":"tutorial/observables/#unsubscribing","title":"Unsubscribing","text":"<p>When you no longer need to listen to an observable, unsubscribe to prevent memory leaks:</p> <pre><code>def logger(value):\n    print(f\"Value: {value}\")\n\ncounter = observable(0)\ncounter.subscribe(logger)\n\ncounter.set(1)  # Prints: \"Value: 1\"\n\n# Unsubscribe when done\ncounter.unsubscribe(logger)\n\ncounter.set(2)  # No output - logger no longer subscribed\n</code></pre> <p>You must pass the exact same function reference to <code>unsubscribe()</code> that you passed to <code>subscribe()</code>. This is why lambda functions can be tricky\u2014you can't easily unsubscribe them later. For cleanup-critical code, use named functions.</p>"},{"location":"tutorial/observables/#observables-vs-regular-variables","title":"Observables vs. Regular Variables","text":"<p>Let's make the difference concrete. Here's state management without observables:</p> <pre><code># Traditional approach\nclass ShoppingCart:\n    def __init__(self):\n        self.items = []\n        self.total = 0\n\n    def add_item(self, item):\n        self.items.append(item)\n        self.total = sum(item['price'] for item in self.items)\n        self.update_ui()  # Manual synchronization\n        self.save_to_storage()  # Manual synchronization\n        self.notify_analytics()  # Manual synchronization\n</code></pre> <p>Every time you modify state, you must remember to update everything that depends on it. Miss one call and your application falls out of sync.</p> <p>Here's the same thing with observables:</p> <pre><code># Reactive approach\nitems = observable([])\ntotal = items &gt;&gt; (lambda item_list: sum(item['price'] for item in item_list))\n\nitems.subscribe(update_ui)\nitems.subscribe(save_to_storage)\nitems.subscribe(notify_analytics)\n\n# Now just update the observable\nitems.set(items.value + [{'name': 'Widget', 'price': 10}])\n# All three functions run automatically\n# total recalculates automatically\n</code></pre> <p>You declare the relationships once. Changes propagate automatically. There's no way to forget a synchronization step because there are no synchronization steps\u2014just state changes.</p>"},{"location":"tutorial/observables/#what-observables-enable","title":"What Observables Enable","text":"<p>Observables are containers, but they're programmable containers. They carry their dependencies with them. When you build reactive systems, you're constructing graphs where nodes (observables) automatically update when their upstream dependencies change.</p> <p>Consider a simple example:</p> <pre><code>base_price = observable(100)\nquantity = observable(2)\n\n# This creates a computed observable (we'll explore these deeply in the next section)\ntotal = (base_price + quantity) &gt;&gt; (lambda price, qty: price * qty)\n\ntotal.subscribe(lambda t: print(f\"Total: ${t}\"))\n\nbase_price.set(150)  # Prints: \"Total: $300\"\nquantity.set(3)      # Prints: \"Total: $450\"\n</code></pre> <p>Notice what didn't happen: you never manually recalculated <code>total</code>. You never explicitly called the subscriber. The reactive graph did all that work for you. You just changed the base values and watched the effects cascade.</p> <p>This is what observables enable: declarative state management. You describe what relationships should exist, and FynX ensures they hold.</p>"},{"location":"tutorial/observables/#when-to-use-observables","title":"When to Use Observables","text":"<p>Observables shine in situations where:</p> <ul> <li>Multiple things depend on the same state \u2014 One change needs to update several downstream systems</li> <li>State changes frequently \u2014 User interactions, real-time data, animated values</li> <li>Dependencies are complex \u2014 Value A depends on B and C, which depend on D and E</li> <li>You want to avoid manual synchronization \u2014 Eliminating update code reduces bugs</li> </ul> <p>Observables add overhead compared to plain variables. For simple scripts or one-off calculations, that overhead isn't worth it. But for interactive applications, data pipelines, or anything with non-trivial state management, observables pay for themselves quickly.</p>"},{"location":"tutorial/observables/#whats-next","title":"What's Next","text":"<p>Observables are more than containers\u2014they're nodes in a reactive graph. But standalone observables are just the beginning. The real power emerges when you learn to:</p> <ul> <li>Transform observables using the <code>&gt;&gt;</code> operator to create derived values that update automatically</li> <li>Combine observables using the <code>+</code> operator to work with multiple sources of data</li> <li>Filter observables using the <code>&amp;</code> operator to apply conditional logic and control when data flows</li> <li>Create logical OR conditions using the <code>|</code> operator to combine boolean observables</li> <li>Organize observables into Stores for cleaner application architecture</li> <li>Automate reactions with decorators that eliminate subscription boilerplate</li> </ul> <p>Each of these builds on the foundation you've just learned. Observables are simple, but their composition creates sophisticated reactive systems.</p> <p>The insight to carry forward: observables aren't just containers\u2014they're nodes in a reactive graph. When you change one node, effects ripple through the entire structure automatically. That's the power FynX gives you.</p>"},{"location":"tutorial/stores/","title":"Stores: Organizing Reactive State","text":"<p>Observables form the foundation of reactivity, but scattered reactive values create chaos. As applications grow, you need structure\u2014containers that group related state, define behaviors, and provide clean boundaries.</p> <p>Stores solve these problems by giving structure to your reactive state.</p>"},{"location":"tutorial/stores/#what-is-a-store","title":"What is a Store?","text":"<p>A Store is a class that groups related observables together. That's the essence. Everything else\u2014the computed properties, the methods, the reactive behaviors\u2014builds on this simple organizational principle.</p> <p>Think of a Store as a namespace for related state. If you're building a shopping cart, all the cart-related observables live in <code>CartStore</code>. If you're managing user authentication, all auth state lives in <code>AuthStore</code>. Each Store becomes a clear, testable boundary in your application.</p> <p>Here's the simplest possible Store:</p> <pre><code>from fynx import Store, observable\n\nclass CounterStore(Store):\n    count = observable(0)\n</code></pre> <p>That's it. You've created a Store with one reactive attribute. The magic is in what this gives you:</p> <pre><code># Read the value\ncurrent = CounterStore.count\n\n# Write the value\nCounterStore.count = 5\n\n# The value is an observable under the hood\nCounterStore.count.subscribe(lambda c: print(f\"Count: {c}\"))\n\nCounterStore.count = 10  # Prints: \"Count: 10\"\n</code></pre> <p>Notice the asymmetry: you read with direct access (<code>CounterStore.count</code>), but the value is still an observable. You can still subscribe to it, transform it with <code>&gt;&gt;</code>, merge it with <code>+</code>. The Store class uses Python descriptors to give you clean syntax while preserving all of observable's power.</p>"},{"location":"tutorial/stores/#why-stores-matter","title":"Why Stores Matter","text":"<p>Before Stores, you might write code like this:</p> <pre><code># Scattered observables\nuser_first_name = observable(\"Alice\")\nuser_last_name = observable(\"Smith\")\nuser_age = observable(30)\nuser_email = observable(\"alice@example.com\")\nis_authenticated = observable(False)\n\n# Where does this logic live?\ndef update_user_profile(first, last, age, email):\n    user_first_name.set(first)\n    user_last_name.set(last)\n    user_age.set(age)\n    user_email.set(email)\n</code></pre> <p>This works, but it doesn't scale. Which observables relate to each other? Where should validation logic go? How do you reset user state? How do you test user-related functionality without affecting other parts of your application?</p> <p>With Stores:</p> <pre><code>class UserStore(Store):\n    first_name = observable(\"Alice\")\n    last_name = observable(\"Smith\")\n    age = observable(30)\n    email = observable(\"alice@example.com\")\n    is_authenticated = observable(False)\n\n    @classmethod\n    def update_profile(cls, first, last, age, email):\n        cls.first_name = first\n        cls.last_name = last\n        cls.age = age\n        cls.email = email\n\n    @classmethod\n    def logout(cls):\n        cls.is_authenticated = False\n        cls.first_name = \"\"\n        cls.last_name = \"\"\n        cls.email = \"\"\n</code></pre> <p>Now everything about users lives in one place. The boundaries are clear. Testing is straightforward. Other parts of your application import <code>UserStore</code> and interact with it through its public methods.</p>"},{"location":"tutorial/stores/#store-attributes-observable-descriptors","title":"Store Attributes: Observable Descriptors","text":"<p>When you write <code>count = observable(0)</code> inside a Store class, you're creating an observable descriptor. This descriptor gives you convenient syntax:</p> <pre><code>class MyStore(Store):\n    value = observable(100)\n\n# These are equivalent:\nprint(MyStore.value)         # Direct access\nprint(MyStore.value.value)   # Explicit .value access\n\n# Writing is clean:\nMyStore.value = 200           # Direct assignment\n\n# But you can still use it as an observable:\nMyStore.value.subscribe(lambda v: print(v))\ndoubled = MyStore.value &gt;&gt; (lambda v: v * 2)\n</code></pre> <p>The descriptor pattern means you don't need <code>.value</code> and <code>.set()</code> for Store attributes\u2014just read and write naturally. But the underlying observable is still there, ready for transformations and subscriptions.</p> <p>Important: This clean syntax only works for Store class attributes. Standalone observables (not in a Store) still require <code>.value</code> and <code>.set()</code>:</p> <pre><code># Standalone observable\ncounter = observable(0)\nprint(counter.value)  # Must use .value\ncounter.set(5)        # Must use .set()\n\n# Store observable\nclass CounterStore(Store):\n    counter = observable(0)\n\nprint(CounterStore.counter)  # No .value needed\nCounterStore.counter = 5     # No .set() needed\n</code></pre>"},{"location":"tutorial/stores/#adding-computed-values","title":"Adding Computed Values","text":"<p>The real power of Stores emerges when you add derived state using the <code>&gt;&gt;</code> operator:</p> <pre><code>class CartStore(Store):\n    items = observable([])\n    tax_rate = observable(0.08)\n\n    # Computed: recalculates when items changes\n    item_count = items &gt;&gt; (lambda items: len(items))\n\n    # Computed: recalculates when items changes\n    subtotal = items &gt;&gt; (\n        lambda items: sum(item['price'] * item['quantity'] for item in items)\n    )\n</code></pre> <p>These computed values update automatically. When you change <code>CartStore.items</code>, both <code>item_count</code> and <code>subtotal</code> recalculate. But they only recalculate when you actually access them\u2014this lazy evaluation means computed values have zero cost until you need them.</p> <pre><code>CartStore.items = [\n    {'name': 'Widget', 'price': 10, 'quantity': 2},\n    {'name': 'Gadget', 'price': 15, 'quantity': 1}\n]\n\nprint(CartStore.item_count)  # 2 (computes now)\nprint(CartStore.subtotal)    # 35.0 (computes now)\n\n# Access again without changes\nprint(CartStore.item_count)  # 2 (returns cached value)\n</code></pre> <p>Computed values memoize their results. After the first access, they return the cached value until their dependencies change.</p>"},{"location":"tutorial/stores/#combining-multiple-observables","title":"Combining Multiple Observables","text":"<p>Most computed values depend on more than one observable. Use the <code>+</code> operator to merge observables:</p> <pre><code>class CartStore(Store):\n    items = observable([])\n    tax_rate = observable(0.08)\n\n    subtotal = items &gt;&gt; (\n        lambda items: sum(item['price'] * item['quantity'] for item in items)\n    )\n\n    # Merge subtotal and tax_rate\n    tax_amount = (subtotal + tax_rate) &gt;&gt; (\n        lambda sub, rate: sub * rate\n    )\n\n    # Merge subtotal and tax_amount\n    total = (subtotal + tax_amount) &gt;&gt; (\n        lambda sub, tax: sub + tax\n    )\n</code></pre> <p>The <code>+</code> operator creates a merged observable that emits a tuple. When you transform it with <code>&gt;&gt;</code>, the function receives one argument per observable:</p> <pre><code>CartStore.items = [{'name': 'Widget', 'price': 20, 'quantity': 1}]\n\nprint(CartStore.subtotal)     # 20.0\nprint(CartStore.tax_amount)   # 1.6\nprint(CartStore.total)        # 21.6\n\nCartStore.tax_rate = 0.10\nprint(CartStore.tax_amount)   # 2.0 (recalculated)\nprint(CartStore.total)        # 22.0 (recalculated)\n</code></pre> <p>Any change to a merged observable triggers recomputation. This makes <code>+</code> perfect for values that need to coordinate multiple pieces of state.</p>"},{"location":"tutorial/stores/#methods-encapsulating-state-changes","title":"Methods: Encapsulating State Changes","text":"<p>Stores become truly useful when they encapsulate the logic for modifying their own state:</p> <pre><code>class CartStore(Store):\n    items = observable([])\n\n    @classmethod\n    def add_item(cls, name, price, quantity=1):\n        \"\"\"Add an item to the cart or update quantity if it exists.\"\"\"\n        current_items = cls.items\n\n        # Find existing item\n        existing = next((item for item in current_items if item['name'] == name), None)\n\n        if existing:\n            # Update quantity\n            cls.items = [\n                {**item, 'quantity': item['quantity'] + quantity}\n                if item['name'] == name else item\n                for item in current_items\n            ]\n        else:\n            # Add new item\n            cls.items = current_items + [{'name': name, 'price': price, 'quantity': quantity}]\n\n    @classmethod\n    def remove_item(cls, name):\n        \"\"\"Remove an item from the cart.\"\"\"\n        cls.items = [item for item in cls.items if item['name'] != name]\n\n    @classmethod\n    def clear(cls):\n        \"\"\"Remove all items.\"\"\"\n        cls.items = []\n</code></pre> <p>Now cart manipulation is clean and explicit:</p> <pre><code>CartStore.add_item('Widget', 10.0, 2)\nCartStore.add_item('Gadget', 15.0)\nprint(CartStore.item_count)  # 2\n\nCartStore.remove_item('Widget')\nprint(CartStore.item_count)  # 1\n\nCartStore.clear()\nprint(CartStore.item_count)  # 0\n</code></pre> <p>Methods define your Store's public API. Users don't manipulate observables directly\u2014they call methods that express intent. This encapsulation makes your code more maintainable and testable.</p>"},{"location":"tutorial/stores/#a-critical-pattern-immutable-updates","title":"A Critical Pattern: Immutable Updates","text":"<p>Notice the pattern in the methods above\u2014we never mutate values in place:</p> <pre><code># Wrong: Mutation doesn't trigger reactivity\ncls.items.append(new_item)\n\n# Right: Create new list\ncls.items = cls.items + [new_item]\n</code></pre> <p>FynX detects changes through assignment. When you mutate an observable's value in place, nothing triggers because from FynX's perspective, the reference hasn't changed. Always create new values:</p> <pre><code># Lists: Create new list\ncls.items = cls.items + [new_item]\ncls.items = [item for item in cls.items if condition]\n\n# Dicts: Create new dict\ncls.user = {**cls.user, 'name': 'New Name'}\n\n# Nested structures: Reconstruct the path\ncls.items = [\n    {**item, 'quantity': item['quantity'] + 1} if item['id'] == target_id else item\n    for item in cls.items\n]\n</code></pre> <p>This immutable update pattern is crucial. It ensures reactivity works correctly and makes your state changes predictable.</p>"},{"location":"tutorial/stores/#chaining-computed-values","title":"Chaining Computed Values","text":"<p>Computed values can depend on other computed values, creating transformation pipelines:</p> <pre><code>class AnalyticsStore(Store):\n    values = observable([10, 20, 30, 40, 50])\n\n    # Level 1: Basic stats\n    count = values &gt;&gt; (lambda v: len(v))\n    total = values &gt;&gt; (lambda v: sum(v))\n\n    # Level 2: Depends on count and total\n    mean = (total + count) &gt;&gt; (\n        lambda t, c: t / c if c &gt; 0 else 0\n    )\n\n    # Level 3: Depends on values and mean\n    variance = (values + mean + count) &gt;&gt; (\n        lambda vals, avg, n: (\n            sum((x - avg) ** 2 for x in vals) / (n - 1) if n &gt; 1 else 0\n        )\n    )\n\n    # Level 4: Depends on variance\n    std_dev = variance &gt;&gt; (lambda v: v ** 0.5)\n</code></pre> <p>When <code>values</code> changes, FynX propagates updates through the entire chain in the correct order. Each level recalculates only if its dependencies actually changed:</p> <pre><code>print(f\"Mean: {AnalyticsStore.mean:.2f}\")      # 30.00\nprint(f\"Std Dev: {AnalyticsStore.std_dev:.2f}\") # 15.81\n\nAnalyticsStore.values = [5, 10, 15, 20, 25]\nprint(f\"Mean: {AnalyticsStore.mean:.2f}\")      # 15.00\nprint(f\"Std Dev: {AnalyticsStore.std_dev:.2f}\") # 7.91\n</code></pre> <p>This chaining pattern lets you build complex derived state from simple transformations. Each step is testable and easy to understand.</p>"},{"location":"tutorial/stores/#practical-example-user-profile-store","title":"Practical Example: User Profile Store","text":"<p>Let's build a realistic Store that demonstrates all these concepts:</p> <pre><code>from fynx import Store, observable\n\nclass UserProfileStore(Store):\n    # Basic observables\n    first_name = observable(\"\")\n    last_name = observable(\"\")\n    email = observable(\"\")\n    age = observable(0)\n    is_premium = observable(False)\n\n    # Computed: full name\n    full_name = (first_name + last_name) &gt;&gt; (\n        lambda first, last: f\"{first} {last}\".strip()\n    )\n\n    # Computed: display name (falls back if no name)\n    display_name = full_name &gt;&gt; (\n        lambda name: name if name else \"Anonymous User\"\n    )\n\n    # Computed: email validation\n    is_email_valid = email &gt;&gt; (\n        lambda e: '@' in e and '.' in e.split('@')[-1] if e else False\n    )\n\n    # Computed: age validation\n    is_adult = age &gt;&gt; (lambda a: a &gt;= 18)\n\n    # Computed: profile completeness\n    is_complete = (first_name + last_name + email + is_email_valid) &gt;&gt; (\n        lambda first, last, email_addr, email_valid:\n            bool(first and last and email_addr and email_valid)\n    )\n\n    # Computed: user tier\n    user_tier = (is_premium + is_complete) &gt;&gt; (\n        lambda premium, complete: (\n            \"Premium\" if premium else\n            \"Complete\" if complete else\n            \"Basic\"\n        )\n    )\n\n    @classmethod\n    def update_name(cls, first, last):\n        \"\"\"Update the user's name.\"\"\"\n        cls.first_name = first.strip()\n        cls.last_name = last.strip()\n\n    @classmethod\n    def update_email(cls, email):\n        \"\"\"Update the user's email.\"\"\"\n        cls.email = email.strip().lower()\n\n    @classmethod\n    def set_age(cls, age):\n        \"\"\"Update the user's age.\"\"\"\n        if age &gt;= 0:\n            cls.age = age\n\n    @classmethod\n    def upgrade_to_premium(cls):\n        \"\"\"Upgrade the user to premium status.\"\"\"\n        cls.is_premium = True\n\n    @classmethod\n    def reset(cls):\n        \"\"\"Reset all profile data.\"\"\"\n        cls.first_name = \"\"\n        cls.last_name = \"\"\n        cls.email = \"\"\n        cls.age = 0\n        cls.is_premium = False\n</code></pre> <p>Usage demonstrates how everything updates automatically:</p> <pre><code># Initial state\nprint(UserProfileStore.display_name)  # \"Anonymous User\"\nprint(UserProfileStore.user_tier)     # \"Basic\"\n\n# Update name\nUserProfileStore.update_name(\"Alice\", \"Smith\")\nprint(UserProfileStore.display_name)  # \"Alice Smith\"\nprint(UserProfileStore.full_name)     # \"Alice Smith\"\n\n# Update email\nUserProfileStore.update_email(\"alice@example.com\")\nprint(UserProfileStore.is_email_valid)  # True\n\n# Set age\nUserProfileStore.set_age(25)\nprint(UserProfileStore.is_adult)      # True\nprint(UserProfileStore.is_complete)   # True\nprint(UserProfileStore.user_tier)     # \"Complete\"\n\n# Upgrade\nUserProfileStore.upgrade_to_premium()\nprint(UserProfileStore.user_tier)     # \"Premium\"\n</code></pre> <p>Every computed value updates automatically when its dependencies change. You never write synchronization code\u2014just modify observables and watch the effects cascade.</p>"},{"location":"tutorial/stores/#cross-store-dependencies","title":"Cross-Store Dependencies","text":"<p>Stores can reference observables from other Stores, enabling modular architecture:</p> <pre><code>class ThemeStore(Store):\n    mode = observable(\"light\")  # \"light\" or \"dark\"\n    font_size = observable(16)\n\nclass UIStore(Store):\n    sidebar_open = observable(True)\n\n    # Depends on ThemeStore\n    background_color = ThemeStore.mode &gt;&gt; (\n        lambda mode: \"#ffffff\" if mode == \"light\" else \"#1a1a1a\"\n    )\n\n    text_color = ThemeStore.mode &gt;&gt; (\n        lambda mode: \"#000000\" if mode == \"light\" else \"#ffffff\"\n    )\n\n    # Depends on multiple observables from ThemeStore\n    css_vars = (ThemeStore.mode + ThemeStore.font_size) &gt;&gt; (\n        lambda mode, size: {\n            '--bg': \"#ffffff\" if mode == \"light\" else \"#1a1a1a\",\n            '--text': \"#000000\" if mode == \"light\" else \"#ffffff\",\n            '--font-size': f\"{size}px\"\n        }\n    )\n</code></pre> <p>This pattern keeps Stores focused while allowing coordination:</p> <pre><code>ThemeStore.mode = \"dark\"\nprint(UIStore.background_color)  # \"#1a1a1a\"\nprint(UIStore.text_color)        # \"#ffffff\"\n\nThemeStore.font_size = 18\nprint(UIStore.css_vars['--font-size'])  # \"18px\"\n</code></pre> <p>Each Store maintains its own domain, but computed values can reach across Store boundaries to create relationships.</p>"},{"location":"tutorial/stores/#when-to-use-stores","title":"When to Use Stores","text":"<p>Use Stores when you have:</p> <p>Related state that belongs together:</p> <pre><code># Good: Cart-related state in CartStore\nclass CartStore(Store):\n    items = observable([])\n    discount_code = observable(None)\n    shipping_address = observable(None)\n</code></pre> <p>State that needs derived values:</p> <pre><code># Good: Computed values with their source state\nclass FormStore(Store):\n    email = observable(\"\")\n    password = observable(\"\")\n\n    email_valid = email &gt;&gt; (lambda e: '@' in e)\n    password_valid = password &gt;&gt; (lambda p: len(p) &gt;= 8)\n    form_valid = (email_valid + password_valid) &gt;&gt; (lambda e, p: e and p)\n</code></pre> <p>State that needs encapsulated modification:</p> <pre><code># Good: Methods that maintain invariants\nclass AccountStore(Store):\n    balance = observable(0)\n\n    @classmethod\n    def deposit(cls, amount):\n        if amount &gt; 0:\n            cls.balance = cls.balance + amount\n\n    @classmethod\n    def withdraw(cls, amount):\n        if 0 &lt; amount &lt;= cls.balance:\n            cls.balance = cls.balance - amount\n</code></pre> <p>Don't use Stores for truly independent, single-purpose observables:</p> <pre><code># Overkill: Just use a standalone observable\nclass IsLoadingStore(Store):\n    value = observable(False)\n\n# Better:\nis_loading = observable(False)\n</code></pre>"},{"location":"tutorial/stores/#store-inheritance-clean-state-isolation","title":"Store Inheritance: Clean State Isolation","text":"<p>Store classes support inheritance, but with important nuances for state management:</p> <pre><code>class BaseStore(Store):\n    count = observable(0)\n    name = observable(\"Base\")\n\nclass ChildStore(BaseStore):\n    pass  # Inherits count and name observables\n\n# Each class gets completely independent state\nBaseStore.count = 5\nChildStore.count = 10\n\nprint(BaseStore.count)   # 5\nprint(ChildStore.count)  # 10 (completely separate)\n</code></pre> <p>Key Behavior: Unlike standard Python inheritance where child classes share parent attributes, Store inheritance creates separate observable instances for each class. This ensures clean state isolation:</p> <ul> <li><code>BaseStore.count</code> and <code>ChildStore.count</code> are completely independent</li> <li>Changes to one don't affect the other</li> <li>Each class maintains its own reactive state</li> </ul> <p>Explicit Overrides: You can still override inherited observables:</p> <pre><code>class CustomStore(BaseStore):\n    count = observable(100)  # Completely replaces parent's count\n    name = observable(\"Custom\")  # Completely replaces parent's name\n\nprint(CustomStore.count)  # 100 (not 0)\nprint(BaseStore.count)    # 5 (unchanged)\n</code></pre> <p>Store inheritance prioritizes predictability and state isolation. Since Stores are typically global singletons, shared state through inheritance could lead to unexpected coupling. Each Store class gets its own clean state namespace.</p> <p>Best Practice: Use inheritance for shared behavior (methods, computed properties), but define separate observables for each Store class that needs independent state.</p>"},{"location":"tutorial/stores/#best-practices","title":"Best Practices","text":"<p>1. Keep Stores focused on a single domain</p> <p>Each Store should represent one cohesive area of your application:</p> <pre><code># Good: Focused domains\nclass AuthStore(Store): ...\nclass CartStore(Store): ...\nclass UIStore(Store): ...\n\n# Bad: Everything in one Store\nclass AppStore(Store):\n    user = observable(None)\n    cart_items = observable([])\n    modal_open = observable(False)\n    ...  # 50 more observables\n</code></pre> <p>2. Use class methods for state modifications</p> <p>Encapsulate how state changes:</p> <pre><code># Good: Clear API\n@classmethod\ndef add_item(cls, item):\n    cls.items = cls.items + [item]\n\n# Bad: Direct manipulation everywhere\nSomeStore.items = SomeStore.items + [item]\n</code></pre> <p>3. Always create new values, never mutate</p> <pre><code># Good: New list\ncls.items = cls.items + [new_item]\ncls.items = [item for item in cls.items if item['id'] != id]\n\n# Bad: Mutation (won't trigger reactivity)\ncls.items.append(new_item)\ncls.items.remove(item)\n</code></pre> <p>4. Handle edge cases in computed values</p> <p>Computed values should be defensive:</p> <pre><code># Good: Handles empty list\naverage = values &gt;&gt; (\n    lambda vals: sum(vals) / len(vals) if len(vals) &gt; 0 else 0\n)\n\n# Good: Handles None\nuser_name = user &gt;&gt; (\n    lambda u: u['name'] if u and 'name' in u else \"Guest\"\n)\n</code></pre> <p>5. Name computed values clearly</p> <p>Use names that indicate derivation:</p> <pre><code># Good: Clear that these are derived\nis_valid = email &gt;&gt; (lambda e: '@' in e)\nitem_count = items &gt;&gt; len\ntotal_price = items &gt;&gt; (lambda items: sum(item['price'] for item in items))\n\n# Less clear:\nvalid = email &gt;&gt; (lambda e: '@' in e)\ncount = items &gt;&gt; len\nprice = items &gt;&gt; (lambda items: sum(item['price'] for item in items))\n</code></pre>"},{"location":"tutorial/stores/#summary","title":"Summary","text":"<p>Stores organize your reactive state into cohesive, testable units. They combine observables, computed values, and methods into structures that represent distinct domains of your application.</p> <p>Core concepts:</p> <ul> <li>Stores group related observables \u2014 Keep state that belongs together in the same Store</li> <li>Observable descriptors enable clean syntax \u2014 Read and write Store attributes naturally</li> <li>The <code>&gt;&gt;</code> operator creates computed values \u2014 Derived state updates automatically</li> <li>The <code>+</code> operator merges observables \u2014 Combine multiple sources for multi-input computations</li> <li>Always create new values \u2014 Never mutate observable contents in place</li> <li>Methods encapsulate state changes \u2014 Define clear APIs for modifying state</li> <li>Stores can depend on other Stores \u2014 Build modular applications with cross-Store relationships</li> </ul> <p>With Stores, you can build reactive applications that scale from simple counters to complex, multi-domain state management systems. The secret is organization: each Store owns its domain, exposes a clean API, and lets FynX handle all the synchronization automatically.</p>"},{"location":"tutorial/using-reactive/","title":"@reactive: Automatic Reactions to Change","text":"<p>Observables hold state, and Stores organize it. But how do you actually respond when that state changes? How do you keep UI, databases, and external systems in sync?</p> <p>Right now, if you want to respond to changes, you write this:</p> <pre><code>count = observable(0)\n\ndef log_count(value):\n    print(f\"Count: {value}\")\n\ncount.subscribe(log_count)\n</code></pre> <p>This works. But as your application grows, subscription management becomes tedious:</p> <pre><code># Subscriptions scattered everywhere\ncount.subscribe(update_ui)\ncount.subscribe(save_to_database)\ncount.subscribe(notify_analytics)\nname.subscribe(update_greeting)\nemail.subscribe(validate_email)\n(first_name + last_name).subscribe(update_display_name)\n\n# Later... did you remember to unsubscribe?\ncount.unsubscribe(update_ui)\n# Wait, which function was subscribed to which observable?\n</code></pre> <p>You're back to manual synchronization, just with a different syntax. The subscriptions themselves become state you have to manage.</p> <p>There's a better way.</p>"},{"location":"tutorial/using-reactive/#introducing-reactive","title":"Introducing @reactive","text":"<p>The <code>@reactive</code> decorator turns functions into automatic reactions. Instead of manually subscribing, you declare what observables matter and FynX handles the rest:</p> <pre><code>from fynx import observable, reactive\n\ncount = observable(0)\n\n@reactive(count)\ndef log_count(value):\n    print(f\"Count: {value}\")\n\ncount.set(5)   # Prints: \"Count: 5\"\ncount.set(10)  # Prints: \"Count: 10\"\n</code></pre> <p>That's it. No manual subscription. No cleanup to remember. Just a declaration: \"this function reacts to this observable.\"</p> <p>The decorator does two things:</p> <ol> <li>Subscribes automatically \u2014 No need to call <code>.subscribe()</code></li> <li>Runs on every change \u2014 Whenever the observable changes, the function runs with the new value</li> </ol> <p>This is the bridge from passive state management (observables and stores) to active behavior (side effects that respond to changes).</p>"},{"location":"tutorial/using-reactive/#a-critical-detail-when-reactions-fire","title":"A Critical Detail: When Reactions Fire","text":"<p>Here's something that might surprise you: when you create a reactive function, it doesn't fire immediately with the current value. It only fires when the value changes.</p> <pre><code>ready = observable(True)  # Already true\n\n@reactive(ready)\ndef on_ready(value):\n    print(f\"Ready: {value}\")\n\n# Nothing prints yet, even though ready is True\n\nready.set(False)  # Prints: \"Ready: False\"\nready.set(True)   # Prints: \"Ready: True\"\n</code></pre> <p>This behavior has deep roots in category theory\u2014reactive functions form what's called a \"pullback\" in categorical semantics. The initial state isn't captured because you haven't pulled back through a change yet. You're observing the flow of changes, not the snapshot of current state.</p> <p>This matters enormously for initialization logic. If you need something to run immediately based on current state, you'll need to handle that separately, perhaps by calling the function once manually before decorating it, or by setting up your initial state in a way that triggers the reaction. Reactive functions are about responding to transitions, not about reflecting static state.</p> <p>Understanding this execution model is crucial:</p> <pre><code>count = observable(0)\n\n@reactive(count)\ndef log_count(value):\n    print(f\"Count: {value}\")\n\n# At this point, log_count has NOT run yet - no initial trigger\n\ncount.set(5)   # log_count runs for the first time\n# Output: \"Count: 5\"\n\ncount.set(5)   # Same value - does log_count run?\n# Output: (no additional output - only runs when value actually changes)\n</code></pre> <p>The function runs every time <code>.set()</code> is called with a different value\u2014only when the value actually changes. The execution is synchronous\u2014the function completes before <code>.set()</code> returns. This makes reactive code predictable and debuggable. When you write <code>count.set(5)</code>, you know that all reactive functions have finished by the time the next line runs.</p>"},{"location":"tutorial/using-reactive/#the-mental-model-declarative-side-effects","title":"The Mental Model: Declarative Side Effects","text":"<p>Traditional programming separates \"doing\" from \"reacting\":</p> <pre><code># Traditional: Manual coordination\ndef update_count(new_value):\n    count = new_value\n    update_ui(count)           # Remember to call this\n    save_to_database(count)    # Remember to call this\n    log_change(count)          # Remember to call this\n</code></pre> <p>Every time you modify state, you must remember all the dependent actions. Miss one and your application falls out of sync.</p> <p>With <code>@reactive</code>, you declare the relationships once:</p> <pre><code># Reactive: Declare what should happen\n@reactive(count)\ndef update_ui(value):\n    print(f\"UI: {value}\")\n\n@reactive(count)\ndef save_to_database(value):\n    print(f\"Saving: {value}\")\n\n@reactive(count)\ndef log_change(value):\n    print(f\"Log: {value}\")\n\n# Now just update state\ncount.set(42)\n# All three functions run automatically\n# UI: 42\n# Saving: 42\n# Log: 42\n</code></pre> <p>You've moved from \"remember to update everything\" to \"declare what should stay synchronized.\" The burden of coordination shifts from you to FynX.</p>"},{"location":"tutorial/using-reactive/#conditional-reactions-boolean-logic-for-when-to-react","title":"Conditional Reactions: Boolean Logic for When to React","text":"<p>Here's where <code>@reactive</code> becomes truly powerful. You can combine observables with logical operators to create conditional reactions that only fire when specific conditions are met:</p> <pre><code>is_logged_in = observable(False)\nhas_data = observable(False)\nis_loading = observable(True)\nshould_sync = observable(False)\n\n# React only when logged in AND has data AND NOT loading OR should sync\n@reactive(is_logged_in &amp; has_data &amp; ~is_loading + should_sync)\ndef sync_to_server(should_run):\n    if should_run:\n        perform_sync()\n</code></pre> <p>The operators work exactly as you'd expect:</p> <ul> <li><code>&amp;</code> is logical AND</li> <li><code>+</code> is logical OR (when used with observables on both sides)</li> <li><code>~</code> is logical NOT (negation)</li> </ul> <p>These create composite observables that emit values based on boolean logic. The critical insight: the reaction still follows the change-only semantics. Even if your condition is <code>True</code> when you attach the reactive function, it won't fire until something changes and the condition evaluates.</p> <pre><code>logged_in = observable(True)\nverified = observable(True)\n\n# Even though both are already True, this doesn't fire yet\n@reactive(logged_in &amp; verified)\ndef enable_premium_features(both_true):\n    print(f\"Premium features: {both_true}\")\n\n# Nothing printed yet - waiting for first change\n\nlogged_in.set(False)  # Condition now False, triggers reaction\n# Prints: \"Premium features: False\"\n\nverified.set(False)  # Both False, triggers reaction\n# Prints: \"Premium features: False\"\n\nlogged_in.set(True)  # One is True, one is False, triggers reaction\n# Prints: \"Premium features: False\"\n\nverified.set(True)  # Both True now, triggers reaction\n# Prints: \"Premium features: True\"\n</code></pre> <p>This mirrors MobX's <code>when</code> behavior, but with more compositional flexibility. You're not limited to simple conditions\u2014you can build arbitrarily complex boolean expressions that describe exactly when your side effect should consider running.</p> <p>Think of it as event-driven reactions with declarative conditions. Instead of checking conditions inside your reaction function, you express them in the observable composition itself:</p> <pre><code># Instead of this:\n@reactive(status)\ndef maybe_sync(status):\n    if status.logged_in and status.has_data and not status.loading:\n        perform_sync()\n\n# You can write this:\n@reactive(logged_in &amp; has_data &amp; ~is_loading)\ndef sync_when_ready(should_sync):\n    if should_sync:\n        perform_sync()\n</code></pre> <p>The second version is clearer about when the sync happens\u2014the condition is part of the observable dependency declaration, not buried in the function body.</p>"},{"location":"tutorial/using-reactive/#reacting-to-multiple-observables","title":"Reacting to Multiple Observables","text":"<p>Most real-world reactions depend on multiple pieces of state. When you need values from several observables without boolean logic, use the <code>+</code> operator differently\u2014for combining observables into value tuples:</p> <pre><code>first_name = observable(\"Alice\")\nlast_name = observable(\"Smith\")\n\n# Derive a combined observable first\nfull_name = (first_name + last_name) &gt;&gt; (lambda f, l: f\"{f} {l}\")\n\n# Then react to changes in the derivation\n@reactive(full_name)\ndef update_display(display_name):\n    print(f\"Display: {display_name}\")\n\n# Nothing prints yet - waiting for first change\n\nfirst_name.set(\"Bob\")  # Triggers with \"Bob Smith\"\nlast_name.set(\"Jones\")  # Triggers with \"Bob Jones\"\n</code></pre> <p>Notice the pattern: derive first, react second. The <code>+</code> operator combines observables into a stream of value pairs. The <code>&gt;&gt;</code> operator transforms that stream. Only after you've created a derived observable do you attach the reaction.</p> <p>This is a fundamental principle: most of the time, you don't react directly to raw observables. You react to derived observables\u2014computed values that represent the meaningful state for your side effect.</p> <pre><code>class CartStore(Store):\n    items = observable([])\n    tax_rate = observable(0.08)\n\n# Derive the meaningful state\ntotal = (CartStore.items + CartStore.tax_rate) &gt;&gt; (\n    lambda items, rate: sum(item['price'] * item['qty'] for item in items) * (1 + rate)\n)\n\n# React to the derived state\n@reactive(total)\ndef update_total_display(total_amount):\n    print(f\"Total: ${total_amount:.2f}\")\n</code></pre> <p>The reaction only cares about the final computed total, not about whether items changed or tax rate changed. This separation of concerns\u2014derive meaning, then react to it\u2014keeps your reactive functions simple and focused.</p>"},{"location":"tutorial/using-reactive/#reacting-to-entire-stores","title":"Reacting to Entire Stores","text":"<p>Sometimes you want to react to any change in a Store, regardless of which specific observable changed. Pass the Store class itself:</p> <pre><code>class UserStore(Store):\n    name = observable(\"Alice\")\n    age = observable(30)\n    email = observable(\"alice@example.com\")\n\n@reactive(UserStore)\ndef sync_to_server(store_snapshot):\n    print(f\"Syncing: {store_snapshot.name}, {store_snapshot.email}\")\n\n# Doesn't run immediately - waits for first change\n\nUserStore.name = \"Bob\"  # Triggers reaction\n# Prints: \"Syncing: Bob, alice@example.com\"\n\nUserStore.age = 31  # Triggers reaction\n# Prints: \"Syncing: Bob, alice@example.com\"\n\nUserStore.email = \"bob@example.com\"  # Triggers reaction\n# Prints: \"Syncing: Bob, bob@example.com\"\n</code></pre> <p>The function receives a snapshot of the entire Store. This is perfect for operations that need to consider the complete state\u2014saving to a database, logging changes, synchronizing with a server.</p> <p>Note the subtle difference: when reacting to individual observables, you get the values as arguments. When reacting to a Store, you get the Store snapshot itself as a single argument, and you access observables through it.</p>"},{"location":"tutorial/using-reactive/#reacting-to-computed-observables","title":"Reacting to Computed Observables","text":"<p>Everything that's an observable\u2014including computed ones\u2014works with <code>@reactive</code>:</p> <pre><code>class CartStore(Store):\n    items = observable([])\n\n# Computed observable\nitem_count = CartStore.items &gt;&gt; (lambda items: len(items))\n\n@reactive(item_count)\ndef update_badge(count):\n    print(f\"Cart badge: {count}\")\n\n# Doesn't run immediately - waits for first change\n\nCartStore.items = [{'name': 'Widget', 'price': 10}]\n# Computed value recalculates: 1\n# Reactive function runs: \"Cart badge: 1\"\n\nCartStore.items = CartStore.items + [{'name': 'Gadget', 'price': 15}]\n# Computed value recalculates: 2\n# Reactive function runs: \"Cart badge: 2\"\n</code></pre> <p>You don't react to <code>CartStore.items</code> directly. You react to the computed value. This is powerful: it means you only care about changes in the derived state, not every modification to the underlying data.</p> <p>If the computed value doesn't change, the reaction doesn't fire:</p> <pre><code>items = observable([1, 2, 3])\nlength = items &gt;&gt; (lambda i: len(i))\n\n@reactive(length)\ndef log_length(l):\n    print(f\"Length: {l}\")\n\nitems.set([4, 5, 6])  # Length is still 3, reaction doesn't fire\nitems.set([7, 8, 9, 10])  # Length is now 4, reaction fires\n</code></pre> <p>This is exactly what you want\u2014reactions tied to semantic meaning, not raw data changes.</p>"},{"location":"tutorial/using-reactive/#the-commitment-what-you-gain-and-what-you-give-up","title":"The Commitment: What You Gain and What You Give Up","text":"<p>Once you decorate a function with <code>@reactive</code>, you're making a commitment. The function becomes automatic\u2014it runs when its dependencies change. In exchange, you lose the ability to call it manually:</p> <pre><code>@reactive(count)\ndef log_count(value):\n    print(f\"Count: {value}\")\n\nlog_count(10)  # Raises fynx.reactive.ReactiveFunctionWasCalled exception\n</code></pre> <p>This isn't an arbitrary restriction. It's protecting you from confusion. If you could call <code>log_count()</code> manually and have it trigger automatically, which version of the value is authoritative? The manual call or the reactive update? The framework eliminates this ambiguity by enforcing one mode at a time.</p> <p>You can always change your mind, though. Call <code>.unsubscribe()</code> to sever the reactive connection and return the function to normal, non-reactive behavior:</p> <pre><code>@reactive(count)\ndef log_count(value):\n    print(f\"Count: {value}\")\n\ncount.set(5)   # Prints: \"Count: 5\"\n\nlog_count.unsubscribe()  # Severs the reactive connection\n\ncount.set(10)  # No output\u2014the function is no longer reactive\nlog_count(15)  # Prints: \"Count: 15\"\u2014now works as a normal function\n</code></pre> <p>After unsubscribing, the function reverts to its original, non-reactive form. You can call it manually again, and it will no longer respond to changes in its former dependencies.</p> <p>This lifecycle management is particularly important for component-based architectures:</p> <pre><code>class UIComponent:\n    def __init__(self):\n        self.count = observable(0)\n\n        @reactive(self.count)\n        def update_display(value):\n            print(f\"Display: {value}\")\n\n        self._update_display = update_display\n\n    def destroy(self):\n        # Clean up when component is destroyed\n        self._update_display.unsubscribe()\n</code></pre> <p>The pattern is simple: create reactive functions when you need them, unsubscribe when you're done. This prevents memory leaks and ensures reactions don't outlive the components they serve.</p>"},{"location":"tutorial/using-reactive/#practical-example-form-validation","title":"Practical Example: Form Validation","text":"<p>Here's where <code>@reactive</code> really shines\u2014coordinating complex UI behavior:</p> <pre><code>class FormStore(Store):\n    email = observable(\"\")\n    password = observable(\"\")\n    confirm_password = observable(\"\")\n\n# Computed validations\nemail_valid = FormStore.email &gt;&gt; (\n    lambda e: '@' in e and '.' in e.split('@')[-1]\n)\n\npassword_valid = FormStore.password &gt;&gt; (\n    lambda p: len(p) &gt;= 8\n)\n\npasswords_match = (FormStore.password + FormStore.confirm_password) &gt;&gt; (\n    lambda pwd, confirm: pwd == confirm and pwd != \"\"\n)\n\nform_valid = (email_valid &amp; password_valid &amp; passwords_match) &gt;&gt; (lambda x: x)\n\n# Reactive UI updates\n@reactive(email_valid)\ndef update_email_indicator(is_valid):\n    status = \"\u2713\" if is_valid else \"\u2717\"\n    print(f\"Email: {status}\")\n\n@reactive(password_valid)\ndef update_password_indicator(is_valid):\n    status = \"\u2713\" if is_valid else \"\u2717\"\n    print(f\"Password strength: {status}\")\n\n@reactive(passwords_match)\ndef update_match_indicator(match):\n    status = \"\u2713\" if match else \"\u2717\"\n    print(f\"Passwords match: {status}\")\n\n@reactive(form_valid)\ndef update_submit_button(is_valid):\n    state = \"enabled\" if is_valid else \"disabled\"\n    print(f\"Submit button: {state}\")\n\n# Reactive functions don't run immediately\n# Now update the form fields:\nFormStore.email = \"alice@example.com\"\n# Email: \u2713 (email indicator runs)\n\nFormStore.password = \"secure123\"\n# Password strength: \u2713 (password indicator runs)\n# Passwords match: \u2717 (match indicator runs - passwords don't match yet)\n\nFormStore.confirm_password = \"secure123\"\n# Passwords match: \u2713 (match indicator runs)\n# Submit button: enabled (form becomes valid)\n</code></pre> <p>Every UI element updates automatically in response to the relevant state changes. You never write \"when email changes, check if it's valid and update the indicator.\" You just declare the relationship and FynX handles the orchestration.</p> <p>Notice how we use the <code>&amp;</code> operator to create <code>form_valid</code>\u2014it only becomes true when all three conditions are met. The reactive function on <code>form_valid</code> only fires when something changes, giving you precise control over when the submit button updates.</p>"},{"location":"tutorial/using-reactive/#the-core-insight-where-reactive-belongs","title":"The Core Insight: Where @reactive Belongs","text":"<p>Here's the fundamental principle that makes reactive systems maintainable: <code>@reactive</code> is for side effects, not for deriving state.</p> <p>When you're tempted to use <code>@reactive</code>, ask yourself: \"Am I computing a new value from existing data, or am I sending information outside my application?\" If you're computing, you want <code>&gt;&gt;</code>, <code>+</code>, <code>&amp;</code>, or <code>~</code> operators. If you're communicating with the outside world, you want <code>@reactive</code>.</p> <p>This distinction creates what we call the \"functional core, reactive shell\" pattern. Your core is pure transformations\u2014testable, predictable, composable. Your shell is reactions\u2014the unavoidable side effects that make your application actually do something.</p> <pre><code># ===== FUNCTIONAL CORE (Pure) =====\nclass OrderCore(Store):\n    items = observable([])\n    shipping_address = observable(None)\n    payment_method = observable(None)\n    is_processing = observable(False)\n\n    # Pure derivations\u2014no side effects anywhere\n    subtotal = items &gt;&gt; (lambda i: sum(x['price'] * x['qty'] for x in i))\n    has_items = items &gt;&gt; (lambda i: len(i) &gt; 0)\n    has_address = shipping_address &gt;&gt; (lambda a: a is not None)\n    has_payment = payment_method &gt;&gt; (lambda p: p is not None)\n\n    # Boolean logic for conditions\n    can_checkout = (has_items &amp; has_address &amp; has_payment &amp; ~is_processing) &gt;&gt; (lambda x: x)\n\n    tax = subtotal &gt;&gt; (lambda s: s * 0.08)\n    total = (subtotal + tax) &gt;&gt; (lambda s, t: s + t)\n\n# ===== REACTIVE SHELL (Impure) =====\n@reactive(OrderCore.can_checkout)\ndef update_checkout_button(can_checkout):\n    button.disabled = not can_checkout\n\n@reactive(OrderCore.total)\ndef update_display(total):\n    render_total(f\"${total:.2f}\")\n\n# Only auto-save when we have items and aren't processing\n@reactive(OrderCore.has_items &amp; ~OrderCore.is_processing)\ndef auto_save(should_save):\n    if should_save:\n        save_to_db(OrderCore.to_dict())\n</code></pre> <p>Notice how the core is entirely composed of derivations\u2014values computed from other values. No database calls, no DOM manipulation, no network requests. These pure transformations are easy to test, easy to understand, and easy to change.</p> <p>The reactions appear only at the boundary. They're where your perfect functional world meets reality: updating a button's state, rendering to the screen, persisting to a database. The conditional operators let you express exactly when these side effects should occur, without polluting your core logic.</p>"},{"location":"tutorial/using-reactive/#best-practices-for-reactive","title":"Best Practices for @reactive","text":""},{"location":"tutorial/using-reactive/#use-reactive-for-side-effects-only","title":"Use @reactive for Side Effects Only","text":"<p>\u2705 USE @reactive for:</p> <p>Side Effects at Application Boundaries</p> <pre><code>@reactive(UserStore)\ndef sync_to_server(store):\n    # Network I/O\n    api.post('/user/update', store.to_dict())\n\n@reactive(settings_changed)\ndef save_to_local_storage(settings):\n    # Browser storage I/O\n    localStorage.setItem('settings', json.dumps(settings))\n</code></pre> <p>UI Updates (DOM manipulation, rendering)</p> <pre><code>@reactive(cart_total)\ndef update_total_display(total):\n    # DOM manipulation\n    render_total(f\"${total:.2f}\")\n</code></pre> <p>Logging and Monitoring</p> <pre><code>@reactive(error_observable)\ndef log_errors(error):\n    # Logging side effect\n    logger.error(f\"Application error: {error}\")\n    analytics.track('error', {'message': str(error)})\n</code></pre> <p>Cross-System Coordination (when one reactive system needs to update another)</p> <pre><code>@reactive(ThemeStore.dark_mode)\ndef update_editor_theme(is_dark):\n    # Coordinating separate systems\n    EditorStore.theme = 'dark' if is_dark else 'light'\n</code></pre> <p>\u274c AVOID @reactive for:</p> <p>Deriving State (use <code>&gt;&gt;</code>, <code>+</code>, <code>&amp;</code>, <code>~</code> instead)</p> <pre><code># BAD: Using @reactive for transformation\n@reactive(count)\ndef doubled_count(value):\n    doubled.set(value * 2)  # Modifying another observable\n\n# GOOD: Use functional transformation\ndoubled = count &gt;&gt; (lambda x: x * 2)\n</code></pre> <p>State Coordination (use computed observables)</p> <pre><code># BAD: Coordinating state in reactive functions\n@reactive(first_name, last_name)\ndef update_full_name(first, last):\n    full_name.set(f\"{first} {last}\")\n\n# GOOD: Express as derived state\nfull_name = (first_name + last_name) &gt;&gt; (lambda f, l: f\"{f} {l}\")\n</code></pre> <p>Business Logic (keep logic in pure transformations)</p> <pre><code># BAD: Business logic in reactive function\n@reactive(order_items)\ndef calculate_total(items):\n    total = sum(item.price * item.quantity for item in items)\n    tax = total * 0.08\n    order_total.set(total + tax)\n\n# GOOD: Business logic in pure transformation\norder_total = order_items &gt;&gt; (lambda items:\n    sum(i.price * i.quantity for i in items) * 1.08\n)\n</code></pre>"},{"location":"tutorial/using-reactive/#anti-patterns-to-avoid","title":"Anti-Patterns to Avoid","text":"<p>The infinite loop. When a reaction modifies what it's watching, you've created a feedback cycle:</p> <pre><code>count = observable(0)\n\n@reactive(count)\ndef increment_forever(value):\n    count.set(value + 1)  # Every change triggers another change\n</code></pre> <p>This is obvious in toy examples but can hide in real code when the dependency is indirect. The change semantics don't save you here\u2014each change triggers the reaction, which causes another change, ad infinitum.</p> <p>The hidden cache. When reactions maintain their own state, you've split your application's state across two systems:</p> <pre><code>results_cache = {}\n\n@reactive(query)\ndef update_cache(query_string):\n    results_cache[query_string] = fetch_results(query_string)\n</code></pre> <p>Now you have to remember that <code>results_cache</code> exists and keep it synchronized. Better to make the cache itself observable and derive from it.</p> <p>The sequential assumption. When reactions depend on each other's execution order, you've created fragile coupling:</p> <pre><code>shared_list = []\n\n@reactive(data)\ndef reaction_one(value):\n    shared_list.append(value)\n\n@reactive(data)\ndef reaction_two(value):\n    # Assumes reaction_one has already run\n    print(f\"List has {len(shared_list)} items\")\n</code></pre> <p>The second reaction assumes the first has already run. But that's an implementation detail, not a guarantee. If execution order changes, your code breaks silently.</p> <p>The fix for all three is the same: keep reactions independent and stateless. Let the observable system coordinate state. Keep reactions purely about effects.</p>"},{"location":"tutorial/using-reactive/#advanced-patterns-conditional-guards-and-cleanup","title":"Advanced Patterns: Conditional Guards and Cleanup","text":"<p>The conditional operators shine when you need to guard expensive or sensitive operations:</p> <pre><code>user = observable(None)\nhas_permission = observable(False)\nis_online = observable(False)\n\n# Only sync when user is logged in, has permission, and is online\n@reactive(user &amp; has_permission &amp; is_online)\ndef sync_sensitive_data(should_sync):\n    if should_sync and user.get():\n        api.sync_user_data(user.get().id)\n\n# Later, when you want to stop syncing entirely:\nsync_sensitive_data.unsubscribe()\n</code></pre> <p>The unsubscribe mechanism becomes particularly important in cleanup scenarios. If your reactive function represents a resource that needs explicit teardown (like a WebSocket connection or a file handle), you can unsubscribe when you're done to prevent further reactions and then perform cleanup in the function itself.</p>"},{"location":"tutorial/using-reactive/#reactive-vs-manual-subscriptions","title":"@reactive vs. Manual Subscriptions","text":"<p>When should you use <code>@reactive</code> instead of calling <code>.subscribe()</code> directly?</p> <p>Use <code>@reactive</code> when:</p> <p>You want declarative, self-documenting code:</p> <pre><code>@reactive(user_count)\ndef update_dashboard(count):\n    print(f\"Users: {count}\")\n</code></pre> <p>You're defining reactions at module level or class definition:</p> <pre><code>class UIController:\n    @reactive(AppStore.mode)\n    def sync_mode(mode):\n        update_ui_mode(mode)\n</code></pre> <p>You need lifecycle management with unsubscribe capability:</p> <pre><code>@reactive(data_stream)\ndef process_data(data):\n    handle_data(data)\n\n# Later, when component is destroyed\nprocess_data.unsubscribe()  # Clean up\n</code></pre> <p>Use <code>.subscribe()</code> when:</p> <p>You need dynamic subscriptions that change at runtime:</p> <pre><code>if user_wants_notifications:\n    count.subscribe(send_notification)\n</code></pre> <p>You need to unsubscribe conditionally:</p> <pre><code>subscription_func = count.subscribe(handler)\nif some_condition:\n    count.unsubscribe(subscription_func)\n</code></pre> <p>You're building a library that accepts observables:</p> <pre><code>def create_widget(data_observable):\n    data_observable.subscribe(widget.update)\n</code></pre> <p>The rule of thumb: <code>@reactive</code> for static, declarative reactions with optional cleanup via <code>.unsubscribe()</code>. <code>.subscribe()</code> for dynamic, programmatic subscriptions that you manage explicitly.</p>"},{"location":"tutorial/using-reactive/#gotchas-and-edge-cases","title":"Gotchas and Edge Cases","text":"<p>Infinite loops are possible</p> <pre><code># BAD: Modifying what you're watching\ncount = observable(0)\n\n@reactive(count)\ndef increment_forever(value):\n    count.set(value + 1)  # DON'T DO THIS\n</code></pre> <p>Solution: Reactive functions should perform side effects, not modify the observables they're watching. Use computed observables for transformations.</p> <p>Reactive functions don't track .get() or .value reads</p> <pre><code># BAD: Hidden dependency\nother_count = observable(10)\n\n@reactive(count)\ndef show_sum(value):\n    print(f\"Sum: {value + other_count.get()}\")  # Hidden dependency\n\ncount.set(5)  # Prints: \"Sum: 15\"\nother_count.set(20)  # Doesn't trigger show_sum - bug!\n</code></pre> <p>Solution: Make all dependencies explicit in the decorator.</p> <p>Reactive functions receive values, not observables</p> <pre><code># BAD: Trying to modify the value parameter\n@reactive(count)\ndef try_to_modify(value):\n    value.set(100)  # ERROR: value is an int, not an observable\n</code></pre> <p>Solution: Access the observable directly if you need to modify it (though you usually shouldn't).</p> <p>Store reactions receive snapshots</p> <pre><code>@reactive(UserStore)\ndef save_user(store):\n    # store is a snapshot of UserStore at this moment\n    # store.name is the current value, not an observable\n    save_to_db(store.name)  # Correct\n\n    # This won't work:\n    store.name.subscribe(handler)  # ERROR\n</code></pre> <p>Order-dependent reactions are fragile</p> <p>Express dependencies through computed observables instead of relying on execution order between multiple reactions.</p>"},{"location":"tutorial/using-reactive/#performance-considerations","title":"Performance Considerations","text":"<p>Reactive functions run synchronously on every change. For expensive operations, consider:</p> <p>Reacting to derived state that filters changes:</p> <pre><code>search_query = observable(\"\")\n\n# Only changes when meaningful\nfiltered_results = search_query &gt;&gt; (\n    lambda q: search_database(q) if len(q) &gt;= 3 else []\n)\n\n@reactive(filtered_results)\ndef update_ui(results):\n    display_results(results)\n</code></pre> <p>Using conditional observables to limit when reactions fire:</p> <pre><code>should_update = (user_active &amp; ~is_loading) &gt;&gt; (lambda x: x)\n\n@reactive(should_update)\ndef update_display(should):\n    if should:\n        expensive_render()\n</code></pre> <p>Conditional logic inside reactions:</p> <pre><code>@reactive(mouse_position)\ndef update_tooltip(position):\n    if should_show_tooltip(position):\n        expensive_tooltip_render(position)\n</code></pre>"},{"location":"tutorial/using-reactive/#summary","title":"Summary","text":"<p>The <code>@reactive</code> decorator transforms functions into automatic reactions that run whenever observables change:</p> <ul> <li>Declarative subscriptions \u2014 No manual <code>.subscribe()</code> calls to manage</li> <li>Runs on changes only \u2014 No initial execution; waits for first change (pullback semantics)</li> <li>Works with any observable \u2014 Standalone, Store attributes, computed values, merged observables</li> <li>Boolean operators for conditions \u2014 Use <code>&amp;</code>, <code>+</code>, <code>~</code> to create conditional reactions (like MobX's <code>when</code>)</li> <li>Multiple observable support \u2014 Derive combined observables first, then react</li> <li>Store-level reactions \u2014 React to any change in an entire Store</li> <li>Lifecycle management \u2014 Use <code>.unsubscribe()</code> to stop reactive behavior and restore normal function calls</li> <li>Prevents manual calls \u2014 Raises <code>fynx.reactive.ReactiveFunctionWasCalled</code> if called manually while subscribed</li> <li>Side effects, not state changes \u2014 Reactive functions should perform effects, not modify watched observables</li> </ul> <p>With <code>@reactive</code>, you declare what should happen when state changes. FynX ensures it happens automatically, in the right order, every time. This eliminates a whole category of synchronization bugs and makes your reactive systems self-maintaining.</p> <p>The rule of thumb here is that most of your code should be pure derivations using <code>&gt;&gt;</code>, <code>+</code>, <code>&amp;</code>, and <code>~</code>. Reactions with <code>@reactive</code> appear only at the edges, where your application must interact with something external. This separation\u2014the functional core, reactive shell pattern\u2014is what makes reactive systems both powerful and maintainable.</p>"}]}