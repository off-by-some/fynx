# Fynx Observable System - Product Specification for 1.0

Below is the roadmap for FynX. This represents what we believe is necessary for v1.0.0, but it is not set in stone — we welcome feedback and anticipate that the roadmap may evolve as we learn more and incorporate new ideas.

## Table of Contents

- [1. Overview](#1-overview)
- [2. Concurrency Model & Threading Behavior](#2-concurrency-model-threading-behavior)
  - [2.1 Serialized Propagation Architecture](#21-serialized-propagation-architecture)
  - [2.2 Thread-Safe Enqueueing](#22-thread-safe-enqueueing)
  - [2.3 Async/Await Integration](#23-asyncawait-integration)
  - [2.4 Propagation Guarantees](#24-propagation-guarantees)
  - [2.5 Performance Considerations](#25-performance-considerations)
  - [2.6 User Experience](#26-user-experience)
- [3. Core Observable Types](#3-core-observable-types)
  - [3.1 GenericObservable (Base Type)](#31-genericobservable-base-type)
  - [3.2 FiniteObservable&lt;T&gt;](#32-finiteobservablet)
  - [3.3 InfiniteObservable&lt;T&gt;](#33-infiniteobservablet)
  - [3.4 ConditionalObservable&lt;T&gt;](#34-conditionalobservablet)
  - [3.5 MergedObservable&lt;T&gt;](#35-mergedobservablet)
- [4. Operators](#4-operators)
  - [4.1 Transform Operator (`>>`)](#41-transform-operator)
  - [4.2 Merge Operator (`@`)](#42-merge-operator)
  - [4.3 Filter Method (`.where()`)](#43-filter-method-where)
  - [4.4 Push Operator (`<<`)](#44-push-operator)
  - [4.5 Subscribe Method (`.subscribe()`)](#45-subscribe-method-subscribe)
- [5. Boolean/Comparison Operators](#5-booleancomparison-operators)
  - [5.1 Boolean Logic Operators](#51-boolean-logic-operators)
  - [5.2 Comparison Operators](#52-comparison-operators)
- [6. Conditional Reactions with @reactive](#6-conditional-reactions-with-reactive)
- [7. Operator Summary Table](#7-operator-summary-table)
- [8. Design Principles](#8-design-principles)
- [9. Full Integration Example](#9-full-integration-example)
- [10. Edge Cases & Error Handling](#10-edge-cases-error-handling)


## 1. Overview
---

A reactive observable system providing type-safe, composable primitives for finite state management and infinite stream processing with Pythonic operator semantics. Features deterministic concurrency handling through serialized propagation.


## 2. Concurrency Model & Threading Behavior
---

### 2.1 Serialized Propagation Architecture

**Description**: All observables use an internal emission queue to ensure deterministic, race-free propagation regardless of emission source (sync thread, async coroutine, or background thread).

**Core Mechanism**:

1. Each observable (or the global system) maintains an internal emission queue
1. Any emission (via `obs << value`, assignment `obs = value`, or merged sources) enqueues the value
1. A single propagation worker consumes the queue sequentially
1. The worker recalculates derived observables, applies filters, and notifies subscribers in queue order
1. Worker can be a dedicated thread or the current thread in single-threaded contexts

**Acceptance Criteria**:

☐ All emissions are enqueued, never propagated directly on caller thread
☐ Propagation worker processes emissions sequentially in enqueue order
☐ Concurrent pushes from multiple threads/coroutines are serialized automatically
☐ No race conditions possible: subscribers never observe partial updates
☐ Merge order (`a @ b @ c`) determines transformation argument order deterministically
☐ Left-to-right evaluation: `(a @ b) @ c` processes `a`, then `b`, then `c` emissions in queue order

### 2.2 Thread-Safe Enqueueing

**Open Questions**:
* What is the non-sugar api for this?

**Acceptance Criteria**:

☐ Push operations (`<<`, assignment) are thread-safe
☐ Uses thread-safe queue implementation (`queue.Queue` or equivalent with locks)
☐ Multiple threads can emit concurrently without coordination
☐ Enqueue operation returns immediately (non-blocking for caller)
☐ Propagation happens asynchronously on worker thread/context

**Example**:

```python
stream = InfiniteObservable()

# Thread 1
stream << 1

# Thread 2 (concurrent)
stream << 2

# Both enqueued safely; propagated sequentially in arrival order
```


### 2.3 Async/Await Integration

**Acceptance Criteria**:

☐ Supports `asyncio` integration via `asyncio.Queue` for propagation
☐ Sync context emissions use `loop.call_soon_threadsafe()` to enqueue
☐ Async context emissions can directly await queue operations
☐ Propagation coroutine processes emissions sequentially
☐ Users can emit from sync or async contexts transparently
☐ Subscribers can be sync or async callbacks (system handles both)

**Example**:

```python
# Sync emission (from any thread)
stream << value  # Internally uses call_soon_threadsafe if async loop active

# Async emission
async def process():
    stream << await fetch_data()

# Async subscriber
async def async_handler(value):
    await save_to_db(value)

stream.subscribe(async_handler)  # System detects async and handles appropriately
```

### 2.4 Propagation Guarantees

**Acceptance Criteria**:

☐ **Deterministic ordering**: Emissions processed in exact enqueue order
☐ **Atomic propagation**: Each emission propagates completely before next emission starts
☐ **No race conditions**: Derived observables never see partial/inconsistent state
☐ **Subscriber safety**: All subscribers receive same value in same propagation cycle
☐ **Single propagation per emission**: Each emission triggers exactly one propagation pass
☐ **Merge consistency**: Left-to-right merge order preserved across all propagations

**Example**:

```python
a = observable(1)
b = observable(2)
merged = a @ b
result = merged >> (lambda x, y: x + y)  # x from a, y from b (deterministic)

# Thread 1
a = 10

# Thread 2 (concurrent)
b = 20

# Result sees either (10, 2) or (1, 20) or (10, 20)
# Never partial like (10, <uninitialized>)
# Order determined by queue arrival, but always consistent
```

### 2.5 Performance Considerations

**Latency**:

☐ Slight overhead vs direct synchronous propagation (typically microseconds)
☐ Negligible for most applications
☐ Configurable queue processing batch size for high-throughput scenarios

**Backpressure**:

☐ Optional max queue size to prevent unbounded memory growth
☐ Configurable overflow strategies: block, drop oldest, drop newest, raise error
☐ Monitoring API for queue depth inspection

**Example**:

```python
# Configure backpressure (optional)
stream = InfiniteObservable(max_queue_size=1000, overflow='drop_oldest')

# Monitor queue health
if stream.queue_depth() > 900:
    warnings.warn("Observable queue near capacity")
```

### 2.6 User Experience

**Acceptance Criteria**:

☐ No API changes required for threading/async support
☐ System automatically detects execution context (sync/async, thread)
☐ Users never need to manage locks, mutexes, or async context explicitly
☐ Standard operators (`<<`, `=`, `>>`, `@`) work identically regardless of threading
☐ Subscribers always see sequential, deterministic updates
☐ Optional configuration for advanced use cases (queue size, worker threads)

**Example**:

```python
# Works identically in all contexts
stream << value  # Sync thread
stream << value  # Async coroutine
stream << value  # Background thread

# User never sees:
# - Race conditions
# - Partial updates
# - Lock/mutex management
# - async/await complexity (unless desired)
```



## 3. Core Observable Types
---

### 3.1 GenericObservable (Base Type)

**Description**: Abstract supertype for all observable types. Provides common interface and enables polymorphic operations across all observable subtypes.

**Acceptance Criteria**:

☐ All observable types inherit from `GenericObservable`
☐ All operators (`>>`, `@`, `.where()`, `.subscribe()`) work on `GenericObservable` instances regardless of concrete subtype
☐ Type system is transparent to users - operations return appropriate concrete types without requiring type-specific logic
☐ Generic observables can be composed with any other generic observable using standard operators
☐ Runtime type determination follows documented promotion rules (e.g., Finite + Infinite → Infinite)
☐ All emissions go through serialized propagation queue (see Section 2)


### 3.2 FiniteObservable<T>

**Description**: Single-valued reactive cell holding current value from discrete domain with serialized propagation.

**Acceptance Criteria**:

☐ Holds exactly one value of type `T` at any moment
☐ Assignment enqueues value for propagation (not direct synchronous)
☐ Can be created via `observable(initial_value)` factory function
☐ Supports `obs = new_value` assignment syntax (thread-safe)
☐ Reading `.value` returns current value without triggering propagation
☐ Used as Store class property decorator: `property_name = observable(default)`
☐ All dependent observables recalculate atomically during propagation worker pass
☐ Thread-safe: can be assigned from any thread

**Example**:

```python
counter = observable(5)
doubled = counter >> (lambda x: x * 2)
counter = 10  # Enqueued; doubled becomes 20 after propagation
```


### 3.3 InfiniteObservable<T>

**Description**: Unbounded stream of values emitted asynchronously over time with serialized propagation.

**Acceptance Criteria**:

☐ Maintains sequence of emissions with no defined “final” value
☐ Created via `InfiniteObservable()` constructor
☐ Supports `<<` push operator: `stream << value` (thread-safe)
☐ Supports merging another stream: `stream << other_stream`
☐ Each emission enqueued and triggers downstream propagation independently
☐ **Concurrent emissions are serialized**: multiple threads can push simultaneously
☐ Emissions processed in queue arrival order
☐ Can emit zero or more values over lifetime
☐ Can merge with transformed streams: `stream << upload.map(fn)`
☐ Push operations are non-blocking (return immediately after enqueueing)

**Memory Management**:

☐ Subscriptions maintain reference to observable
☐ Unsubscribing releases subscription reference but not observable
☐ Long-lived infinite observables should be explicitly disposed when no longer needed
☐ Consider weak references for subscriber management to prevent memory leaks

**Concurrent Emission Example**:

```python
stream = InfiniteObservable()

# Thread 1
for i in range(100):
    stream << i

# Thread 2 (concurrent)
for i in range(100, 200):
    stream << i

# Thread 3 (concurrent)
for i in range(200, 300):
    stream << i

# All 300 emissions safely enqueued and propagated sequentially
# Subscribers see values in queue arrival order (deterministic per run)
```


### 3.4 ConditionalObservable<T>

**Description**: Wrapper that filters emissions from source observable based on predicate with propagation queue integration.

**Acceptance Criteria**:

**Core Filtering**:

☐ Created via `.where(predicate)` method on any observable
☐ Predicate signature: `T → Bool`
☐ Only propagates emissions where `predicate(value) == True`
☐ Predicate evaluation happens in propagation worker context
☐ Preserves source type: `FiniteObservable.where()` → `FiniteObservable`
☐ Preserves source type: `InfiniteObservable.where()` → `InfiniteObservable`
☐ Thread-safe: source emissions can come from any thread

**Finite Source Semantics**:

☐ Evaluates condition during propagation worker pass
☐ Suppresses downstream propagation when condition is `False`
☐ No retroactive evaluation of past assignments

**Infinite Source Semantics**:

☐ Acts as stream filter during propagation
☐ Does not affect previously emitted values
☐ Each emission independently evaluated against predicate in worker context

**Dynamic Conditions**:

☐ Accepts observable predicates: `.where(condition_observable)`
☐ Gates emissions based on current value of condition observable at propagation time
☐ For finite sources: checks condition during propagation worker pass
☐ For infinite sources: checks condition during propagation of each emission

**Composition**:

☐ Chained `.where()` calls compose with AND logic
☐ `source.where(P1).where(P2)` equivalent to `source.where(lambda x: P1(x) and P2(x))`
☐ Derived observables inherit conditional propagation

**Example**:

```python
stream = InfiniteObservable()
evens = stream.where(lambda x: x % 2 == 0)

# Thread-safe concurrent pushes
stream << 1  # suppressed during propagation
stream << 2  # evens emits 2 during propagation
stream << 3  # suppressed
stream << 4  # evens emits 4

condition = observable(True)
gated = stream.where(condition)  # Checks condition at propagation time
```


### 3.5 MergedObservable<T>

**Description**: Unified emission stream combining multiple source observables with deterministic propagation order.

**Acceptance Criteria**:

**Core Merging**:

☐ Created via `@` operator: `obs1 @ obs2 @ obs3`
☐ Accepts 2+ source observables of same type `T`
☐ Emits union of all source emissions: `⋃ᵢ emissions(sᵢ)`
☐ **Merge order is deterministic and left-to-right**: `(a @ b) @ c` always processes `a`, then `b`, then `c`
☐ Interleaves emissions in queue arrival order (within propagation worker)
☐ Concurrent emissions from different sources serialized by propagation queue

**Type Determination**:

☐ All finite sources → `FiniteObservable<T>`
☐ All infinite sources → `InfiniteObservable<T>`
☐ Mixed finite + infinite → `InfiniteObservable<T>` (most dynamic type wins)

**Finite Source Behavior**:

☐ Each source assignment enqueued for propagation
☐ Merged result emits during propagation pass
☐ Sequential assignments preserve per-source ordering in queue

**Infinite Source Behavior**:

☐ Each emission enqueued independently
☐ Emissions interleaved in queue arrival order
☐ Thread-safe: sources can emit from different threads concurrently

**Mixed Source Behavior**:

☐ Finite sources contribute current value snapshot during propagation
☐ Infinite sources contribute ongoing emissions via queue
☐ Result exhibits both discrete and continuous characteristics

**Edge Cases**:

☐ Empty merge `MergedObservable()` with no sources raises `ValueError`
☐ Single source merge `MergedObservable(s)` returns identity (equivalent to `s`)

**Algebraic Properties**:

☐ Identity: `MergedObservable(s) ≡ s`
☐ Associativity: `(a @ b) @ c ≡ a @ (b @ c)`
☐ Type closure: Result is always an observable
☐ **Deterministic ordering**: merge order determines transformation argument order (guaranteed by propagation queue)

**Concurrent Emission Example**:

```python
stream1 = InfiniteObservable()
stream2 = InfiniteObservable()
merged = stream1 @ stream2

# Thread 1
stream1 << "A1"
stream1 << "A2"

# Thread 2 (concurrent)
stream2 << "B1"
stream2 << "B2"

# Propagation worker sees queue like: [A1, B1, A2, B2] (example order)
# Subscribers see deterministic sequence based on queue arrival
# Transform receives arguments in merge order (stream1 first, stream2 second)

result = merged >> (lambda v1, v2: f"{v1}+{v2}")
# v1 always from stream1, v2 always from stream2 (deterministic merge order)
```



## 4. Operators
---

### 4.1 Transform Operator (`>>`)

**Description**: Creates derived observable by applying transformation function during propagation. **Never mutates source observable.**

**Acceptance Criteria**:

☐ Signature: `Observable<T> >> (T → U) → Observable<U>`
☐ Works on `GenericObservable` regardless of concrete type
☐ **Always creates new observable**; source remains unchanged
☐ Derived observable recalculates during propagation worker pass
☐ Supports chaining: `obs >> f >> g >> h`
☐ Lazy evaluation: computes only during propagation pass
☐ Type preservation: Finite → Finite, Infinite → Infinite
☐ Multi-argument functions receive values in merge order (deterministic, left-to-right, guaranteed by propagation queue)
☐ Chained transformations compose left-to-right
☐ Transformation function called once per emission/update during propagation
☐ Thread-safe: source emissions can originate from any thread

**Example**:

```python
result = counter >> (lambda x: x * 2) >> (lambda x: x + 10)
# counter unchanged; result is new observable
# Transformation happens in propagation worker

total = (count @ price) >> (lambda c, p: c * p)
# c=count, p=price (merge order, deterministic even with concurrent updates)
```


### 4.2 Merge Operator (`@`)

**Description**: Combines multiple observables into unified stream with deterministic propagation order.

**Acceptance Criteria**:

☐ Signature: `Observable<T> @ Observable<T> → MergedObservable<T>`
☐ Works on `GenericObservable` instances
☐ Accepts 2+ operands: `a @ b @ c`
☐ Associative: `(a @ b) @ c ≡ a @ (b @ c)`
☐ **Deterministic left-to-right merge order preserved** for downstream transformations (guaranteed by propagation queue)
☐ Result type follows type determination rules (section 3.5)
☐ Can be chained with `>>`: `(a @ b) >> transform_fn`
☐ Raises `ValueError` if called with zero operands
☐ Thread-safe: operands can emit from different threads concurrently

**Example**:

```python
combined = obs1 @ obs2 @ obs3
result = combined >> (lambda v1, v2, v3: v1 + v2 + v3)
# v1=obs1, v2=obs2, v3=obs3 (deterministic merge order)
# Works correctly even if obs1, obs2, obs3 updated from different threads
```


### 4.3 Filter Method (`.where()`)

**Description**: Creates conditional observable filtering emissions during propagation.

**Acceptance Criteria**:

☐ Signature: `Observable<T>.where(T → Bool) → ConditionalObservable<T>`
☐ Signature (dynamic): `Observable<T>.where(Observable<Bool>) → ConditionalObservable<T>`
☐ Works on `GenericObservable`
☐ Returns `ConditionalObservable` preserving source type (Finite/Infinite)
☐ Chainable: `obs.where(p1).where(p2)` applies AND logic
☐ Can be combined with other operators: `obs.where(pred) >> transform`
☐ Predicate evaluation happens in propagation worker context
☐ Thread-safe: source can emit from any thread

**Example**:

```python
positives = counter.where(lambda x: x > 0)
evens = stream.where(lambda x: x % 2 == 0)
filtered = obs.where(p1).where(p2) >> transform
# All predicates evaluated during propagation worker pass
```


### 4.4 Push Operator (`<<`)

**Description**: Thread-safe emission into infinite observable stream via propagation queue.

**Acceptance Criteria**:

☐ Signature: `InfiniteObservable<T> << T → None`
☐ Signature (merge): `InfiniteObservable<T> << Observable<T> → None`
☐ Only valid for `InfiniteObservable` instances
☐ Pushes single value: `stream << value` (enqueues for propagation)
☐ Merges another observable: `stream << other_observable`
☐ **Thread-safe**: can be called from any thread concurrently
☐ Non-blocking: returns immediately after enqueueing
☐ Triggers downstream propagation during worker pass
☐ Returns `None` (side-effect only)

**Example**:

```python
stream << 42  # Thread-safe, enqueued
stream << (upload >> process)  # Merge enqueued

# Concurrent pushes (safe)
threading.Thread(target=lambda: stream << 1).start()
threading.Thread(target=lambda: stream << 2).start()
# Both enqueued; propagated sequentially by worker
```


### 4.5 Subscribe Method (`.subscribe()`)

**Description**: Registers callback to react to observable changes during propagation.

**Acceptance Criteria**:

☐ Signature: `Observable<T>.subscribe(T → None) → Subscription`
☐ Works on `GenericObservable`
☐ Callback invoked during propagation worker pass for each emission/update
☐ Returns subscription object for unsubscription
☐ Subscription has `.unsubscribe()` method
☐ Multiple subscribers supported per observable
☐ Callbacks receive current/emitted value as argument
☐ Callbacks execute in propagation worker context (thread-safe by design)
☐ **All subscribers see same value in same propagation cycle** (no races)

**Memory Management**:

☐ Subscription maintains reference to observable and callback
☐ Calling `.unsubscribe()` releases callback reference
☐ Observable maintains weak references to subscriptions where possible
☐ Unsubscribing does not dispose the observable itself
☐ Subscribers should explicitly unsubscribe when done to prevent memory leaks

**Example**:

```python
subscription = obs.subscribe(lambda x: print(f"Value: {x}"))
# Callback invoked in propagation worker context (safe)

subscription.unsubscribe()  # Release callback reference
```



## 5. Boolean/Comparison Operators
---

### 5.1 Boolean Logic Operators

**Description**: Native boolean operations on observables producing reactive boolean results with propagation queue semantics.

**Acceptance Criteria**:

☐ `&` operator: `obs1 & obs2` returns observable evaluating AND during propagation
☐ `|` operator: `obs1 | obs2` returns observable evaluating OR during propagation (distinct from merge `@`)
☐ `~` operator: `~obs` returns observable negating value during propagation
☐ Operators work element-wise on current values at propagation time
☐ For finite sources: produces `FiniteObservable<bool>`
☐ For infinite sources: produces stream of boolean evaluations per emission
☐ Results are fully reactive: update during propagation when any operand changes
☐ Works on `GenericObservable` instances
☐ Thread-safe: operands can be updated from different threads

**Mixed Type Behavior**:

☐ `FiniteObservable<bool> & InfiniteObservable<bool>` → `InfiniteObservable<bool>`
☐ Finite operand provides current value snapshot; infinite operand drives emission timing
☐ Result emits on each infinite stream emission, using latest finite value at propagation time

**Example**:

```python
ready = uploaded & valid & (~processing)
any_active = stream1 | stream2  # Boolean OR, not merge
# All evaluations happen in propagation worker (thread-safe)
```


### 5.2 Comparison Operators

**Description**: Comparison operators for observables returning reactive boolean observables with propagation semantics.

**Acceptance Criteria**:

☐ Supports: `==`, `!=`, `<`, `<=`, `>`, `>=`
☐ Signature: `Observable<T> {op} T → Observable<bool>`
☐ Signature: `Observable<T> {op} Observable<T> → Observable<bool>`
☐ Returns reactive boolean observable
☐ Evaluates comparison during propagation worker pass
☐ Works with `@reactive` decorator and standalone
☐ Works on `GenericObservable`
☐ Thread-safe: operands can be updated from different threads

**Mixed Type Behavior**:

☐ `FiniteObservable<T> >= InfiniteObservable<T>` → `InfiniteObservable<bool>`
☐ `InfiniteObservable<T> >= FiniteObservable<T>` → `InfiniteObservable<bool>`
☐ Finite operand provides current value snapshot at propagation time
☐ Infinite operand drives emission timing
☐ Each emission from infinite side triggers comparison with latest finite value during propagation
☐ `FiniteObservable<T> >= FiniteObservable<T>` → `FiniteObservable<bool>` (updates when either changes)
☐ `InfiniteObservable<T> >= InfiniteObservable<T>` → `InfiniteObservable<bool>` (emits when either emits)

**Example**:

```python
is_adult = age >= 18
is_equal = obs1 == obs2
matches = name == "Alice"

# Mixed types
exceeded = infinite_sensor >= finite_threshold  # InfiniteObservable<bool>
# Comparison happens in propagation worker using latest finite_threshold value
```



## 6. Conditional Reactions with @reactive
---

**Description**: Use @reactive with conditional observables to create event-driven reactions that trigger when specific conditions are met.

**Acceptance Criteria**:

☐ Use @reactive with conditional observables created with `&` operator
☐ Conditional observables emit when conditions are met
☐ @reactive functions receive boolean values indicating condition state
☐ Supports complex boolean logic through computed observables
☐ Re-evaluates reactively when any observable in the condition changes
☐ **Thread-safe**: conditions evaluated in propagation worker context, safe from races

**Execution Semantics**:

☐ Function executes in propagation worker context when conditional observable emits
☐ No automatic debouncing or coalescing (user can implement if needed)
☐ If multiple observables change concurrently, executes once during propagation with latest values

**Example**:

```python
# Create conditional observables
is_adult = User.age >> (lambda age: age >= 18)
has_valid_email = User.email >> (lambda email: email.endswith('.com'))
is_eligible = is_adult & has_valid_email

@reactive(is_eligible)
def process_eligible_user(is_eligible_state):
    if is_eligible_state:
        print("Eligible user detected!")
# Triggers during propagation when conditions become True
# Safe even if User.age and User.email updated from different threads

# Complex conditions
sensor_condition = (sensor_reading >> (lambda r: r > threshold)) & sensor_active
@reactive(sensor_condition)
def alert(is_alert):
    if is_alert:
        print("Alert!")
# Triggers during propagation on each emission where condition is True
# Evaluation happens in propagation worker (thread-safe)
```



## 7. Operator Summary Table
---

| Operator | Signature | Description | Example |
|----------|-----------|-------------|---------|
| `>>` | `Observable<T> >> (T → U) → Observable<U>` | Transform values (creates new observable) | `doubled = x >> (lambda v: v * 2)` |
| `\|` | `Observable<T> \| Observable<U> → MergedObservable<T,U>` | Merge observables (deterministic order) | `combined = a \| b` |
| `<<` | `InfiniteObservable<T> << T → None` | Thread-safe push to stream (enqueued) | `stream << value` |
| `.subscribe()` | `Observable<T>.subscribe(T → None) → Subscription` | React to changes during propagation | `obs.subscribe(print)` |
| `&` | `Observable<bool> & Observable<bool> → Observable<bool>` | Boolean AND (evaluated during propagation) | `ready = a & b` |
| `~` | `~Observable<bool> → Observable<bool>` | Boolean NOT (evaluated during propagation) | `inactive = ~active` |
| `==`, `!=`, `<`, `<=`, `>`, `>=` | `Observable<T> {op} T → Observable<bool>` | Comparison (evaluated during propagation) | `adult = age >= 18` |



## 8. Design Principles
---

**Acceptance Criteria**:

☐ **Type preservation**: Operations preserve or predictably promote types per documented rules
☐ **Composability**: All operators support nesting and chaining
☐ **Transparency**: Internal taxonomy hidden from users; all operations work on `GenericObservable`
☐ **Immutability**: Transformations always create new observables; sources never mutated
☐ **Determinism**: Merge order is left-to-right and consistent; propagation queue ensures sequential processing
☐ **Algebraic rigor**: Identity, associativity, and type closure properties maintained
☐ **Pythonic elegance**: Uses familiar Python operators and method chaining
☐ **Accessibility**: No category theory knowledge required; intuitive semantics
☐ **Memory safety**: Clear subscription lifecycle; explicit cleanup prevents leaks
☐ **Concurrency safety**: Serialized propagation queue eliminates race conditions; thread-safe by design
☐ **Performance**: Minimal latency overhead; configurable backpressure handling



## 9. Full Integration Example
---

**Acceptance Criteria**:

☐ Following example works end-to-end with all specified features including threading:

```python
class CartStore(Store):
    item_count = observable(1)
    price_per_item = observable(10.0)
    discount_active = observable(False)

# Merge observables (@ operator, deterministic order, thread-safe)
cart_state = CartStore.item_count @ CartStore.price_per_item

# Calculate subtotal (immutable transform, propagated via queue)
subtotal = cart_state >> (lambda count, price: count * price)

# Apply discount conditionally (evaluated during propagation)
final_price = (subtotal @ CartStore.discount_active) >> \
    (lambda total, discount: total * 0.9 if discount else total)

# Subscribe to updates (callback runs in propagation worker context)
subscription = final_price.subscribe(lambda price: print(f"Total: ${price:.2f}"))

# Changes propagate automatically via queue (thread-safe)
CartStore.item_count = 3           # Enqueued → Total: $30.00
CartStore.discount_active = True   # Enqueued → Total: $27.00

# Thread-safe concurrent updates
import threading
threading.Thread(target=lambda: CartStore.item_count = 5).start()
threading.Thread(target=lambda: CartStore.price_per_item = 15.0).start()
# Both enqueued; propagated sequentially; final_price sees consistent state

# Cleanup
subscription.unsubscribe()

# Boolean operators (| for OR, @ for merge)
preview_ready = uploaded_file & is_valid & (~is_processing)
any_error = validation_error | network_error  # Boolean OR

# Mixed type comparisons with concurrent emissions
sensor_stream = InfiniteObservable()
threshold = observable(100)
alert_stream = sensor_stream >= threshold  # InfiniteObservable<bool>

# Thread-safe concurrent sensor updates
def sensor_thread():
    for reading in sensor_readings:
        sensor_stream << reading  # Thread-safe push

threading.Thread(target=sensor_thread).start()

# Conditional reactive (reactive, per-emission trigger, thread-safe)
is_adult = User.age >> (lambda age: age >= 18)
has_valid_email = User.email >> (lambda email: email.endswith('.com'))
is_eligible = is_adult & has_valid_email

@reactive(is_eligible)
def process_eligible_user(is_eligible_state):
    if is_eligible_state:
        print("Eligible user detected!")
# Conditions evaluated in propagation worker (safe from races)
```



## 10. Edge Cases & Error Handling

**Acceptance Criteria**:

**Empty Merge**:

☐ `MergedObservable()` with no sources raises `ValueError` with message: “Cannot create merge with zero sources”
☐ `a @ b @ ...` with at least one operand succeeds

**Mixed Type Merges**:

☐ `FiniteObservable @ InfiniteObservable` produces `InfiniteObservable` (documented in 3.5)
☐ Finite values emit immediately via queue, infinite values emit over time via queue
☐ ConditionalObservable wrapping MergedObservable preserves result type rules

**Type Mismatches**:

☐ Merging incompatible types (e.g., `Observable<int> @ Observable<str>`) raises `TypeError`
☐ Comparison operators require comparable types or raise `TypeError`

**Null/None Handling**:

☐ Observables can hold `None` as valid value
☐ Predicates/transforms receive `None`
